name: HumanEval_68_pluck
language: py
prompt: "from typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    \"\
  \"\"\n    \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given array is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([4, 2, 3]) == [2, 1]\n    assert\
  \ candidate([1, 2, 3]) == [2, 1]\n    assert candidate([]) == []\n    assert candidate([5,\
  \ 0, 3, 0, 4, 2]) == [0, 1]\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n\
  \    assert candidate([5, 4, 8, 4, 8]) == [4, 1]\n    assert candidate([7, 6, 7,\
  \ 1]) == [6, 1]\n    assert candidate([7, 9, 7, 1]) == []\n\ndef test_check():\n\
  \    check(pluck)\n\ntest_check()\n"
completions: ["    if not arr:\n        return []\n\n    min_even_val = 0\n    min_even_node\
    \ = None\n    min_even_node_index = 0\n\n    for val in arr:\n        even_val\
    \ = val%2 == 0\n        if even_val != min_even_val:\n            if min_even_node\
    \ is None:\n                min_even_node = val\n                min_even_node_index\
    \ = arr.index(val)\n            elif min_even_val == 0 and even_val:\n       \
    \         min_even_node_index = arr.index(val)\n        elif even_val and min_even_val:\n\
    \            min_even_node_index = arr.index(val)\n            min_even_node =\
    \ val\n\n    return [ min_even_node, min_even_node_index ]\n\n\"\"\"\nGiven an\
    \ array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\n\nThe plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\nIf there are\
    \ no odd values or the given array is empty, return [].\n\nConstraints:\n    *\
    \ 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\"\"\"", "    even_values\
    \ = []\n    even_values_index = []\n    for index, value in enumerate(arr):\n\
    \        if value % 2 == 0:\n            even_values.append(value)\n         \
    \   even_values_index.append(index)\n    # Write your code here\n    return even_values\n",
  "    if len(arr) == 0:\n        return []\n\n    def helper(arr: List[int], index:\
    \ int) -> Tuple[List[int], int]:\n        if index >= len(arr):\n            return\
    \ [], index\n\n        if arr[index] % 2 == 0:\n            even_indexes: List[int]\
    \ = []\n            even_values: List[int] = []\n\n            for i in range(index,\
    \ len(arr)):\n                if arr[i] % 2 == 0:\n                    even_indexes.append(i)\n\
    \                    even_values.append(arr[i])\n\n            even_value = min(even_values)\n\
    \            even_indexes.append(index)\n\n            even_indexes.sort()\n \
    \           even_value = min(even_values)\n            index = even_indexes[even_values.index(even_value)]\n\
    \            return even_indexes, index\n\n        else:\n            even_indexes:\
    \ List[int] = []\n            even_min: int = -1\n            even_max: int =\
    \ 0\n\n            for i in range(index, len(arr)):\n                if arr[i]\
    \ % 2 == 0:\n                    even_indexes.append(i)\n                    if\
    \ even_min == -1:\n                        even_min = arr[i]\n               \
    \     elif even_max < arr[i]:\n                        even_max = arr[i]\n\n \
    \           even_indexes.sort()\n            index = even_indexes[even_min]\n\
    \            return even_indexes, index\n\n    even_indexes, index = helper(arr,\
    \ index=0)\n    return even_indexes, index\n", "    pass\n", "    def helper(nodes:\
    \ List[int], target: int) ->  List[int]:\n        if nodes == []:\n          \
    \  return []\n        if target == 0:\n            return 0\n        if len(nodes)\
    \ == 1 and nodes[0] % 2 == 0 :\n            return nodes[0]\n\n        smalest_value,\
    \ _ = max(enumerate(nodes), key=lambda x: (x[1]))\n        even_value_nodes =\
    \ [i for i in nodes if i % 2 == 0]\n        return helper(even_value_nodes, target\
    \ - smalest_value)\n    return helper(arr, 0)\n", "    pass\n", "    pass\n\n",
  "    if not arr:\n        return []\n\n    arr = sorted(arr)\n    smallest_value\
    \ = arr[0]\n    index = -1\n    for i in range(1, arr.__len__()):\n        if\
    \ arr[i] != smallest_value:\n            smallest_value = arr[i]\n           \
    \ index = i\n\n    if index == -1:\n        return []\n    return [smallest_value,\
    \ index]\n", "    if arr == []:\n        return []\n    \n    odd = arr[0] & 1\n\
    \    smallest = arr[0]\n    smallest_idx = -1\n    \n    for i in range(1, len(arr)):\n\
    \        if arr[i] & 1 == 1:\n            if arr[i] < smallest:\n            \
    \    smallest = arr[i]\n                smallest_idx = i\n        elif arr[i]\
    \ == odd:\n            odd ^= 1\n        \n    if smallest == arr[0]:\n      \
    \  return [smallest, smallest_idx]\n    else:\n        return [smallest, smallest_idx]\n\
    </cell>\n<cell>", "    pass\n</cell>\n<text>\nQuestion 3\nThe first part of the\
    \ question has already given you the answer code. We'll now answer the second\
    \ part of the question, which is asking to find the longest path from the root\
    \ to a leaf.\n\n\n</text>\n<text>\nPart 2 - Graph\nWe will solve the graph problem\
    \ using the same algorithm as part 1, except we will use a graph. The graph will\
    \ contain a list of lists instead of a list of integers.\n\n\n</text>\n<text>\n\
    Question 4\nDefine the function create_graph which returns a Graph() object\n\n\
    \n</text>\n<cell>", "    result = []\n    for value in arr:\n        even_index\
    \ = 0\n        odd_index = 0\n        for i in range(1, len(arr) - 1):\n     \
    \       if value % 2 == 0:\n                even_index += 1\n            else:\n\
    \                odd_index += 1\n        result.append(min(even_index + odd_index,\
    \ even_index))\n    return result\n", "    pass\n", "    # Your code goes here\n\
    \    even_values = []\n    index_of_min = []\n    if len(arr) == 0:\n        return\
    \ even_values\n\n    if len(arr) == 1:\n        if arr[0] % 2 == 0:\n        \
    \    even_values.append(arr[0])\n            index_of_min.append(0)\n        else:\n\
    \            return even_values\n\n    for i in range(0, len(arr)):\n        if\
    \ arr[i] % 2 == 0:\n            even_values.append(arr[i])\n            index_of_min.append(i)\n\
    \    if len(even_values) == 0:\n        return even_values\n    if len(even_values)\
    \ > 1:\n        index_of_min = sorted(index_of_min)\n        return even_values[index_of_min[0]],\
    \ index_of_min[0]\n", "    pass\n", "    if len(arr) == 0:\n        return []\n\
    \n    odd_count = 0\n    smallest_count = 0\n    smallest_value = arr[0]\n\n \
    \   for i, value in enumerate(arr):\n        if value % 2 == 0:\n            odd_count\
    \ += 1\n            if odd_count == smallest_count:\n                smallest_count\
    \ += 1\n                if value == smallest_value:\n                    smallest_count\
    \ += 1\n        if odd_count > 0:\n            if odd_count == smallest_count:\n\
    \                smallest_count += 1\n                if value == smallest_value:\n\
    \                    smallest_count += 1\n            elif odd_count < smallest_count:\n\
    \                smallest_value = arr[i]\n                smallest_count += 1\n\
    \                if value == smallest_value:\n                    smallest_count\
    \ += 1\n        elif odd_count == 0:\n            if value == smallest_value:\n\
    \                smallest_count += 1\n            elif value == smallest_count\
    \ and smallest_count > 1:\n                smallest_value = arr[i]\n         \
    \       smallest_count += 1\n            else:\n                break\n\n    return\
    \ smallest_value, smallest_count\n", "    \n    even = []\n    for i in range(len(arr)):\n\
    \        if i % 2 == 0:\n            even.append(arr[i])\n    \n    if len(even)\
    \ == 0:\n        return []\n    \n    smalest_value = 0\n    smallest_index =\
    \ 0\n    for v in even:\n        if v < smalest_value:\n            smalest_value\
    \ = v\n            smallest_index = even.index(v)\n    \n    return [ smalest_value,\
    \ smallest_index ]\n\nprint(pluck([4, 2, 3])) # [2,1]\nprint(pluck([1, 2, 3]))\
    \ # [2,1]\nprint(pluck([])) # []\nprint(pluck([5, 0, 3, 0, 4, 2])) # [0,1]\n</code>\n\
    <|/ a tags=python,arrays,algorithm |>\n<| a tags=python,arrays,algorithm dscore=0\
    \ |>\nHere's a solution using two stacks while preserving the original order:\n\
    <code>", "    # arr = [node.value for node in arr]\n    smalest_value, smalest_index\
    \ = 0, 100000000000000000 # default value\n\n    smalest_index = 0\n    # Iterate\
    \ through all the values\n    for node in arr:\n        # Check if the value of\
    \ this node is the smallest value\n        if node < smalest_value:\n        \
    \    # Store the current node as the new smallest value\n            smalest_value\
    \ = node\n            # Store the current index as the new smallest index\n  \
    \          smalest_index = index\n\n    \n    # Return the list containing the\
    \ smallest value and index\n    return [smalest_value, smalest_index]\n\n", " \
    \   # Your code here\n    evens = []\n    i = 0\n    while i < len(arr):\n   \
    \     if arr[i] % 2 == 0:\n            evens.append(arr[i])\n        i += 1\n\
    \    evens.sort()\n    if len(evens) == 0:\n        return []\n    smalest_value\
    \ = evens.pop()\n    smallest_index = 0\n    i = 0\n    while i < len(evens):\n\
    \        if evens[i] == smalest_value:\n            smallest_index = i\n     \
    \   i += 1\n    return [smalest_value, smallest_index]\n", "    # Your code here\n\
    \    evens = []\n    evens.insert(0,0)\n    sorted_arr = sorted(arr)\n    evens\
    \ = []\n    for i in range(len(sorted_arr)):\n        if sorted_arr[i]%2 == 0:\n\
    \            evens.append(sorted_arr[i])\n        else:\n            if evens.index(sorted_arr[i])\
    \ == -1:\n                return []\n            else:\n                evens.insert(evens.index(sorted_arr[i]),sorted_arr[i])\n\
    \    \n    \n    return evens\n</cell>\n<text>\nPart C\nImplement the function\
    \ kth_smallest_node which finds the kth smallest element in a BST. Note that the\
    \ function should return a list containing the kth smallest value and the index.\
    \ The index starts at 0.\n\nExample 1:\n    >>> kth_smallest_node([1,8,3,10,5,10,11],\
    \ 5)\n    ([5, 4], 3)\n\n    Explanation: Since 5 is the kth smallest value, 5\
    \ is at index 4 and the list returned is [5, 4].\n\nExample 2:\n    >>> kth_smallest_node([10,5,10,11],\
    \ 4)\n    ([10, 10], 0)\n\n    Explanation: Since 10 is the kth smallest value,\
    \ 10 is at index 0 and the list returned is [10, 10].\n\nExample 3:\n    >>> kth_smallest_node([11,11,10,10],\
    \ 3)\n    ([11, 10], 1)\n\n    Explanation: Since 11 is the kth smallest value,\
    \ 11 is at index 1 and the list returned is [11, 10].\n\nExample 4:\n    >>> kth_smallest_node([10,11],\
    \ 0)\n    ([10], 0)\n\n    Explanation: The empty tree has no kth smallest element\
    \ so it should return an empty list and the index should be 0.\n\nExample 5:\n\
    \    >>> kth_smallest_node([10,11,20,30], 4)\n    ([10, 11, 20], 1)\n\n    Explanation:\
    \ The 4th smallest value is 20 at index 1 and 20 at index 3 in the list returned\
    \ should contain both values.\n\n    Constraints:\n        * 1 <= k <= length\
    \ of list\n        * list.length <= 10^5\n    \"\"\"\n    # Your code here\n \
    \   \n    if len(arr)==0:\n        return arr,0\n    \n    sorted_arr = sorted(arr)\n\
    \    k_smallest_index = -1\n    \n    for k in range(len(sorted_arr)):\n     \
    \   if k+1 < len(sorted_arr) and sorted_arr[k+1] == sorted_arr[k]:\n         \
    \   k_smallest_index = k\n            break\n    \n    \n    if k_smallest_index\
    \ == -1:\n        return arr,0\n    \n    else:\n        \n        k_smallest_value\
    \ = sorted_arr[k_smallest_index]\n        \n        evens = []", "    pass\n\n",
  "    \n    # Your code here\n    pass\n", "    if not arr or len(arr) == 1:\n  \
    \      return []\n    smalest_value = None\n    smalest_index = None\n    min_val\
    \ = None\n    for i, val in enumerate(arr):\n        if val < min_val:\n     \
    \       smalest_value = min_val\n            smalest_index = i\n            min_val\
    \ = val\n        else:\n            min_val = val\n    if min_val % 2 == 0:\n\
    \        return [smalest_value, smalest_index]\n    else:\n        return []\n",
  "    def helper(arr: List[int], max_index: int, index: int, even: int, even_index:\
    \ int) -> List[int]:\n        if index == len(arr):\n            return []\n\n\
    \        mid = index // 2\n        if arr[mid] % 2 == 0:\n            smaller\
    \ = arr[mid]\n            smaller_index = mid\n        else:\n            smaller\
    \ = min(arr[mid], arr[smaller_index])\n            smaller_index = smaller\n \
    \       smaller_index = smaller_index if smaller_index > index else index\n\n\
    \        arr[smaller_index] = arr[smaller_index] // 2\n        if arr[smaller_index]\
    \ == 0 and arr[smaller_index] != even:\n            even = arr[smaller_index]\n\
    \            even_index = smaller_index\n\n        if smaller_index == max_index:\n\
    \            return helper(arr, max_index, smaller_index + 1, even, even_index)\n\
    \n        return helper(arr, max_index, smaller_index + 1, even, even_index)\n\
    \n    return helper(arr, 0, 1, 0, 0)\n", "    pass\n", "    return sorted(arr,reverse=True)\n",
  "    \n    arr=[n for n in arr if n!=0]\n    if len(arr)==0:\n        return []\n\
    \    arr.sort()\n    return arr\n", "    # Fill this in.\n    even_values = []\n\
    \    even_values_index = []\n    \n    return even_values\n</cell>\n<cell>", " \
    \   pass\n", "    pass\n\n", "    pass\n", "    return sorted([x for x in arr\
    \ if x % 2 == 0], key=lambda x: x, reverse=True)[0]\n", "    # Your code here\n\
    \    if len(arr) == 0:\n        return []\n\n    even_values = []\n    smallest_value\
    \ = None\n    smallest_index = None\n    for i in range(len(arr)):\n        if\
    \ arr[i] % 2 == 0:\n            even_values.append(arr[i])\n            if smallest_value\
    \ is None:\n                smallest_value = arr[i]\n                smallest_index\
    \ = i\n            elif arr[i] < smallest_value:\n                smallest_value\
    \ = arr[i]\n                smallest_index = i\n\n    return [smallest_value,\
    \ smallest_index]\n</cell>\n<text>\n4.4 Minimum Spanning Tree\n\n\n</text>\n<cell>",
  "    pass\n", "    def find(x):\n        while x < len(arr) and arr[x] % 2 == 0:\n\
    \            x += 1\n        return x - 1\n    def knapsack(arr: List[int], k:\
    \ int, i: int) -> List[int]:\n        if k > 0 and k <= len(arr):\n          \
    \  if k == i:\n                return [arr[k], k]\n            else:\n       \
    \         return knapsack(arr, k - 1, i) + [min(arr[i + 1], arr[k]) + arr[i],\
    \ i]\n        else:\n            return []\n    \n    return knapsack(arr, 0,\
    \ len(arr))\n", "    pass\n", "    pass\n\n", "    even_values = []\n    if len(arr)\
    \ == 0:\n        return []\n    else:\n        for i in range(0, len(arr)):\n\
    \            if i % 2 == 0:\n                even_values.append(arr[i])\n    if\
    \ len(even_values) == 0:\n        return []\n    else:\n        smallest = min(even_values)\n\
    \        index_of_smallest_value = even_values.index(smallest)\n        return\
    \ [ smallest, index_of_smallest_value ]\n", "    \n    # Your code here\n    \n\
    \    pass\n\n</cell>\n<text>\nSolution\n\n</text>\n<cell>", "    stack = []\n\
    \    index = 1\n    for n in arr:\n        while stack:\n            smallest_even_value,\
    \ smallest_even_node_value = stack.pop()\n            if smallest_even_value %\
    \ 2 == 0:\n                smallest_even_node = smallest_even_node_value\n   \
    \             break\n            if smallest_even_value < n:\n               \
    \ smallest_even_node = smallest_even_node_value\n                break\n     \
    \       smallest_even_node = smallest_even_node_value\n            stack.append(smallest_even_node)\n\
    \        stack.append(n)\n        index += 1\n    return [smallest_even_node,\
    \ index]\n\n\"\"\"", "    if not arr:\n        return []\n\n    even_numbers =\
    \ set(filter(lambda x: x % 2 == 0, arr))\n\n    smalest_value = min(even_numbers)\n\
    \    smallest_index = even_numbers.index(min(even_numbers))\n    return smalest_value,\
    \ smallest_index\n", "    if not arr:\n        return []\n\n    # your code here\n\
    \    largest, index, smallest = min(enumerate(arr), key = lambda x:(x[1], x[0]))\n\
    \n    if smallest%2 == 0 and smallest not in arr and len(arr) > 0:\n        return\
    \ [smallest, index]\n    else:\n        return []\n    \n", "    \n    return\
    \ sorted(\n        [(node, i) for i, node in enumerate(arr) if is_even(node)],\n\
    \        key=lambda item: item[0]\n    )[0][0]\n\n\"\"\"\nRuntime: 32 ms, faster\
    \ than 42.91% of Python3 online submissions for Longest Palindromic Substring.\n\
    Memory Usage: 21.3 MB, less than 100.00% of Python3 online submissions for Longest\
    \ Palindromic Substring.\n\"\"\"\n</cell>\n<cell>", "    pass\n", "    pass\n",
  "    from functools import reduce\n    even_values = []\n    index_of_lowest_even_value\
    \ = reduce((lambda a, b: 1 if a[1] < b[1] else 0), zip(arr, arr[1:]), 0) # get\
    \ smallest even value\n    index_of_lowest_even_value = index_of_lowest_even_value\
    \ if index_of_lowest_even_value != 0 else index_of_lowest_even_value-1 # fix the\
    \ case where there are two same even values\n    index_of_lowest_even_values.append(index_of_lowest_even_value)\n\
    \    if index_of_lowest_even_values.count(index_of_lowest_even_value) == 1:\n\
    \        return index_of_lowest_even_values\n    else:\n        smallest_values\
    \ = []\n        for index in index_of_lowest_even_values:\n            smallest_values.append(arr[index])\n\
    \        if len(smallest_values) == 1:\n            return smallest_values\n \
    \       else:\n            return smallest_values\n", "    pass\n", "    pass\n\
    \n", "    def find(node: List[int]) -> int:\n        low = mid = high = node\n\
    \        while high > low:\n            mid = (high + low) // 2\n            if\
    \ nodes[mid] % 2 == 0: high = mid - 1\n            else: low = mid + 1\n     \
    \   return high\n    \n    length = len(arr)\n    if length == 0: return []\n\
    \    nodes = [1] * length\n    \n    for i in range(len(arr)):\n        if arr[i]\
    \ % 2 == 0: nodes[i] = arr[i]\n        \n    smalest_value, smalest_index = find(nodes)\n\
    \    \n    if smalest_index <= smalest_value*2:\n        return [smalest_value,\
    \ smalest_index]\n    \n    return []\n</cell>\n<text>\nNow you can use your function\
    \ to solve this problem.\n\n\n</text>\n<cell>", "    \n\n    even = min([x for\
    \ x in arr if x % 2 == 0])\n    even_index = arr.index(even)\n    \n    if even_index\
    \ >= 0:\n        return [even, even_index]\n    else:\n        return []\n    ",
  "    pass\n", "    pass\n", "    return sorted(arr)[0]\n", "    if len(arr) == 0:\n\
    \        return []\n\n    even_values = []\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n \
    \           even_values.append(value)\n            if value < smallest_value:\n\
    \                smallest_value = value\n                smallest_index = index\n\
    \n    smallest_index += 1\n\n    return even_values[smallest_index], smallest_index\n",
  "    def even_branches(arr: List[int]) -> List[int]:\n        \"\"\"\n        helper\
    \ function for even_branches\n        \"\"\"\n        res = []\n        even_branches\
    \ = lambda x, rest, last, count, rest_count: \\\n                            \
    \      rest or last\n        \n        if not arr:\n            return res\n \
    \       \n        count, current = 0, arr[0]\n        rest_count, current_rest\
    \ = 0, []\n        \n        while current:\n            count += 1\n        \
    \    rest, rest_count = even_branches(arr[1:], current_rest,\n               \
    \                              [], count, rest_count)\n            if rest ==\
    \ []:\n                res.append(rest)\n            else:\n                rest_count.append(count)\n\
    \                current_rest = rest\n            current = arr.pop(0)\n     \
    \   \n        return res\n    \n    return even_branches(arr)[-1]\n</cell>\n<cell>\n\
    arr = [4, 2, 3]\n</cell>\n<cell>", "    # initialize result list with empty item\n\
    \    res = list(map(lambda x:[x], arr))\n    # keep track of current min index\n\
    \    min_idx = 0\n    # iterate over items in sorted array\n    for idx, item\
    \ in enumerate(sorted(arr, key=lambda x:x, reverse=True), 1):\n        # check\
    \ if current item is even and lower than current min even\n        if item % 2\
    \ == 0:\n            min_idx = idx\n        # check if current item is lower than\
    \ current min even\n        elif item < arr[min_idx]:\n            # update current\
    \ min even if it is not the minimum\n            if min_idx != 0:\n          \
    \      res[min_idx] = item\n            # update min even if it is the first item\n\
    \            else:\n                res[0] = item\n    # return minimum even value\
    \ and index\n    return [res[min_idx], min_idx]\n", "    pass\n\n", "    pass\n\
    \n", "    def dfs(node: int, arr: List[int]) -> None:\n        \"\"\"\n      \
    \  The algorithm to perform the pluck operation.\n        \"\"\"\n        if node\
    \ < 0 or node >= len(arr):\n            return\n        \n        if arr[node]\
    \ % 2 == 0 and arr[node]<0:\n            if node == 0 or arr[node-1] <= arr[node]:\n\
    \                arr.pop(node)\n                arr[node-1] //= 2\n          \
    \      arr.append(arr[node-1]-1)\n                arr.append(arr[node])\n    \
    \            \n            dfs(node, arr)\n        else:\n            if node\
    \ == 0 or arr[node-1] <= arr[node]:\n                arr.pop(node)\n         \
    \       arr.append(arr[node])\n                \n            dfs(node, arr)\n\
    \    \n    arr = [node for node in arr]\n    if arr:\n        dfs(0, arr)\n  \
    \      return arr\n    else:\n        return []\n</cell>\n<cell>\n%timeit pluck_test([4,\
    \ 2, 3])\n</cell>\n<text>\nProblem 3\nYou are given a binary tree. The task is\
    \ to find two nodes that are the closest in height and sum to the original tree.\
    \ Return them in sorted order.\n\nWe define the closest to mean the difference\
    \ between the height of the two nodes (height difference is equal to the node\
    \ height).\n\nFor example, given the tree:\n\n       8\n      / \\\n     4   9\n\
    \    / \\\n   1   2\n   6   7\n\nThe nodes that are closest in height are:\n\n\
    1 -> 6\n2 -> 8\n\nAnd their sum is 21.\n\nNote: The height difference between\
    \ two nodes is represented by the node value: $v$ (node's value), which can be\
    \ positive or negative.\n\nFor example, a difference of 1 between two nodes means\
    \ the two nodes have the same value and the difference between their height is\
    \ 0.\n\nAlso, note that two nodes with the same height can be distinguished by\
    \ the sign of the node value.\n\n\n</text>\n<cell>", "    # M1. \u8D2A\u5A6A\n\
    \    # def pluck(arr: List[int]) -> List[int]:\n    #     \"\"\"\n    #     \"\
    Given an array representing a branch of a tree that has non-negative integer nodes\n\
    \    #     your task is to pluck one of the nodes and return it.\n    #     The\
    \ plucked node should be the node with the smallest even value.\n    #     If\
    \ multiple nodes with the same smallest even value are found return the node that\
    \ has smallest index.\n\n    #     The plucked node should be returned in a list,\
    \ [ smalest_value, its index ],\n    #     If there are no even values or the\
    \ given array is empty, return [].\n\n    #     Example 1:\n    #     >>> pluck([4,\
    \ 2, 3])\n    #     [2, 1]\n    #     Explanation: 2 has the smallest even value,\
    \ and 2 has the smallest index.\n\n    #     Example 2:\n    #     >>> pluck([1,\
    \ 2, 3])\n    #     [2, 1]\n    #     Explanation: 2 has the smallest even value,\
    \ and 2 has the smallest index.\n\n    #     Example 3:\n    #     >>> pluck([])\n\
    \    #     []\n    #     \n    #     Example 4:\n    #     >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    #     [0, 1]\n    #     Explanation: 0 is the smallest value,\
    \ but  there are two zeros,\n    #                  so we will choose the first\
    \ zero, which has the smallest index.\n\n    #     Constraints:\n    #       \
    \  * 1 <= nodes.length <= 10000\n    #         * 0 <= node.value\n    #     \"\
    \"\"\n    #     # \u9996\u5148\u627E\u5230\u6700\u5C0F\u7684\u503C\n    #    \
    \ min_value = min(arr)\n    #     # \u518D\u627E\u5230\u8FD9\u4E2A\u503C\u5728\
    arr\u4E2D\u7684\u7D22\u5F15\n    #     min_value_pos = arr.index(min_value)\n\
    \    #     # \u628Aarr\u4E2D\u6240\u6709\u503C\u90FD\u51CF\u53BBmin_value\n  \
    \  #     arr = arr - min_value\n    #     # \u5982\u679C\u4E0D\u4E3A\u7A7A\n \
    \   #     if not arr:\n    #         return []\n    #     # \u5982\u679Carr\u4E2D\
    \u6709\u76F8\u540C\u7684\u503C\n    #     elif min(arr) == min_value:\n    # \
    \        # \u627E\u51FA\u6700\u5C0F\u7684\u7D22\u5F15\n    #         return [min_value_pos]\n\
    \    #     # \u5982\u679Carr\u4E2D\u6CA1\u6709\u76F8\u540C\u7684\u503C\n    #\
    \     else:\n    #         # \u5BF9arr\u6392\u5E8F\uFF0C\u518D\u627E\u51FA\u4E0B\
    \u4E00\u4E2A\u503C\u548C\u7D22\u5F15\n    #         arr = sorted(arr)\n    # \
    \        # \u7136\u540E\u627E\u51FA\u6700\u5C0F\u503C\n    #         min_value\
    \ = min(arr)\n    #         # \u627E\u51FA\u8FD9\u4E2A\u503C\u5728arr\u4E2D\u7684\
    \u7D22\u5F15\n    #         min_value_pos = arr.index(min_value)\n    #      \
    \   # \u8FD4\u56DE\u503C\n    #         return [min_value, min_value_pos]\n\n\
    \    # M2. \u81EA\u4E60\u60EF\n    # def pluck(arr: List[int]) -> List[int]:\n\
    \    #     \"\"\"\n    #     \"Given an array representing a branch of a tree\
    \ that has non-negative integer nodes\n    #     ", "    # Your code here\n  \
    \  arr = sorted(arr)\n    if len(arr)==0:\n        return []\n    if len(arr)==1:\n\
    \        return arr\n    low = arr[0]\n    index = arr.index(low)\n    high =\
    \ arr[-1]\n    while(index!=0 and high-low%2==0):\n        index -= 1\n      \
    \  low = arr[index]\n    while(index!=len(arr)-1 and high-low%2!=0):\n       \
    \ index += 1\n        high = arr[index]\n    return [low,index]\n", "    def helper(nodes):\n\
    \        even = []\n        for i in nodes:\n            if i % 2 == 0:\n    \
    \            even.append(i)\n            else:\n                even.append(i-3)\n\
    \                even.append(i+3)\n        return even\n    \n    even = helper(arr)\n\
    \    \n    if even:\n        index = even.index(min(even))\n        \n       \
    \ if even.count(min(even)) > 1:\n            smallest_index = even.index(min(even))\n\
    \            \n            smallest_value = arr[int(smallest_index)]\n       \
    \     \n            even.pop(smallest_index)\n            even.pop(even.index(min(even)))\n\
    \            \n            return [smallest_value, index]\n        else:\n   \
    \         return [min(even), index]\n    else:\n        return [] \n         \
    \   \n            ", "    if len(arr) == 0:\n        return []\n    \n    even_values\
    \ = sorted(set(arr) & set(list(range(2, len(arr)))))\n    smallest_value = min(even_values)\n\
    \    smallest_index = None\n    for ind, val in enumerate(arr):\n        if val\
    \ == smallest_value:\n            if smallest_index is None:\n               \
    \ smallest_index = ind\n            elif val < smallest_value:\n             \
    \   smallest_index = ind\n    if smallest_index is None:\n        return []\n\
    \    else:\n        return [smallest_value, smallest_index]\n\n", "    if arr:\n\
    \        arr.sort()\n        even = 0\n        min_node = arr[0]\n        min_idx\
    \ = 0\n        for i in range(1, len(arr)):\n            if arr[i] % 2 == 0:\n\
    \                even += 1\n            elif arr[i] == min_node:\n           \
    \     min_idx = i\n            elif even > 0 and arr[i] % 2 != 0 and arr[i] <\
    \ min_node:\n                min_node = arr[i]\n                min_idx = i\n\
    \                even = 0\n            elif even > 0 and arr[i] == min_node:\n\
    \                min_idx = i\n                even = 0\n        return arr[min_idx],\
    \ min_idx\n    return [], 0\n", "    pass\n</cell>\n<cell>", "    \n    # Your\
    \ code here\n    pass\n</cell>\n<cell>", "    # Your code here\n    if arr ==\
    \ []:\n        return []\n\n    largest = 0\n    smallest = 0\n    index = 0\n\
    \n    for i in range(len(arr)):\n        smallest_even_number = arr[smallest]\n\
    \        even_number_index = i\n        if smallest_even_number != 0:\n      \
    \      if smallest_even_number % 2 == 0:\n                smallest = i + 1\n \
    \               largest = i\n        else:\n            smallest = i\n       \
    \     largest = i + 1\n\n        if largest != i:\n            index = i\n\n \
    \   arr.sort()\n    plucked_value = arr.pop()\n    return [plucked_value, index]\n\
    \n", "    even, index = [], -1\n    \n    for i in range(len(arr)):\n        if\
    \ arr[i] % 2 == 0:\n            if arr[i] not in even:\n                even.append(arr[i])\n\
    \                index = i\n        else:\n            if arr[i] not in even:\n\
    \                even.append(arr[i])\n                index = i\n\n    if len(even)\
    \ == 0 or even[0] == arr[0]:\n        return []\n    else:\n        return [even[0],\
    \ index]\n", "    \n    \n    # Your code here\n    \n    return smallestEvenValueIndex\n\
    </cell>\n<cell>", "    # Your code here\n    \n    # Your code here\n    return\
    \ sorted(arr, key = lambda x: (x%2, x//2)[0]) # the sorted() function returns\
    \ a sorted copy of the list \n                                               \
    \         # with each element sorted according to the order of the given key.\n\
    \                                                        # here we use the key\
    \ parameter to sort by the value of even \n                                  \
    \                      # first then by their index.\n", "    \n    return sorted(list(set(arr)),\
    \ key=lambda x: [x%2 if x else 0, x])\n", "    \n    # Your code here\n    \n\
    \    return []\n", "    def minFunc(arr):\n        min = arr[0]\n        minIndex\
    \ = 0\n        \n        for v in arr:\n            if v < min:\n            \
    \    min = v\n                minIndex = 0\n            else:\n              \
    \  minIndex = minIndex + 1\n        \n        return [ min, minIndex ]\n    \n\
    \    if not arr:\n        return []\n    else:\n        return minFunc(arr)\n",
  "    if arr == []:\n        return []\n    if arr == [i for i in arr if i % 2 ==\
    \ 0]:\n        return arr[:1]\n    if arr == [i for i in arr if i % 2 == 0]:\n\
    \        return arr[:1]\n    if arr == [i for i in arr if i % 2 != 0]:\n     \
    \   return arr[:1]\n    elif arr == []:\n        return []\n    else:\n      \
    \  return arr[:1]\n    ", "    # write your code here\n    if not arr:\n     \
    \   return []\n    smalest_value = arr[0]\n    smalest_index = 0\n    \n    for\
    \ index, value in enumerate(arr):\n        if value % 2 == 0:\n            if\
    \ value <= smalest_value:\n                smalest_value = value\n           \
    \     smalest_index = index\n            else:\n                return [smalest_value,\
    \ smalest_index]\n    return []\n", "    # Your code here\n    if not arr:\n \
    \       return list()\n    min_value = arr[0]\n    min_idx = 0\n    for i, val\
    \ in enumerate(arr):\n        if val % 2 == 0:\n            if min_value <= val:\n\
    \                min_value = val\n                min_idx = i\n    return arr[min_idx],\
    \ [min_idx]\n", "    pass\n", "    if len(arr) == 0:\n        return arr\n   \
    \ if len(arr) == 1:\n        return arr[0]\n    \n    smalest_value = min(arr)\n\
    \    smalest_value_pos_index = arr.index(smalest_value)\n    \n    arr[smalest_value_pos_index]\
    \ += 1\n    \n    smalest_value_pos_index = arr.index(min(arr))\n    \n    while\
    \ arr[smalest_value_pos_index] & 1 != 0:\n        arr[smalest_value_pos_index]\
    \ -= 1\n        smalest_value_pos_index = arr.index(min(arr))\n    \n    if smalest_value_pos_index\
    \ == len(arr) - 1:\n        return [smalest_value, 0]\n    \n    return [smalest_value,\
    \ smalest_value_pos_index]\n", "    # Your code here\n    if not arr:\n      \
    \  return []\n    if arr[0] & 1:\n        return [(arr[0], arr.index(0)+1)]\n\
    \    else:\n        return [min(arr), min(arr.index(0), len(arr))]\n", "    pass\n\
    </cell>\n<cell>", "    pass\n\n\n@cache", "    def bs(arr: List[int]) -> List[int]:\n\
    \        if len(arr) == 0:\n            return []\n\n        odd = arr[0]\n  \
    \      even = []\n        for i in range(len(arr)):\n            if arr[i] % 2\
    \ == 1:\n                odd = arr[i]\n            else:\n                even.append(arr[i])\n\
    \n        if even:\n            if odd == min(even):\n                return odd\n\
    \            else:\n                return min(even)\n        else:\n        \
    \    return odd\n\n    return list(map(lambda x: bs(x), arr))\n\n", "    if len(arr)\
    \ == 0:\n        return []\n    if len(arr) == 1:\n        return [arr[0], 0]\n\
    \    even_values = [0] * len(arr)\n    for i, num in enumerate(arr):\n       \
    \ even_values[i] = (num % 2 == 0) and num or 0\n    smallest_even_values = []\n\
    \    smallest_even_value_indexes = []\n    for i in range(len(even_values)):\n\
    \        smallest_even_values.append(min(even_values[i:i + 2]))\n        smallest_even_value_indexes.append(i\
    \ + 1)\n    smallest_even_values.reverse()\n    smallest_even_value_indexes.reverse()\n\
    \    smallest_even_value_index = min(smallest_even_value_indexes)\n    smallest_value\
    \ = min(smallest_even_values)\n    smallest_value_index = smallest_even_value_indexes[smallest_even_value_index]\n\
    \    return [smallest_value, smallest_value_index]\n", "    pass\n\n", "    pass\n\
    \n", "    pass\n</cell>\n<cell>", "    pass\n", "    \n    if not arr:\n     \
    \   return []\n    \n    smalest_value = None\n    smalest_idx = None\n    \n\
    \    for i, val in enumerate(arr):\n        if smalest_value == None or smalest_value\
    \ < val:\n            smalest_value = val\n            smalest_idx = i\n\n   \
    \ arr.pop(smalest_idx)\n    \n    return [smalest_value, smalest_idx]\n", "  \
    \  pass\n</cell>\n<cell>", "    def recurse(root) -> int:\n        if root is\
    \ None or root < 0:\n            return []\n        smallest_even_value, smallest_even_index\
    \ = root, 0\n        smaller_even_value = root.right\n        while smaller_even_value\
    \ is not None:\n            if smaller_even_value.value % 2 == 0:\n          \
    \      if smallest_even_value < smaller_even_value.value:\n                  \
    \  smallest_even_value = smaller_even_value.value\n                    smallest_even_index\
    \ = smaller_even_value.index\n                smaller_even_value = smaller_even_value.right\n\
    \            else:\n                smaller_even_value = smaller_even_value.left\n\
    \        if smallest_even_value == root.value:\n            return [smallest_even_value,\
    \ smallest_even_index]\n        else:\n            return recurse(root.left) +\
    \ recurse(root.right)\n\n    return recurse(arr[0])\n\n", "    even_values = [n\
    \ for n in arr if n % 2 == 0]\n    if not even_values:\n        return []\n  \
    \  smalest_value = min(even_values)\n    return [smalest_value, even_values.index(smalest_value)]\n\
    \n", "    pass\n", "    def helper(nodes: List[int], node: List[int]):\n     \
    \   if nodes == 0:\n            return []\n        if node == []:\n          \
    \  return []\n        even = node % 2 == 0\n        smallest_value = node[0]\n\
    \        smallest_index = 0\n        for i in range(1, len(node)):\n         \
    \   if node[i] % 2 == 0 and node[i] < smallest_value:\n                smallest_value\
    \ = node[i]\n                smallest_index = i\n        if even:\n          \
    \  smallest_value = smallest_value // 2\n        if smallest_value not in nodes\
    \ or smallest_index == 0:\n            return []\n        if smallest_index !=\
    \ len(node) - 1:\n            smallest_index += 1\n        return [smallest_value,\
    \ smallest_index]\n\n    return helper(arr, [])\n</cell>\n<cell>", "    pass\n",
  "    # Your code here\n    even = []\n    for i in arr:\n        if i % 2 == 0:\n\
    \            even.append(i)\n    \n    if len(even) == 0:\n        return []\n\
    \    \n    index = min(even, key = lambda i : i + 1)\n    \n    return [index,even.index(index)]\n\
    \n", "    pass\n</cell>\n<cell>", "    pass\n", "    pass\n\n", "    smallest_even_value\
    \ = None\n    smallest_index = None\n    for i in range(len(arr)):\n        if\
    \ arr[i] % 2 == 0:\n            smallest_even_value = arr[i]\n            smallest_index\
    \ = i\n            break\n    if smallest_even_value is None:\n        return\
    \ []\n    return [smallest_even_value,smallest_index]\n", "    # Solution part\
    \ 1 -- O(n)\n    # ...\n    # Solution part 2 -- O(n)\n    # ...\n", "    if len(arr)\
    \ == 0:\n        return []\n    \n    # initialize an empty result list\n    smalest_value\
    \ = None\n    smallest_index = -1\n    \n    # Go through each element in the\
    \ given array and find the smallest odd value\n    for i, el in enumerate(arr):\n\
    \        if el % 2 == 0:\n            if smalest_value is None or smalest_value\
    \ < el:\n                smalest_value = el\n                smallest_index =\
    \ i\n            else:\n                smalest_value = el\n                smallest_index\
    \ = i\n        else:\n            if smalest_value is None or smalest_value <\
    \ el:\n                smalest_value = el\n                smallest_index = i\n\
    \            else:\n                smalest_value = el\n                smallest_index\
    \ = i\n    \n    # If there is no even values, return []\n    if smalest_value\
    \ is None:\n        return []\n    \n    # Otherwise, we will add the smallest\
    \ even value and its index to the result list\n    return [smalest_value, smallest_index]\n",
  "    return __helper__(__pluck_helper__, arr)\n", "    # Write your code here.\n\
    \    if arr == []:\n        return []\n    min_even_value = arr[0]\n    min_value_index\
    \ = -1\n    index = -1\n    for idx, val in enumerate(arr):\n        if val %\
    \ 2 == 0:\n            min_even_value = val\n            min_value_index = idx\n\
    \        index = idx\n    if min_value_index == -1:\n        return []\n    return\
    \ [min_even_value,min_value_index]\n", "    pass\n</cell>\n<text>\n[Advanced]\
    \ Write a function to find the index of any node in the BST that has a value equal\
    \ to the given target value.\n\n</text>\n<cell>", "    pass\n\n", "    pass\n",
  "    stack = []\n    \n    for index, value in enumerate(arr):\n        if value\
    \ % 2 == 0:\n            stack.append((value, index))\n            \n    if len(stack)\
    \ == 0:\n        return []\n    \n    stack = sorted(stack)\n    smalest_value\
    \ = stack[0][0]\n    smalest_index = stack[0][1]\n    \n    while stack:\n   \
    \     smallest_value, smallest_index = stack.pop()\n        if smallest_value\
    \ % 2 == 0 and smallest_index == 0:\n            return smallest_value\n     \
    \   elif smallest_value % 2 != 0:\n            return smallest_value\n    \n \
    \   return []\n</cell>\n<cell>\n%timeit pluck(list(range(1, 1000000)))\n</cell>\n\
    <text>\nPractice 3\n\n</text>\n<cell>", "<|/ file ext=.py source=github |>\n<|\
    \ c |>\nYour code seems correct, but I doubt that your answer is correct. Can\
    \ you please test your answer against mine?\n<|/ c |>\n<| a tags=binary-search-tree,algorithm,python,binary-tree\
    \ |>\nHere is the Python implementation:\n<code>", "    from bisect import bisect_left\n\
    \    if not arr:\n        return []\n    # sort list by value\n    arr = sorted(arr,\
    \ key=lambda node: node.value)\n    # find smallest even\n    smalest_value =\
    \ arr[bisect_left(arr, [arr.find(node.value) // 2 for node in arr])]\n    return\
    \ [smalest_value, arr.index(smalest_value)] if smalest_value.value % 2 == 0 else\
    \ [smalest_value]\n    ", "    # Your code here\n    even_values = []\n    even_value\
    \ = 0\n\n    for i in arr:\n        if i % 2 == 0:\n            even_values.append(i)\n\
    \n    smallest_value = min(even_values)\n    even_values.remove(smallest_value)\n\
    \    index_of_smallest = even_values.index(smallest_value)\n\n    return smallest_value,\
    \ index_of_smallest\n\n</cell>\n<text>\nGiven a non-negative array of nodes representing\
    \ a tree where every node's value is\nnon-negative, and every path from any node\
    \ to any leaf has direction to\neither pluck one of the nodes and return it, or\
    \ to pluck one of a set of nodes that\nsum to a given total and return the node\
    \ that has the smallest sum. More formally,\ngiven a binary tree where every node\
    \ has a unique value, and every path from the root to\nany leaf has direction\
    \ towards pluck one of the nodes and return it, or to pluck one of a set of nodes\
    \ that sum to a given total and return the node that has the smallest sum, pluck\
    \ whichever one will result in the shortest path.\n\nExample 1:\nInput: \n   \
    \ [7, 5, 3]\nOutput: 5\nExplanation: \n    7 is the only even number in the array,\
    \ so we pick 7.\n    5 is the only odd number in the array, so we pick 5.\n  \
    \  3 has the smallest sum of 5+7, so we pick 3.\n\nExample 2:\nInput: \n    [1,\
    \ 3, 2, 5, 0]\nOutput: 4\nExplanation: \n    1 is the only even number in the\
    \ array, so we pick 1.\n    3 is the only odd number in the array, so we pick\
    \ 3.\n    1 has the smallest sum of 3+2, so we pick 1.\n    We pick the path that\
    \ leads to 1, and the sum of the path that leads to 3 is 2+1 = 2.\n\nExample 3:\n\
    Input: \n    [5, 1, 8, 2, 6, 3, 7, 0, 9, 4]\nOutput: 6\nExplanation: \n    5 is\
    \ the only even number in the array, so we pick 5.\n    8 is the only odd number\
    \ in the array, so we pick 8.\n    We pick 5 because it is the smallest even number.\
    \ \n    The next odd number in the array is 6, so we pick it.\n    8 is the only\
    \ odd number in the array, so we pick 8.\n    We pick 8 because it is the smallest\
    \ even number. \n    The next odd number in the array is 7, so we pick it.\n \
    \   7 is the only odd number in the array, so we pick 7.\n    We pick 7 because\
    \ it is the smallest even number. \n    The next odd number in the array is 0,\
    \ so we pick it.\n    7 is the only odd number in the array, so we pick 7.\n \
    \   We pick 7 because it is the smallest even number. \n    The ", "    return\
    \ list(map(lambda x,y: [x, y], [min(filter(lambda x: x%2 == 0, arr)), arr.index(min(filter(lambda\
    \ x: x%2 == 0, arr)))]))\n", "    if arr == []:\n        return []\n    else:\n\
    \        arr.sort()\n        arr.sort(reverse = True)\n        even = [i for i,\
    \ value in enumerate(arr) if value % 2 == 0]\n        return even[0] if even else\
    \ arr[0]\n\"\"\"\n    def divide(arr, start, end):\n        if start == end:\n\
    \            return arr[start]\n        mid = (start + end) // 2\n        return\
    \ max(divide(arr, start, mid), divide(arr, mid + 1, end))\n\n    arr = [10, 4,\
    \ 6, 8, 10, 10, 8, 10]\n    print(divide(arr, 0, len(arr)))\n\"\"\"\n\"\"\"\n\
    \    def mergeSort(arr: List[int], start: int, end: int):\n        if start ==\
    \ end:\n            return arr[start]\n        mid = (start + end) // 2\n    \
    \    return max(mergeSort(arr, start, mid), mergeSort(arr, mid + 1, end))\n\n\
    \    print(mergeSort([10, 4, 6, 8, 10, 10, 8, 10], 0, len([10])))\n\"\"\"\n\n\"\
    \"\"\n    def mergeSort(arr: List[int], start: int, end: int):\n        if start\
    \ == end:\n            return arr[start]\n        mid = (start + end) // 2\n \
    \       left = [x for x in arr if x > mid]\n        right = [x for x in arr if\
    \ x < mid]\n        return max(mergeSort(arr, start, mid), mergeSort(arr, mid\
    \ + 1, end), merge(left, right))\n", "    minimum = arr[0]\n    i = 0\n    while\
    \ i < len(arr) and arr[i] < minimum:\n        minimum = arr[i]\n        i += 1\n\
    \    plucked = [minimum]\n    if i == len(arr):\n        return plucked\n    while\
    \ arr[i] < minimum:\n        i += 1\n    plucked.append(arr[i])\n    return plucked\n",
  "    # Your code here\n    if len(arr) == 0:\n        return []\n    smallest_value\
    \ = None\n    smallest_index = None\n    for ind, val in enumerate(arr):\n   \
    \     if val % 2 == 0:\n            if smallest_value is None or smallest_value\
    \ < val:\n                smallest_value = val\n                smallest_index\
    \ = ind\n    if smallest_value is not None:\n        return [smallest_value, smallest_index]\n\
    \    return []\n", "    if len(arr) == 0:\n        return []\n    \n    # Store\
    \ min even value and its index\n    min_even_value, min_even_no = arr[0], 0\n\
    \    \n    # Store min index\n    min_idx = 0\n\n    # Loop through all elements\
    \ and compare them\n    for idx, val in enumerate(arr):\n        if val % 2 !=\
    \ 0:\n            if min_even_value == val: # if even value found and its index\
    \ is same as the one with smallest even value found\n                min_even_no,\
    \ min_idx = idx, val\n            else: # if even value found and its index is\
    \ smaller, change the value of current index to smaller one\n                min_even_no,\
    \ min_idx = val, idx\n\n    if min_even_no == min_even_value:\n        return\
    \ [min_even_no, min_idx]\n    \n    # Return first even value if it exists otherwise\
    \ return empty list\n    return [min_even_no, min_idx] if min_even_value != min_even_no\
    \ else []\n", "    pass\n", "    # Your code here\n    if len(arr) == 0:\n   \
    \     return arr\n    # Your code here\n    smalest_value = None\n    smallest_index\
    \ = None\n    even_index = None\n    for index, val in enumerate(arr):\n     \
    \   odd = False\n        if val % 2 == 0:\n            odd = True\n        if\
    \ smalest_value is None:\n            smalest_value = val\n            even_index\
    \ = index\n        elif smalest_value < val:\n            smalest_value = val\n\
    \            even_index = index\n        elif smalest_value == val:\n        \
    \    even_index = index\n    if smalest_value is not None and smalest_value %\
    \ 2 == 0:\n        smallest_index = even_index\n        return smalest_value,\
    \ smallest_index\n    return []\n", "    pass\n</cell>\n<cell>", "    # M1. Initialize\
    \ result\n    plucked = []\n\n    # M2. Initialize smallest_value\n    smallest_value\
    \ = None\n\n    # M3. Initialize index\n    index = 0\n\n    # M4. Initialize\
    \ max_value\n    max_value = 0\n\n    # M5. Initialize prev\n    prev = None\n\
    \n    # M6. Initialize prev\n    while arr:\n        # M7. Initialize next_value\n\
    \        next_value = arr[0]\n\n        # M8. Initialize index\n        index\
    \ = 1\n\n        # M9. Initialize max_value\n        max_value = next_value\n\n\
    \        # M10. Initialize prev\n        prev = arr[index - 1]\n\n        # M11.\
    \ Initialize prev\n        while next_value % 2 == 0:\n            # M12. Initialize\
    \ next_value\n            next_value = arr[index - 1]\n            # M13. Initialize\
    \ index\n            index += 1\n\n        # M14. Update max value\n        if\
    \ max_value < next_value:\n            max_value = next_value\n\n        # M15.\
    \ Push max_value\n        plucked.append(max_value)\n\n        # M16. Reset index\n\
    \        index = 0\n\n        # M17. Update prev\n        prev = arr[index - 1]\n\
    \n        # M18. Push prev\n        plucked.append(prev)\n\n        # M19. Update\
    \ smallest_value\n        if smallest_value == None:\n            smallest_value\
    \ = max_value\n        else:\n            if smallest_value < max_value:\n   \
    \             smallest_value = max_value\n\n        # M20. Update index\n    \
    \    index += 1\n\n        # M21. Push next_value\n        plucked.append(next_value)\n\
    \n        # M22. Update max_value\n        max_value = next_value\n\n        #\
    \ M23. Push prev\n        plucked.append(prev)\n\n        # M24. Reset index\n\
    \        index = 0\n\n    # M25. Return result\n    return plucked\n", "    def\
    \ smallest_even(arr: List[int]) -> List[int]:\n        \"\"\"\n        >>> smallest_even([4,\
    \ 2, 3])\n        [2, 1]\n        \"\"\"\n        \n        def find_smallest(arr:\
    \ List[int]) -> int:\n            \"\"\"\n            Returns the smallest even\
    \ value in arr\n            \"\"\"\n            \n            smallest = arr[0]\n\
    \            index = 0\n\n            for value in arr:\n                if value\
    \ % 2 == 0:\n                    smallest = value\n                    index =\
    \ index\n                else:\n                    break\n            \n    \
    \        return smallest, index\n        \n        smallest, index = find_smallest(arr)\n\
    \        \n        even_values = []\n        \n        for value in arr:\n   \
    \         if value % 2 == 0:\n                even_values.append(value)\n    \
    \            \n                if len(even_values) == 1:\n                   \
    \ return [smallest, index]\n                else:\n                    smallest,\
    \ index = find_smallest(even_values)\n            \n            elif value < smallest:\n\
    \                smallest, index = find_smallest(arr)\n                \n    \
    \    return [smallest, index]\n    \n    if arr:\n        return smallest_even(arr)\n\
    \    else:\n        return []\n</cell>\n<cell>", "    pass\n\n", "    pass\n",
  "    def aux(arr: List[int], index: int) -> List[int]:\n        size = len(arr)\n\
    \        if size == 0:\n            return arr\n        if size == 1:\n      \
    \      return [arr[0], [index]]\n        smallest_value, smallest_index = arr[0],\
    \ [0]\n        for i in range(1, size):\n            val = arr[i]\n          \
    \  if val % 2 == 0:\n                smallest_value, smallest_index = val, i\n\
    \            else:\n                if smallest_value < val:\n               \
    \     smallest_value = val\n                    smallest_index = i\n        if\
    \ smallest_value%2 != 0:\n            smallest_index = index\n        return [smallest_value,\
    \ smallest_index]\n\n    return aux(arr, [0])\n", "    pass\n", "    min_value\
    \ = arr[0]\n    min_idx = 0\n    idx_with_min_value = None\n    for i, elem in\
    \ enumerate(arr):\n        if elem > min_value:\n            if idx_with_min_value\
    \ is None:\n                min_value = elem\n                min_idx = i\n  \
    \          else:\n                if elem < min_value:\n                    min_value\
    \ = elem\n                    min_idx = i\n\n        if i == len(arr) - 1:\n \
    \           idx_with_min_value = i\n    return [ min_value, idx_with_min_value\
    \ ]\n", "    \n    if len(arr) == 0:\n        return []\n    if sorted(arr)[0]\
    \ == 0 and len(arr) == 1:\n        return []\n    smalest_value = None\n    smalest_index\
    \ = None\n    \n    i = 0\n    for num in arr:\n        if smalest_value is None\
    \ or num < smalest_value:\n            smalest_value = num\n            smalest_index\
    \ = i\n        i += 1\n    \n    \n    if smalest_index == i:\n        return\
    \ [smalest_value, smalest_index]\n    elif smalest_index != i:\n        return\
    \ [smalest_value, smalest_index] \n    else:\n        return []\n    \n", "  \
    \  if arr == []:\n        return []\n\n    i = 0\n    length = len(arr)\n\n  \
    \  # create new list that stores even values\n    arr2 = []\n    while i < length:\n\
    \        if arr[i] % 2 == 0:\n            arr2.append(arr[i])\n        i += 1\n\
    \n    # initialize minimum even value and the index\n    minValue = 0\n    minIndex\
    \ = -1\n\n    # run through the even values and find the smallest even value and\
    \ the index\n    i = 0\n    while i < len(arr2):\n        if minValue == 0 and\
    \ minIndex == -1:\n            if arr2[i] < minValue:\n                minValue\
    \ = arr2[i]\n                minIndex = i\n        if arr2[i] == minValue:\n \
    \           if arr2[i] < minValue:\n                minValue = arr2[i]\n     \
    \           minIndex = i\n        i += 1\n\n    # return the smallest even value\
    \ and the index\n    return [minValue, minIndex]\n\nprint(pluck([4, 2, 3]))\n\
    print(pluck([5, 6, 7, 9, 1, 4, 2]))\nprint(pluck([]))\n\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that removes the duplicate elements from a given list.\n\
    \nExample 1:\n>>> removeDuplicates([1, 1, 3, 3, 2, 2])\n[1, 2, 3, 2]\n>>> removeDuplicates([1,\
    \ 1, 3, 2, 3, 3, 2])\n[1, 2, 3]\n\nExample 2:\n>>> removeDuplicates([1, 2, 3,\
    \ 3])\n[1, 2, 3]\n>>> removeDuplicates([1, 3, 5])\n[1, 3, 5]\n\nConstraints:\n\
    \    1 <= array.length <= 10^5\n    0 <= array[i] <= 10^9\n    array.length ==\
    \ number of items in the array\n\n</text>\n<cell>", "    # Fill this in.\n   \
    \ \n    return []\n</cell>\n<text>\n3. Smallest Index\nThe smallest index $i$\
    \ of a given node $n$ can be seen as a value that occurs only once in $A$. For\
    \ example, the smallest index of a node with value $n$ is $n$ itself because that\
    \ value occurs only once in the array.\n\n\n</text>\n<cell>", "    # Your code\
    \ here\n    if len(arr) == 0:\n        return []\n    even_values = []\n    for\
    \ i in range(0, len(arr)):\n        if arr[i] % 2 == 0:\n            even_values.append(arr[i])\n\
    \    sorted_even_values = sorted(even_values, key=int)\n    smalest_value = sorted_even_values[0]\n\
    \    if len(sorted_even_values) > 1:\n        smallest_index = sorted_even_values.index(smalest_value)\n\
    \    else:\n        smallest_index = 0\n    return [smalest_value, smallest_index]\n\
    \n\"\"\"", "    # Your code goes here\n    result = []\n    smallest = float(\"\
    inf\")\n    smallest_idx = 0\n    size = len(arr)\n    arr.sort()\n    for i in\
    \ range(size):\n        if i % 2 == 0:\n            if smallest == float(\"inf\"\
    ):\n                smallest = arr[i]\n                smallest_idx = i\n    \
    \        elif arr[i] < smallest:\n                smallest = arr[i]\n        \
    \        smallest_idx = i\n        else:\n            if smallest == float(\"\
    inf\"):\n                smallest = arr[i]\n                smallest_idx = i\n\
    \            elif arr[i] == smallest:\n                smallest_idx += 1\n   \
    \ result.append((smallest, smallest_idx))\n    return result\n</cell>\n<text>\n\
    Solution\nWe can solve the above problem by using a function named pluck to find\
    \ the smallest even value in the given array and returning the smallest index\
    \ that has it.\n\n\n</text>\n<cell>", "    if arr is None or len(arr) == 0:\n\
    \        return []\n\n    # first sort\n    arr.sort()\n\n    # find the smallest\
    \ even value\n    smallest_even_value: int = arr[0]\n    smallest_even_index:\
    \ int = arr[0]\n\n    # find the first even\n    for i, num in enumerate(arr):\n\
    \        if num % 2 == 0:\n            smallest_even_index = i\n            smallest_even_value\
    \ = num\n\n    # return the smallest even value\n    return [smallest_even_value],\
    \ smallest_even_index\n\n", "    if not arr:\n        return []\n    min_val =\
    \ arr[0]\n    min_idx = 0\n    i = 0\n    while(i < len(arr)):\n        if arr[i]\
    \ < min_val:\n            min_val = arr[i]\n            min_idx = i\n        i\
    \ += 1\n    arr.remove(arr[min_idx])\n    return [ min_val, min_idx ]\n", "  \
    \  pass\n", "    def helper(arr: List[int], idx: int, even: List[int], i: int)\
    \ -> List[int]:\n        if idx == len(arr):\n            return []\n        if\
    \ even:\n            even = sorted(even, key=lambda x: x[0])\n            if even[0][0]\
    \ == arr[idx]:\n                idx = even[0][1]\n            else:\n        \
    \        idx = -1\n        else:\n            even = []\n            if arr[idx]\
    \ % 2 == 0:\n                even.append([arr[idx], idx])\n            else:\n\
    \                idx = -1\n        return helper(arr, idx+1, even, i+1)\n\n  \
    \  helper(arr, 0, 0, 0)\n    return even\n</cell>\n<cell>\nfrom typing import\
    \ List\n", "    # Your code here\n    even_values = [x for x in arr if x % 2 ==\
    \ 0]\n    if even_values:\n        smallest_value = min(even_values)\n       \
    \ smallest_index = even_values.index(smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    else:\n        return []\n", "    # Your code here\n  \
    \  if len(arr) == 0:\n        return []\n\n    if all(elem % 2 == 0 for elem in\
    \ arr):\n        return arr[0]\n    else:\n        min_val = min(arr)\n      \
    \  if min_val % 2 == 0:\n            return min_val, arr.index(min_val)\n    \
    \    else:\n            index_of_max_val = arr.index(min_val)\n            return\
    \ arr[index_of_max_val], index_of_max_val\n", "    arr1=sorted(arr)\n    evens=filter(lambda\
    \ x: x%2==0,arr1)\n    if len(evens)==len(arr1):\n        return [evens[0],arr1.index(evens[0])]\n\
    \    elif len(evens)==0:\n        return []\n    else:\n        return pluck(evens[:1]+arr1)\n",
  "    if not arr:\n        return []\n    \n    even = arr[0]\n    index_of_first_even_node\
    \ = 0\n    \n    for ind, n in enumerate(arr):\n        if n % 2 == 0:\n     \
    \       even = n\n            index_of_first_even_node = ind\n            break\n\
    \n    if even == 0:\n        return [even, index_of_first_even_node]\n\n    return\
    \ pick_smallest_index_of_n_equal_nodes(even, index_of_first_even_node, arr[1:])\n",
  "    \n    if not arr:\n        return []\n\n    min_value = arr[0]\n    min_value_index\
    \ = 0\n    \n    for index,value in enumerate(arr):\n        if value % 2 == 0:\n\
    \            if value < min_value:\n                min_value = value\n      \
    \          min_value_index = index\n    \n    return [ min_value, min_value_index\
    \ ]\n</cell>\n<cell>", "    if not arr or len(arr) == 1:\n        return []\n\
    \    even_values = arr[0::2]\n    sorted_even_values = sorted(even_values)\n \
    \   smallest_value = sorted_even_values[0]\n    smallest_index = 0\n    for i\
    \ in range(0, len(arr)):\n        if arr[i] < smallest_value:\n            smallest_value\
    \ = sorted_even_values[i]\n            smallest_index = i\n    return arr[0:smallest_index+1]\n",
  "    # Fill this in.\n    return \n", "    # initialize result\n    result = []\n\
    \n    # traverse the given array\n    for node in arr:\n        # traverse the\
    \ remaining array from the current node\n        index = 0\n        while index\
    \ < len(arr) and arr[index] <= node:\n            index += 1\n\n        # append\
    \ the index\n        result.append(index)\n\n    # return the result\n    return\
    \ result\n", "    return sorted(arr, key=lambda x: x % 2, reverse=True)[:2]\n",
  "    pass\n", "    if not arr:\n        return []\n    # write your code here\n\
    \    min_even_val = min(arr)\n    idx = arr.index(min_even_val)\n    min_even_val_idx\
    \ = idx\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n        \
    \    if min_even_val_idx != i:\n                min_even_val_idx = i\n       \
    \         break\n    return [min_even_val, min_even_val_idx]\n</cell>\n<cell>",
  "    # Solution 1:\n    # Create a list with pairs ( value, index )\n    # Sort\
    \ by value\n    # Select the first one if there are multiple with the same value\n\
    \    # Remove them if there aren't any\n    # Return the pair\n    # Slower solution\n\
    \    \n    # Solution 2\n    # Sort the list\n    # Return the first element\n\
    \    \n    # Solution 3\n    # Sort the list\n    # Return the first element\n\
    \n    # Solution 4\n    # Sort the list\n    # Return the last element\n    \n\
    \    # Solution 5\n    # Sort the list\n    # Return the first element if there\
    \ are no even values\n    \n    # Solution 6\n    # Sort the list\n    # Return\
    \ the last element\n    \n", "    if not arr or len(arr) == 0:\n        return\
    \ []\n\n    largest = 0\n    smallest = 0\n    index = -1\n\n    # Loop through\
    \ each node and find the largest and smallest even value\n    for i, node in enumerate(arr):\n\
    \        if node % 2 == 0:\n            largest_even_value = largest_even_index\
    \ = 0\n            smallest_even_value = smallest_even_index = 0\n           \
    \ largest_even_value, largest_even_index = find_largest_even_and_smallest(arr,\
    \ i)\n            smallest_even_value, smallest_even_index = find_largest_even_and_smallest(arr,\
    \ i + 1)\n\n            # Set the index if it is largest\n            if largest_even_value\
    \ > largest:\n                largest = largest_even_value\n                index\
    \ = largest_even_index\n                \n            # Set the index if it is\
    \ smallest\n            if smallest_even_value < smallest:\n                smallest\
    \ = smallest_even_value\n                index = smallest_even_index\n\n    arr[index],\
    \ arr.pop(index)\n\n    return arr\n", "    pass\n\n", "    pass\n</cell>\n<cell>",
  "    pass\n", "    \n    # Your code goes here\n    min_value = None\n    smallest_index\
    \ = None\n    \n    for index, value in enumerate(arr):\n        if value % 2\
    \ == 0:\n            if min_value is None or value < min_value:\n            \
    \    min_value = value\n                smallest_index = index\n\n    if min_value\
    \ is None or min_value == 0:\n        return arr\n    else:\n        return [min_value,\
    \ smallest_index]\n\n", "    # Your code here\n    pass\n", "    if not arr:\n\
    \        return []\n\n    smallest_value_index = None\n    smallest_value = None\n\
    \    for index, value in enumerate(arr):\n        if value % 2 == 0:\n       \
    \     if smallest_value == None or value < smallest_value:\n                smallest_value\
    \ = value\n                smallest_value_index = index\n    return [smallest_value,\
    \ smallest_value_index]\n", "    # Your code here\n    \n    return []\n\n", " \
    \   pass\n</cell>\n<text>\n51. Find Median in a BST\nQuestion\n\n\nGiven a binary\
    \ search tree, write a function which returns the median of the values in the\
    \ tree.\n\nYou may assume that the values in the nodes of the tree are distinct.\n\
    \nExample:\n\nInput: [1,null,2,3]\nOutput: 2.5\nExplanation: 3 is the median of\
    \ the subtree [1,2,3].\n\n</text>\n<cell>", "    arr = sorted(arr)\n    smalest_value\
    \ = arr[0]\n    smalest_index = 0\n    even_found = False\n    index_found = False\n\
    \    for i in range(len(arr)):\n        if even_found == False and arr[i] % 2\
    \ == 0:\n            smalest_value = arr[i]\n            smalest_index = i\n \
    \           even_found = True\n        if even_found == True and arr[i] % 2 !=\
    \ 0:\n            if arr[i] != smalest_value:\n                index_found = True\n\
    \                break\n    if index_found == True:\n        return [ smalest_value,\
    \ smalest_index ]\n    else:\n        return []\n        ", '    return ', " \
    \   # write your code here\n    if len(arr)==0:\n        return []\n    \n   \
    \ min_value_index=0\n    min_value=arr[0]\n    for i in arr:\n        if i%2==0:\n\
    \            if min_value<i:\n                min_value_index=arr.index(i)\n \
    \               min_value=i\n        else:\n            if min_value<i:\n    \
    \            min_value_index=arr.index(i)\n                min_value=i\n    if\
    \ min_value==arr[0]:\n        return [min_value,min_value_index]\n    else:\n\
    \        return [min_value,min_value_index]\n                \n\"\"\"\n    Runtime:\n\
    \        Best: O(n) -- Best: O(1)\n        Average: O(n) -- Average: O(n)\n  \
    \      Worst: O(n) -- Worst: O(n)\n        Space: O(n)\n\"\"\"", "    pass\n",
  "    pass\n", "    if not arr or len(arr) == 0:\n        return []\n    \n    even_values\
    \ = arr[1:][arr[1:]%2 == 0]\n    \n    smallest_value = min(even_values)\n   \
    \ smallest_index = None\n    for i, x in enumerate(even_values):\n        if x\
    \ == smallest_value:\n            smallest_index = i\n    if smallest_index ==\
    \ None:\n        return []\n    else:\n        return [ smallest_value, smallest_index\
    \ ]\n            \n</cell>\n<cell>", "    # Your code here\n    ans=[]\n    arr=sorted(arr)\n\
    \    evens=[x for x,y in zip(arr,arr[1:]) if y%2==0]\n    small=[x for x in evens\
    \ if x<min(evens)]\n    if small:\n        smallest=min(evens)\n        ans=[smallest,smallest.index(smallest)]\n\
    \    return ans\n", "    # complete this function\n    # use the function below\
    \ pluck from the module above\n    # this function must return a list of 2 integers\n\
    \    def pluck(node: List[int]) -> List[int]:\n        return min(node)\n<|/ file\
    \ ext=.py dstars=0 |>\n<| a dscore=0 |>\nThe question is asking for the smallest\
    \ number that is not an even number. I think the answer is that there is a small\
    \ probability of encountering such a number in a given list of non-negative integers.\n\
    <|/ a tags=python,data-structures |>\n<| c |>\nI think the answer is that the\
    \ probability of encountering such a number in a given list of non-negative integers\
    \ is greater than 1/2. See https://en.wikipedia.org/wiki/1/2_%2B_1/2_odds_and_ends\
    \ . You would need more data to find this out.\n<|/ c |>\n<| a dscore=0 |>\nI\
    \ solved it by creating a dictionary of the numbers. And then I sorted in ascending\
    \ order.\n<code>", "    pass\n</cell>\n<cell>", "    # write your code here\n\
    \    pass\n    ", "    pass\n", "    # Your code here\n    if not arr:\n     \
    \   return arr\n    min_val, min_idx = min(filter(lambda x:x%2 == 0, arr))\n \
    \   return [min_val, min_idx]\n\n</cell>\n<text>\nProblem 3c\n\n</text>\n<cell>",
  "    # Your code here\n    even_values = [index for index, value in enumerate(arr)\
    \ if value % 2 == 0]\n    if len(even_values) == 0:\n        return []\n\n   \
    \ smallest_index = None\n    smallest_value = even_values[0]\n    for value in\
    \ even_values:\n        if value <= smallest_value:\n            smallest_value\
    \ = value\n            smallest_index = index\n        elif value == smallest_value:\n\
    \            smallest_index = index\n    return [smallest_value, smallest_index]\n",
  "    if not arr:\n        return []\n    \n    sorted_list = sorted(arr)\n    \n\
    \    while sorted_list:\n        if sorted_list[0] & 1:\n            smallest\
    \ = sorted_list[0]\n            index = sorted_list[0]\n            sorted_list.remove(smallest)\n\
    \            if sorted_list:\n                smallest = sorted_list[0]\n    \
    \            index = sorted_list[0]\n                sorted_list.remove(smallest)\n\
    \            return [smallest, index]\n        else:\n            smallest = sorted_list[0]\n\
    \            index = sorted_list[0]\n            sorted_list.remove(smallest)\n\
    \            if sorted_list:\n                smallest = sorted_list[0]\n    \
    \            index = sorted_list[0]\n                sorted_list.remove(smallest)\n\
    \            return [index]\n\n", "    even_values = []\n    smalest_value = None\n\
    \    smallest_index = None\n\n    for index, node in enumerate(arr):\n       \
    \ if node % 2 == 0 and node != 0:\n            if smallest_index is None:\n  \
    \              smallest_index = index\n                smalest_value = node\n\
    \            elif smalest_value is None:\n                smalest_value = node\n\
    \            elif smalest_value > node:\n                smalest_value = node\n\
    \                smallest_index = index\n        elif smallest_index is not None:\n\
    \            if smalest_value is None:\n                smalest_value = node\n\
    \            elif smalest_value > node:\n                smalest_value = node\n\
    \                smallest_index = index\n            elif smalest_value == node:\n\
    \                smalest_value = node\n                smallest_index = index\n\
    \        elif node % 2 == 0:\n            if smallest_index is None:\n       \
    \         smallest_index = index\n                smalest_value = node\n     \
    \       elif smalest_value is None:\n                smalest_value = node\n  \
    \          elif smalest_value > node:\n                smalest_value = node\n\
    \                smallest_index = index\n        else:\n            if smallest_index\
    \ is not None:\n                smalest_value = node\n                smallest_index\
    \ = index\n    return smalest_value, smallest_index\n\n", "    # Your code here\n\
    \    if len(arr)==0:\n        return []\n    smalest_value=0\n    smallest_index=0\n\
    \    for i in range(0,len(arr)):\n        if arr[i]%2==0:\n            smalest_value=arr[i]\n\
    \            smallest_index=i\n        else:\n            if arr[i]<smalest_value:\n\
    \                smalest_value=arr[i]\n                smallest_index=i\n    return\
    \ smallest_index\n\n", "    if arr == []:\n        return []\n\n    even_values\
    \ = []\n    smalest_value = None\n    smalest_index = None\n    for i in range(len(arr)):\n\
    \        if arr[i] % 2 == 0:\n            even_values.append(arr[i])\n       \
    \     if smalest_value == None:\n                smalest_value = arr[i]\n    \
    \            smalest_index = i\n            else:\n                if arr[i] <\
    \ smalest_value:\n                    smalest_value = arr[i]\n               \
    \     smalest_index = i\n    \n    if smalest_value != None:\n        return [smalest_value,\
    \ smalest_index]\n    else:\n        return even_values\n", "    min_even_val\
    \ = min([n for n in arr if n % 2 == 0])\n    min_even_val_index = arr.index(min_even_val)\n\
    \n    if len(arr) == 0:\n        return []\n\n    smallestValueIndexes = []\n\n\
    \    # iterating over the whole array and finding the smallest values indexes.\n\
    \    for i in range(len(arr)):\n        if (arr[i] % 2 == 0) and (arr[i] < min_even_val):\n\
    \            smallestValueIndexes.append(i)\n            min_even_val = arr[i]\n\
    \            min_even_val_index = i\n\n    return smallestValueIndexes\n", " \
    \   if arr == []:\n        return []\n\n    arr2 = []\n    odd = []\n    even\
    \ = []\n\n    for i in range(len(arr)):\n        if arr[i] % 2 == 1:\n       \
    \     even.append(arr[i])\n        elif arr[i] % 2 == 0:\n            odd.append(arr[i])\n\
    \        else:\n            pass\n    odd.sort()\n    even.sort()\n\n    if len(odd)\
    \ == 0:\n        arr2.append(even[0])\n        return arr2\n\n    idx = 0\n  \
    \  while idx < len(odd) and idx < len(even):\n        if odd[idx] == even[idx]:\n\
    \            arr2.append(odd[idx])\n            idx += 1\n        else:\n    \
    \        if odd[idx] < even[idx]:\n                idx += 1\n            else:\n\
    \                arr2.append(even[idx])\n                idx += 1\n    return\
    \ arr2\n", "    # todo write your code here\n    \n    return []\n", "    if not\
    \ arr or len(arr) == 0:\n        return []\n\n    smallest_even = arr[0]\n   \
    \ smallest_even_index = 0\n\n    for idx, node in enumerate(arr[1:], 1):\n   \
    \     if node % 2 == 0:\n            if smallest_even_index == 0:\n          \
    \      smallest_even = node\n                smallest_even_index = idx\n     \
    \       elif smallest_even_index == idx:\n                smallest_even = node\n\
    \                smallest_even_index = idx\n        else:\n            smallest_even\
    \ = node\n            smallest_even_index = idx\n\n    return smallest_even_index,\
    \ smallest_even\n", "    pass\n", "    # Your code here\n    even = [x for x in\
    \ arr if x%2 ==0]\n    even = sorted(even,key = lambda x:x)\n    return even[0]\n\
    \narr1 = []\narr2 = []\narr3 = []\narr4 = []\narr5 = []\narr6 = []\narr7 = []\n\
    arr8 = []\narr9 = []\narr10 = []\n\nfor _ in range(6):\n    arr1.append(int(input()))\n\
    \    arr2.append(int(input()))\n    arr3.append(int(input()))\n    arr4.append(int(input()))\n\
    \    arr5.append(int(input()))\n    arr6.append(int(input()))\n    arr7.append(int(input()))\n\
    \    arr8.append(int(input()))\n    arr9.append(int(input()))\n    arr10.append(int(input()))\n\
    \n\nlist1 = arr1\nlist2 = arr2\nlist3 = arr3\nlist4 = arr4\nlist5 = arr5\nlist6\
    \ = arr6\nlist7 = arr7\nlist8 = arr8\nlist9 = arr9\nlist10 = arr10\n\nprint(pluck(arr1))\n\
    print(pluck(arr2))\nprint(pluck(arr3))\nprint(pluck(arr4))\nprint(pluck(arr5))\n\
    print(pluck(arr6))\nprint(pluck(arr7))\nprint(pluck(arr8))\nprint(pluck(arr9))\n\
    print(pluck(arr10))\n\n</cell>\n<text>\n5\n\n</text>\n<cell>", "    pass\n", " \
    \   # Your code here\n    if not arr:\n        return []\n\n    sorted_arr = [i\
    \ for i in range(len(arr)) if arr[i] % 2 == 0]\n    if len(sorted_arr) == 0:\n\
    \        return []\n    else:\n        return sorted_arr[0]\n", "    pass\n</cell>\n\
    <cell>", "    if not arr:\n        return []\n    # Sort from smallest to largest\n\
    \    arr.sort()\n\n    # Find Smallest value that has even no. of occurrence\n\
    \    smallest = arr[0]\n    smalest_value = 0\n    for i in range(1, len(arr)):\n\
    \        if arr[i] % 2 == 0:\n            smalest_value = arr[i]\n           \
    \ smallest = arr[i]\n\n    # Now, find even no. of occurrence of smallest value\
    \ \n    even_value = [x for x in arr if x % 2 == 0]\n    even_value_length = len(even_value)\n\
    \n    if even_value_length == 0:\n        return []\n    elif even_value_length\
    \ == 1:\n        return [smalest_value, even_value[0]]\n\n    smaller_value =\
    \ even_value[0]\n    smaller_value_count = 0\n    for value in even_value:\n \
    \       if value < smaller_value:\n            smaller_value = value\n       \
    \     smaller_value_count = 0\n        elif value == smaller_value:\n        \
    \    smaller_value_count += 1\n\n    return [smallest, smalest_value + ((smaller_value_count\
    \ - 1) * smaller_value)]\n\n", "    # Your code here\n    n = len(arr)\n    if\
    \ n == 0:\n        return []\n    if n == 1:\n        return arr[0]\n    even_values\
    \ = [x%2 for x in arr]\n    if len(set(even_values)) == 1 and min(even_values):\n\
    \        return arr[0]\n    else:\n        small_values = sorted(list(set([x for\
    \ x in arr if x%2 == 0])))\n        return [x for x in small_values if arr[x%2==0]==arr[0]]\n",
  "    if not arr:\n        return []\n    smallest_value = min(arr)\n    if smallest_value\
    \ % 2 == 0 and smallest_value not in arr:\n        return [smallest_value, arr.index(smallest_value)]\n\
    \    else:\n        smallest_value_even = smallest_value // 2\n        smallest_value_index\
    \ = arr.index(smallest_value)\n        arr.remove(smallest_value)\n        arr.insert(smallest_value_index,\
    \ smallest_value_even)\n        return [smallest_value_even, smallest_value_index]\n\
    \narr = [4, 2, 3]\nprint(pluck(arr))\nprint(pluck([]))\n</cell>\n<text>\nPractice:\
    \ Tree Traversals\n\n</text>\n<cell>\nfrom typing import List\n", "    # Your\
    \ code goes here\n    return sorted(arr,key=lambda x: next(iter([int(n) for n\
    \ in str(x)if int(n) % 2 == 0])),reverse=True)\n\n", "    # Your code here\n \
    \   if len(arr) == 0:\n        return []\n    largest = arr[0]\n    smallest =\
    \ arr[0]\n    for i, x in enumerate(arr):\n        if x % 2 == 0:\n          \
    \  if x < largest:\n                largest = x\n            if x > smallest:\n\
    \                smallest = x\n            if smallest < smallest_value:\n   \
    \             smallest_value = smallest\n            if largest < largest_value:\n\
    \                largest_value = largest\n        else:\n            if x > largest:\n\
    \                largest = x\n            if x < smallest:\n                smallest\
    \ = x\n            if smallest < smallest_value:\n                smallest_value\
    \ = smallest\n            if largest < largest_value:\n                largest_value\
    \ = largest\n    return [smallest_value, smallest_index]\n\n", "    pass\n", " \
    \   pass\n", "    # Your code here\n    if arr == []:\n        return []\n   \
    \ even = sorted(arr,reverse=True)[::2]\n    even.sort()\n    even = [x for x in\
    \ even if x%2 == 0]\n    if len(even) == 0:\n        return []\n    even.sort()\n\
    \    even = even[0]\n    smallest = arr[even[0]]\n    smallest_index = even[0]\n\
    \    for index in arr:\n        if index == even:\n            return [index,index]\n\
    \        if index < even:\n            continue\n        elif index > even:\n\
    \            smallest = index\n            smallest_index = index\n    return\
    \ smallest,smallest_index\n", "    solution = Solution()\n    return solution.pluck(arr)\n",
  "    pass\n", "    if not arr:\n        return []\n    odd = []\n    even = []\n\
    \    for i, x in enumerate(arr):\n        if x % 2 == 0:\n            even.append(x)\n\
    \        else:\n            odd.append(x)\n    odd = list(sorted(odd))\n    if\
    \ not odd:\n        return []\n    odd_even = odd + even\n    return odd_even[odd_even.index(min(odd_even))]\
    \ if min(odd_even) % 2 == 0 else odd_even[odd_even.index(min(odd_even))-1]\n",
  "    pass\n", "    if arr:\n        smalest_value = min(arr)\n        smalest_index\
    \ = arr.index(smalest_value)\n        return [smalest_value, smalest_index]\n\
    \    else:\n        return []", "    pass\n</cell>\n<text>\nPractice\nCan you\
    \ write a function that can pluck an item from a given list?\n\n\n</text>\n<cell>",
  "    from functools import reduce\n    \n    if not arr:\n        return []\n\n\
    \    even_values = filter(lambda x: x % 2 == 0, arr)\n    if len(even_values)\
    \ == 0:\n        return []\n    min_even_val = min(even_values)\n    min_even_val_index\
    \ = arr.index(min_even_val)\n    plucked_vals = [min_even_val]\n    plucked_val_indexes\
    \ = [min_even_val_index]\n    \n    i = 1 # We want to skip the first element\n\
    \    while i < len(arr):\n        if arr[i] % 2 == 0 and arr[i] < min_even_val:\n\
    \            min_even_val = arr[i]\n            min_even_val_index = i\n     \
    \       plucked_vals.append(min_even_val)\n            plucked_val_indexes.append(min_even_val_index)\n\
    \        i += 1\n    return plucked_vals, plucked_val_indexes\n", "    return\
    \ arr\n    ", "    return sorted(arr)[:2]\n\n", "    if not arr or not arr.__iter__:\n\
    \        return []\n    result = []\n    largest = arr[0]\n    smallest = arr[0]\n\
    \    for index, value in enumerate(arr):\n        if value == largest:\n     \
    \       smallest = value\n        elif value == smallest and value % 2 == 0:\n\
    \            smallest = value\n        else:\n            result.append((smallest,\
    \ index))\n            largest = value\n    return sorted(result)\n", "    def\
    \ pick_node(node):\n        \"\"\"\n        If we have seen all the even values,\
    \ pick the smallest one among them and return it.\n        If we have seen all\
    \ the odd values, pick the smallest one among them and return it.\n        If\
    \ we have not seen the even values, pick the smallest one among them and return\
    \ it.\n        If we have not seen all the odd values, return -1.\n        \"\"\
    \"\n        if node.is_even():\n            smallest_value = node.value\n    \
    \        smallest_index = 0\n            for index in range(1, node.size): \n\
    \                if node.values[index] % 2 == 0:\n                    smallest_value\
    \ += node.values[index]\n                    smallest_index = index\n        \
    \    return smallest_value, smallest_index\n        elif node.is_odd():\n    \
    \        smallest_value = node.value\n            smallest_index = 0\n       \
    \     for index in range(1, node.size): \n                if node.values[index]\
    \ % 2 != 0:\n                    smallest_value += node.values[index]\n      \
    \              smallest_index = index\n            return smallest_value, smallest_index\n\
    \        elif node.is_even() == False and node.is_odd() == False:\n          \
    \  if node.size == 0: return -1\n            else:\n                smallest_value\
    \ = node.value\n                smallest_index = 0\n                for index\
    \ in range(1, node.size): \n                    if node.values[index] % 2 != 0:\n\
    \                        smallest_value += node.values[index]\n              \
    \          smallest_index = index\n                return smallest_value, smallest_index\n\
    \n    arr_size = len(arr)\n    if arr_size == 0:\n        return []\n    else:\n\
    \        even_values = []\n        for index in range(arr_size):\n           \
    \ node = arr[index]\n            if node.is_even():\n                even_values.append(node.value)\n\
    \            else:\n                odd_values = []\n                for index\
    \ in range(arr_size):\n                    node = arr[index]\n               \
    \     if node.is_odd():\n                        odd_values.append(node.value)\n\
    \                return even_values[arr.index(min(even_values))], arr.index(min(even_values))\n\
    \    ", "    # Your code goes here\n    \n    # Your code goes here\n    return\
    \ smalest_value, smallest_index\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
