name: HumanEval_61_correct_bracketing
language: py
prompt: "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a\
  \ string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding\
  \ closing bracket.\n\n    >>> correct_bracketing('(')\n    False\n    >>> correct_bracketing('()')\n\
  \    True\n    >>> correct_bracketing('(()())')\n    True\n    >>> correct_bracketing(')(()')\n\
  \    False\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('()') == True\n    assert candidate('(()())')\
  \ == True\n    assert candidate('()()(()())()') == True\n    assert candidate('()()((()()())())(()()(()))')\
  \ == True\n    assert candidate('((()())))') == False\n    assert candidate(')(()')\
  \ == False\n    assert candidate('(') == False\n    assert candidate('((((') ==\
  \ False\n    assert candidate(')') == False\n    assert candidate('(()') == False\n\
  \    assert candidate('()()(()())())(()') == False\n    assert candidate('()()(()())()))()')\
  \ == False\n\ndef test_check():\n    check(correct_bracketing)\n\ntest_check()\n"
completions: ["    return len(set(brackets)) == 2 and all(bracket.endswith(')') for\
    \ bracket in brackets)\n", "    stack = []\n    for index, value in enumerate(brackets):\n\
    \        if value == '(':\n            stack.append(value)\n        elif value\
    \ == ')':\n            if not stack:\n                return False\n         \
    \   if stack.pop() != value:\n                return False\n    return not stack\n\
    \n", "    stack = []\n    for char in brackets:\n        if char == '(':\n   \
    \         stack.append(char)\n        elif char == ')':\n            if len(stack)\
    \ == 0:\n                return False\n            else:\n                stack.pop()\n\
    \    return len(stack) == 0\n\n", "    stack = []\n    for c in brackets:\n  \
    \      if c == '(':\n            stack.append(c)\n        elif c == ')' and stack.pop()\
    \ != '(':\n            return False\n    return not stack\n", "    stack = []\n\
    \    for char in brackets:\n        if char == '(':\n            stack.append(char)\n\
    \        elif char == ')':\n            if len(stack) == 0:\n                return\
    \ False\n            if stack.pop() != '(':\n                return False\n  \
    \  return len(stack) == 0\n\n", "    stack = []\n    for char in brackets:\n \
    \       if char == '(':\n            stack.append(char)\n        elif char ==\
    \ ')':\n            if len(stack) == 0:\n                return False\n      \
    \      else:\n                last_item = stack.pop()\n                if last_item\
    \ != '(':\n                    return False\n    return len(stack) == 0\n", " \
    \   counts = collections.Counter(brackets)\n    has_correct_bracketing = not all([value\
    \ == 0 for value in counts.values()])\n    return has_correct_bracketing\n", " \
    \   stack = []\n    for char in brackets:\n        if char == '(':\n         \
    \   stack.append(char)\n        else:\n            if stack:\n               \
    \ if stack.pop() != ')':\n                    return False\n            else:\n\
    \                return False\n    return True\n", "    stack = []  # type: List[Tuple[bool,\
    \ str, str]]\n    for c in brackets:\n        if c == \"(\":\n            stack.append((False,\
    \ \"(\", \"\"))\n        elif c == \")\":\n            if len(stack) == 0:\n \
    \               return False\n            else:\n                (_, s, res) =\
    \ stack.pop()\n                if not s:\n                    return False\n \
    \               else:\n                    stack.append((True, res, \"\"))\n \
    \       else:\n            stack[-1][-1] += c\n\n    if len(stack) != 1:\n   \
    \     return False\n\n    _, is_opening, s = stack.pop()\n    return not is_opening\n\
    \n", "    num_open_brackets = 0\n    for c in brackets:\n        if c == '(':\n\
    \            num_open_brackets += 1\n        elif c == ')':\n            if not\
    \ num_open_brackets:\n                return False\n            num_open_brackets\
    \ -= 1\n        else:\n            return False\n    return True\n\n", "    brackets_dict\
    \ = {'(':')', '[':']', '{':'}'}\n    brackets_set = set(brackets)\n    return\
    \ not (len(brackets_dict) - len(brackets_set))\n\n", "    if brackets == '()':\n\
    \        return True\n    if brackets == '[]':\n        return True\n    if brackets\
    \ == '{}':\n        return True\n    return False\n\n", "    if brackets.count('(')\
    \ != brackets.count(')'):\n        return False\n\n    stack = []\n    for c in\
    \ brackets:\n        if c == '(':\n            if stack:\n                return\
    \ False\n            stack.append(c)\n        elif c == ')':\n            if len(stack)\
    \ == 0:\n                return False\n            open_bracket = stack.pop()\n\
    \            if open_bracket != '(':\n                return False\n        else:\n\
    \            return False\n\n    if stack:\n        return False\n\n    return\
    \ True\n\n", "    if brackets == ')':\n        return True\n    if brackets ==\
    \ '(' or brackets == ')(' or brackets == '((' or brackets == ')(' or brackets\
    \ == '(' or brackets == '):)':\n        return False\n    ", "    if brackets\
    \ == \"()\":\n        return True\n    if brackets == '()':\n        return True\n\
    \    if brackets == '[]':\n        return True\n    if brackets == '{}':\n   \
    \     return True\n    if brackets == '<>':\n        return True\n    if brackets\
    \ == '<>=':\n        return True\n    if brackets == '===':\n        return True\n\
    \    if brackets == '==':\n        return True\n    if brackets == '!=':\n   \
    \     return True\n    return False\n\n", "    stack = collections.deque([-1])\n\
    \    opening = set(brackets)\n    for index, symbol in enumerate(brackets):\n\
    \        if symbol in opening:\n            stack.append(index)\n        if symbol\
    \ == '(':\n            opening.remove(symbol)\n            if len(stack) == 1:\n\
    \                return False\n            else:\n                top = stack.pop()\n\
    \                if top - 1 == index:\n                    return True\n    return\
    \ False\n\n", "    stack = collections.deque()\n    for char in brackets:\n  \
    \      if char == '(':\n            stack.append(char)\n        elif char == ')':\n\
    \            if not stack:\n                return False\n            opening\
    \ = stack.popleft()\n            if opening != ')':\n                return False\n\
    \        else:\n            return False\n    return not stack\n\n", "    brackets\
    \ = brackets.strip()\n    if len(brackets) <= 1:\n        return False\n    brackets_open\
    \ = brackets.count('(')\n    brackets_closed = brackets.count(')')\n    if brackets_open\
    \ != brackets_closed:\n        return False\n    return brackets_open >= 1\n\n",
  "    stack = [False] * len(brackets)\n    stack[0] = True\n    openings = 0\n  \
    \  i = 0\n\n    while i < len(brackets):\n        if brackets[i] == \")\":\n \
    \           stack.pop()\n        elif brackets[i] == \"(\":\n            stack.append(False)\n\
    \            openings += 1\n        elif brackets[i] == \")\" and stack.pop():\n\
    \            openings -= 1\n        i += 1\n    return openings == 0\n\n", " \
    \   stack = []\n    for char in brackets:\n        if char in \"([{\":\n     \
    \       stack.append(char)\n        elif char in \")]}\":\n            if not\
    \ stack:\n                return False\n            else:\n                top\
    \ = stack.pop()\n                if top != \")\":\n                    return\
    \ False\n    return not stack\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
