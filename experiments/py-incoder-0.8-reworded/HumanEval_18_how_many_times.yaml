name: HumanEval_18_how_many_times
language: py
prompt: "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find\
  \ how many times a given substring can be found in the original string. Count overlaping\
  \ cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa',\
  \ 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx',\
  \ 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john\
  \ doe', 'john') == 1\n\ndef test_check():\n    check(how_many_times)\n\ntest_check()\n"
completions: ["    return len(re.findall(substring, string))\n\n", "    substring_length\
    \ = len(substring)\n    count = 0\n    for index in range(len(string)):\n    \
    \    if string[index:index + substring_length] == substring:\n            count\
    \ += 1\n    return count\n\n", "    \n    # Search for the substring within the\
    \ original string\n    index = string.find(substring)\n    \n    # Count the number\
    \ of occurrences of that substring\n    return index if index >= 0 else -1\n\n",
  "    count = 0\n\n    for i, ele in enumerate(string):\n        if ele == substring[0]:\n\
    \            count += how_many_times(string[i + 1:], substring[1:])\n        else:\n\
    \            count += 1\n\n    return count\n\n", "    return sum(s.lower().count(substring.lower())\
    \ for s in string.split(' '))\n\n", "    count = 0\n    size = len(string)\n \
    \   sub_len = len(substring)\n\n    for index in range(size):\n        char =\
    \ string[index]\n        if char == substring[0]:\n            count += how_many_times(string[index\
    \ + 1:], substring[1:])\n        elif char == substring[-1]:\n            count\
    \ += how_many_times(string[index + 1:], substring[1:])\n        elif char == substring[0]:\n\
    \            count += how_many_times(string[index + 1:], substring[1:])\n    \
    \    else:\n            if index + sub_len <= size:\n                count +=\
    \ how_many_times(string[index + 1:index + sub_len], substring)\n            else:\n\
    \                count += 1\n\n    return count\n\n", "    pos = 0\n    count\
    \ = 0\n    sub_len = len(substring)\n    while True:\n        pos = string.find(substring,\
    \ pos)\n        if pos == -1:\n            return count\n        count += 1\n\
    \        pos += 1\n        if pos >= len(string):\n            return count\n\n",
  "    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if\
    \ string[i: i + len(substring)] == substring:\n            count += 1\n    return\
    \ count\n\n", "    return sum(substring in s for s in string.split(substring))\n\
    \n", "    start = string.find(substring)\n    if start == -1:\n        return\
    \ 0\n    stop = start + len(substring)\n    return stop - string.rfind(substring,\
    \ 0, stop)\n\n", "    if string is None or substring is None:\n        return\
    \ 0\n    count = 0\n    i = 0\n    while i < len(string):\n        if string[i:i+len(substring)]\
    \ == substring:\n            count += 1\n        i += len(substring)\n    return\
    \ count\n", "    return len([s for s in string.split(substring) if len(s) >= len(substring)])\n\
    \n", "    return string.lower().count(substring.lower())\n\n", "    count = 0\n\
    \    for i in range(len(string) - len(substring) + 1):\n        count += string.count(substring,\
    \ i, i + len(substring))\n    return count\n\n", "    return string.count(substring)\n\
    \n", "    count = 0\n    s = string.lower()\n    sub = substring.lower()\n   \
    \ if sub in s:\n        count += 1\n    sub_len = len(sub)\n    sub_count = s.count(sub)\n\
    \    for i in range(0, len(s)-sub_len):\n        if s[i:i+sub_len] == sub:\n \
    \           count += 1\n    return count\n\n", "    count = 0\n    start = 0\n\
    \    while start < len(string) and start < len(substring):\n        if string[start]\
    \ == substring[start:]:\n            count += 1\n        start += 1\n    return\
    \ count\n\n", "    if substring not in string:\n        return 0\n    substring\
    \ = string.lower()\n    return len([1 for c in string if c in substring])\n\n",
  "    \n    # check if string and substring are empty\n    if string == '' and substring\
    \ == '':\n        return 0\n    \n    # check if string and substring are equal\n\
    \    if string == substring:\n        return 1\n    \n    # find start position\
    \ of substring in string\n    start = string.find(substring)\n    \n    # check\
    \ if substring is not found\n    if start == -1:\n        return 0\n    \n   \
    \ # find end of substring in string\n    end = start + len(substring)\n    \n\
    \    # check if substring is not found\n    if end < len(string):\n        # check\
    \ if substring is not found at the end of string\n        if string[end] == substring:\n\
    \            return 1\n        \n    # check if substring is found at the end\
    \ of string\n    return 0\n</cell>\n<cell>", "    count = 0\n    found = 0\n \
    \   str_len = len(string)\n    substr_len = len(substring)\n\n    if substr_len\
    \ <= 1:\n        return found\n\n    # start from beginning\n    i = -1\n\n  \
    \  while i < str_len - substr_len + 1:\n        found = found + substr_len\n \
    \       i = string.find(substring, i)\n\n        if i == -1:\n            break\n\
    \n        if found > str_len:\n            return found\n        else:\n     \
    \       count = count + 1\n\n    return found\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
