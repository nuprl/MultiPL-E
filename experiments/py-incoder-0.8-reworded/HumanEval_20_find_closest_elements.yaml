name: HumanEval_20_find_closest_elements
language: py
prompt: "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float])\
  \ -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length\
  \ at least two) select and return two that are the closest to each\n    other and\
  \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
  \ == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n\
  \    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert\
  \ candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1,\
  \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\ndef test_check():\n    check(find_closest_elements)\n\
  \ntest_check()\n"
completions: ["    diffs_sq = map(lambda x: (x-numbers[0])**2 , numbers)\n    min_diff\
    \ = min(diffs_sq)\n    index = diffs_sq.index(min_diff)\n    return numbers[index],\
    \ numbers[index+1]\n", "    \n    smallest_number = min(numbers)\n    largest_number\
    \ = max(numbers)\n    \n    if smallest_number == largest_number:\n        return\
    \ (smallest_number, smallest_number)\n    \n    closest_numbers = []\n    \n \
    \   for number in numbers:\n        distance_to_number = largest_number - number\n\
    \        \n        if abs(distance_to_number) < abs(smallest_number - number):\n\
    \            closest_numbers.append(number)\n        else:\n            closest_numbers.append(smallest_number)\n\
    \            closest_numbers.append(number)\n            \n    closest_numbers.append(smallest_number)\n\
    \    closest_numbers.append(largest_number)\n    \n    return tuple(closest_numbers)\n",
  "    numbers = sort_numbers(numbers)\n\n    diff = numbers[-1] - numbers[0]\n  \
    \  if diff > 0.0 or diff < 0.0:\n        raise ValueError(\"No number closer to\
    \ each. {}\".format(numbers))\n\n    diff = numbers[-1] - numbers[1]\n    if diff\
    \ > 0.0 or diff < 0.0:\n        numbers, numbers[1] = numbers[1], numbers[-1]\n\
    \    \n    return numbers[-2], numbers[-1]\n", "    # TODO docstring\n    return\
    \ min(numbers, key=lambda n: abs(n - numbers[0])), max(numbers, key=lambda n:\
    \ abs(n - numbers[0]))\n\n", "    sorted_numbers = sorted(numbers)\n    closest_two\
    \ = sorted_numbers[:2]\n    if abs(sorted_numbers[1] - sorted_numbers[0]) < abs(sorted_numbers[1]\
    \ - sorted_numbers[2]):\n        return (sorted_numbers[1], sorted_numbers[0])\n\
    \    else:\n        return (sorted_numbers[2], sorted_numbers[1])\n", "    smallest_number\
    \ = min(numbers)\n    closest_numbers = [i for i in numbers if i < smallest_number]\n\
    \    largest = max(closest_numbers)\n    if largest == smallest_number:\n    \
    \    return smallest_number, largest\n    elif largest - smallest_number > 0.5:\n\
    \        return smallest_number, largest\n    else:\n        return largest, smallest_number\n",
  "    min_idx, max_idx = 0, 1\n    closest_value = numbers[min_idx]\n    for i in\
    \ range(2, len(numbers)):\n        if abs(numbers[i] - closest_value) < abs(numbers[max_idx]\
    \ - closest_value):\n            min_idx, max_idx = i, max_idx\n        elif abs(numbers[i]\
    \ - closest_value) > abs(numbers[max_idx] - closest_value):\n            min_idx,\
    \ max_idx = i, min_idx\n        else:\n            break\n    return closest_value,\
    \ numbers[min_idx]\n", "    min_diff = float('infinity')\n    for elem in numbers:\n\
    \        diff = elem - min_diff\n        if diff < 0.0:\n            diff = diff\n\
    \        elif diff == 0.0 and min_diff == 0.0:\n            diff = elem\n    \
    \    else:\n            diff = abs(diff)\n        if diff == 0.0:\n          \
    \  diff = 1.0\n        if diff < min_diff:\n            min_diff = diff\n    \
    \        closest_elem = elem\n    return closest_elem\n", "    # use numpy for\
    \ efficiency\n    from numpy import array\n    numbers = array(numbers)\n    abs_differences\
    \ = abs(numbers - numbers[0])\n    smallest_difference = numbers[0]\n    largest\
    \ = numbers[0]\n    for i in range(len(numbers)):\n        if abs_differences[i]\
    \ != 0.0: # handle zero element case\n            smallest_difference = numbers[i]\
    \ if numbers[i] < smallest_difference else smallest_difference\n            largest\
    \ = numbers[i] if numbers[i] > largest else largest\n    # return in order\n \
    \   smaller_element = largest\n    larger_element = smallest_difference\n    return\
    \ smaller_element, larger_element\n", "    smallest = numbers[0]\n    largest\
    \ = numbers[0]\n    for n in numbers:\n        if n < smallest:\n            smallest\
    \ = n\n        elif n > largest:\n            largest = n\n    return (smallest,\
    \ largest)\n", "    if numbers[0] < numbers[1]:\n        return numbers[1], numbers[0]\n\
    \    else:\n        return numbers[0], numbers[1]\n", "    return min(numbers),\
    \ max(numbers)\n", "    assert len(numbers) >= 2\n    minimum = numbers[0]\n \
    \   maximum = numbers[-1]\n    for n in numbers[1:]:\n        if n < minimum:\n\
    \            minimum = n\n        elif n > maximum:\n            maximum = n\n\
    \    return (minimum, maximum)\n", "    smallest = numbers[0]\n    largest = numbers[0]\n\
    \    for n in numbers[1:]:\n        if n < smallest:\n            smallest = n\n\
    \        if n > largest:\n            largest = n\n    return smallest, largest\n\
    \n", "    assert len(numbers) >= 2, 'Passed list must have at least two elements'\n\
    \    diffs = [i-j for i, j in zip(numbers[:-1], numbers[1:])]\n    idx = np.argmin(diffs)\n\
    \    return (numbers[idx], numbers[idx+1])\n", "    assert len(numbers) >= 2\n\
    \n    min_diff = numbers[1] - numbers[0]\n    return tuple(min(numbers, key=lambda\
    \ n: abs(n - num))\n                 for num in numbers if abs(num - numbers[0])\
    \ < min_diff)\n", "    smallest = numbers[0]\n    largest = numbers[0]\n    for\
    \ n in numbers[1:]:\n        if n < smallest:\n            smallest = n\n    \
    \    elif n > largest:\n            largest = n\n    return smallest, largest\n",
  "    diff0 = abs(numbers[0] - numbers[1])\n    diff1 = abs(numbers[1] - numbers[2])\n\
    \    diff2 = abs(numbers[2] - numbers[3])\n    diff3 = abs(numbers[3] - numbers[4])\n\
    \    diff4 = abs(numbers[4] - numbers[5])\n    diff5 = abs(numbers[5] - numbers[6])\n\
    \    diff6 = abs(numbers[6] - numbers[7])\n    if diff0 < diff1:\n        if diff2\
    \ < diff3:\n            if diff4 < diff5:\n                if diff6 < diff7:\n\
    \                    return (numbers[0], numbers[1])\n                else:\n\
    \                    return (numbers[0], numbers[4])\n            else:\n    \
    \            return (numbers[0], numbers[2])\n        else:\n            return\
    \ (numbers[0], numbers[3])\n    else:\n        return (numbers[0], numbers[1])\n\
    \        \n</cell>\n<cell>", "    if len(numbers) == 1:\n        return numbers[0],\
    \ numbers[0]\n\n    numbers = numbers[1::2]\n    numbers.sort()\n\n    if numbers[0]\
    \ > numbers[1]:\n        return numbers[1], numbers[0]\n    else:\n        return\
    \ numbers[0], numbers[1]\n", "    smallest = numbers[0]\n    largest = numbers[0]\n\
    \n    smallest_dist = None\n    largest_dist = None\n\n    for num in numbers[1:]:\n\
    \        dist = abs(num - largest)\n        if smallest_dist is None:\n      \
    \      smallest_dist = dist\n        elif smallest_dist > dist:\n            smallest_dist\
    \ = dist\n            smallest = num\n\n        dist = abs(num - smallest)\n \
    \       if largest_dist is None:\n            largest_dist = dist\n        elif\
    \ largest_dist < dist:\n            largest_dist = dist\n            largest =\
    \ num\n\n    if smallest_dist is not None and largest_dist is not None:\n    \
    \    return (smallest, largest)\n    else:\n        return None\n\n", "    closest_pair\
    \ = min(zip(numbers, numbers[1:]))\n    return closest_pair[0], closest_pair[1]\n\
    \n", "    closest_numbers = []\n    closest_distances = []\n    smallest_number\
    \ = numbers[0]\n    largest_number = numbers[0]\n    for number in numbers:\n\
    \        closest_distance = (number - smallest_number).abs()\n        if closest_distance\
    \ < largest_number:\n            closest_number = smallest_number\n          \
    \  closest_distances = [closest_distance]\n            smallest_number = number\n\
    \        elif closest_distance > largest_number:\n            closest_number =\
    \ largest_number\n            closest_distances = [closest_distance]\n       \
    \     largest_number = number\n        else:\n            closest_distances.append(closest_distance)\n\
    \            closest_number = number\n        closest_numbers.append(closest_number)\n\
    \    return (smallest_number, largest_number)\n", "    distances = []\n    for\
    \ i in range(len(numbers) - 1):\n        distances.append(get_distance(numbers[i],\
    \ numbers[i+1]))\n\n    # find minimum\n    min_dist = min(distances)\n    min_idx\
    \ = distances.index(min_dist)\n\n    # return element and next element\n    return\
    \ numbers[min_idx], numbers[min_idx + 1]\n\n", "    if len(numbers) < 2:\n   \
    \     raise Exception('Not enough numbers for closest pair search')\n\n    numbers.sort()\n\
    \    return numbers[len(numbers) - 2], numbers[len(numbers) - 1]\n", "    if len(numbers)\
    \ < 2:\n        raise IndexError(\"Can not find two numbers that are close. Need\
    \ at least two numbers.\")\n\n    # sort so that we can find the two closest in\
    \ order\n    numbers.sort()\n\n    # Find the two closest numbers\n    smallest\
    \ = numbers[0]\n    biggest = numbers[-1]\n\n    diff = smallest - biggest\n\n\
    \    if diff > 0:\n        return (smallest, biggest)\n    else:\n        return\
    \ (numbers[-2], numbers[-1])\n", "    assert len(numbers) >= 2, \"find_closest_elements()\
    \ requires a list of at least two numbers\"\n    lowest_number = numbers[0]\n\
    \    highest_number = numbers[-1]\n    sorted_numbers = sorted(numbers)\n    closest_numbers\
    \ = (sorted_numbers[0], sorted_numbers[1])\n    # If the lowest or highest number\
    \ are themselves the closest then return them\n    if sorted_numbers[0] == lowest_number\
    \ or sorted_numbers[-1] == highest_number:\n        return closest_numbers\n \
    \   # Calculate which of the two numbers are closer to each other\n    difference_from_lowest\
    \ = sorted_numbers[-1] - lowest_number\n    difference_from_highest = highest_number\
    \ - sorted_numbers[0]\n    if difference_from_lowest < difference_from_highest:\n\
    \        closest_numbers = (lowest_number, sorted_numbers[0])\n    else:\n   \
    \     closest_numbers = (sorted_numbers[-1], highest_number)\n    return closest_numbers\n",
  "    smallest_difference = float('inf')\n    smallest_element = float('inf')\n \
    \   largest_difference = float('-inf')\n    largest_element = float('-inf')\n\n\
    \    for number in numbers:\n        if number < smallest_element:\n         \
    \   smallest_element = number\n            smallest_difference = float('inf')\n\
    \        elif number > largest_element:\n            largest_element = number\n\
    \            largest_difference = float('-inf')\n        else:\n            smallest_difference\
    \ = min(smallest_difference, abs(number - smallest_element))\n            largest_difference\
    \ = max(largest_difference, abs(number - largest_element))\n\n    if smallest_difference\
    \ == largest_difference:\n        return (smallest_element, smallest_element)\n\
    \    elif smallest_difference < largest_difference:\n        return (smallest_element,\
    \ largest_element)\n    else:\n        return (largest_element, smallest_element)\n",
  "    smallest_number = numbers[0]\n    greatest_number = numbers[0]\n    for number\
    \ in numbers:\n        if abs(number - greatest_number) < abs(number - smallest_number):\n\
    \            smallest_number = number\n        else:\n            greatest_number\
    \ = number\n    return smallest_number, greatest_number\n", "    if len(numbers)\
    \ < 2:\n        return None, None\n\n    # Find the min and max for the list of\
    \ numbers\n    extreme = numbers[0]\n    minimum = numbers[0]\n    maximum = numbers[0]\n\
    \    for num in numbers:\n        if num < minimum:\n            minimum = num\n\
    \        elif num > maximum:\n            maximum = num\n        else:\n     \
    \       return num, num\n\n    # Return two numbers that are within tolerance\
    \ of the minimum and maximum\n    tolerance = abs(minimum - maximum) / float(len(numbers))\n\
    \    closest_num = minimum\n    closest_index = -1\n    for i in range(0, len(numbers)):\n\
    \        if abs(numbers[i] - closest_num) < tolerance:\n            closest_num\
    \ = numbers[i]\n            closest_index = i\n    return closest_num, closest_index\n",
  "    if len(numbers) < 2:\n        raise RuntimeError('Cannot find two closest to\
    \ zero, no numbers supplied')\n    closest_values = []\n    closest_values_index\
    \ = 0\n    for index, value in enumerate(numbers):\n        delta_x = abs(value\
    \ - numbers[closest_values_index]) # Get the distance to the closest value\n \
    \       if delta_x < min(delta_x, closest_values[closest_values_index][1]):\n\
    \            closest_values = [(index, value)]\n            closest_values_index\
    \ = index\n        elif delta_x < max(delta_x, closest_values[closest_values_index][1]):\n\
    \            closest_values.append((index, value))\n            closest_values_index\
    \ = index\n        else:\n            closest_values.insert(0, (index, value))\n\
    \            closest_values_index = index\n    return closest_values\n", "   \
    \ smallest = numbers[0]\n    largest = numbers[0]\n\n    for n in numbers[1:]:\n\
    \        if n < smallest:\n            smallest = n\n        if n > largest:\n\
    \            largest = n\n\n    if smallest == largest:\n        return smallest,\
    \ largest\n\n    return smallest, largest\n", "    if len(numbers) < 2:\n    \
    \    raise IndexError('Must supply at least two numbers')\n    if len(numbers)\
    \ == 1:\n        raise IndexError('Cannot find two closest numbers')\n    return\
    \ min(numbers), max(numbers)\n", "    \n    return min(enumerate(numbers), key=lambda\
    \ pair: pair[1]-numbers[pair[0]])\n\n", "    if len(numbers) <= 1:\n        raise\
    \ RuntimeError(\"Cannot find two elements in list with no elements close to each\
    \ other\")\n    closest_one = numbers[0]\n    closest_two = numbers[1]\n    for\
    \ one in numbers[2:]:\n        diff = (one - closest_one) * (one - closest_one)\n\
    \        if diff < closest_two:\n            closest_two = diff\n            closest_one\
    \ = one\n    return (closest_one, closest_two)\n", "    closest_to_first = closest_to_last\
    \ = None\n    closest = None\n\n    for i, number in enumerate(numbers):\n   \
    \     if closest is None:\n            closest_to_first = number\n           \
    \ closest=number\n\n        elif abs(number-closest) < abs(number-closest_to_first):\n\
    \            closest_to_first = number\n            closest=number\n\n       \
    \ elif abs(number-closest) < abs(number-closest_to_last):\n            closest_to_last\
    \ = number\n\n    if closest is None:\n        return (numbers[-1], numbers[0])\n\
    \n    return closest_to_first, closest\n", "    # initialize smallest and largest\
    \ numbers to first and last numbers in supplied list\n    smallest = numbers[0]\n\
    \    largest = numbers[-1]\n\n    # find the smallest and largest values in the\
    \ list\n    for number in numbers:\n        if number < smallest:\n          \
    \  smallest = number\n        if number > largest:\n            largest = number\n\
    \n    # return the smallest and largest in order\n    return (smallest, largest)\n",
  "    assert len(numbers) >= 2\n\n    smallest_diff = numbers[0] - numbers[1]\n \
    \   larger_diff = numbers[-1] - numbers[-2]\n\n    if smallest_diff > larger_diff:\n\
    \        return numbers[1], numbers[-2]\n\n    return numbers[-2], numbers[1]\n\
    \n", "    smallest_index = min((numbers.index(i) for i in numbers))\n    largest_index\
    \ = max((numbers.index(i) for i in numbers))\n    return (numbers[smallest_index],\
    \ numbers[largest_index])\n", "    smallest_diff, largest_diff = numbers[0], numbers[0]\n\
    \    for index, num in enumerate(numbers[1:]):\n        diff = abs(num - numbers[index])\n\
    \        if diff < smallest_diff:\n            smallest_diff = diff\n        if\
    \ diff > largest_diff:\n            largest_diff = diff\n    return smallest_diff,\
    \ largest_diff\n", "    return sorted(numbers)[1::2]\n", "    assert len(numbers)\
    \ >= 2, 'There must be at least two numbers in the list of numbers'\n    return\
    \ sorted(numbers), sorted(numbers)[-1]\n", "    if len(numbers) < 2:\n       \
    \ raise ValueError(\"Two or more numbers are required to find the closest\")\n\
    \    sorted_numbers = sorted(numbers)\n    return sorted_numbers[0], sorted_numbers[-1]\n\
    \n", "    differences = [(abs(x - number), x) for x in numbers]\n    differences.sort()\n\
    \    return differences[0][1], differences[1][1]\n\n", "    lowest_number = min(numbers)\n\
    \    second_lowest_number = min(numbers, key=lambda n: abs(n - lowest_number))\n\
    \    return lowest_number, second_lowest_number\n\n", "    if len(numbers) < 2:\n\
    \        raise ValueError(\"numbers list is too short\")\n    return min(numbers),\
    \ max(numbers)\n", "    if len(numbers) < 2:\n        return None, None\n    min_diff\
    \ = numbers[-1] - numbers[0]\n    max_diff = numbers[-1] - numbers[0]\n    \n\
    \    for i in range(1, len(numbers)):\n        current_diff = numbers[i] - numbers[i\
    \ - 1]\n        if min_diff > current_diff:\n            min_diff = current_diff\n\
    \        if max_diff < current_diff:\n            max_diff = current_diff\n  \
    \  \n    smallest_diff = numbers[0] - numbers[len(numbers) - 1]\n    if min_diff\
    \ > smallest_diff:\n        return numbers[0], numbers[len(numbers) - 1]\n   \
    \ elif max_diff < smallest_diff:\n        return numbers[len(numbers) - 1], numbers[0]\n\
    \    else:\n        return smallest_diff, numbers[0]\n    ", "    numbers.sort()\n\
    \    if len(numbers) < 2:\n        raise AssertionError(\"At least two items are\
    \ required\")\n\n    return numbers[1], numbers[0]\n\n", "    minimum = minimum_value\
    \ = None\n\n    if len(numbers) < 2:\n        return None, None\n\n    for number\
    \ in numbers:\n        if minimum is None:\n            minimum = number\n   \
    \         minimum_value = number\n        elif minimum > number:\n           \
    \ minimum = number\n            minimum_value = number\n\n    return minimum_value,\
    \ minimum_value\n\n", "    smallest_diff = 10.0\n    smallest_diff = min(numbers)\n\
    \    smallest_index = numbers.index(smallest_diff)\n    second_smallest_diff =\
    \ 10.0\n    second_smallest_diff = min(numbers)\n    second_smallest_index = numbers.index(second_smallest_diff)\n\
    \    if abs(second_smallest_index - smallest_index) == 1:\n        return second_smallest_diff,\
    \ smallest_diff\n    elif second_smallest_index - smallest_index > 1:\n      \
    \  return second_smallest_diff, second_smallest_diff\n    else:\n        return\
    \ smallest_diff, second_smallest_diff\n", "    smallest_difference = numbers[0]\n\
    \    second_smallest_difference = numbers[1]\n    for number in numbers:\n   \
    \     difference = abs(number - smallest_difference)\n        if difference <\
    \ second_smallest_difference:\n            second_smallest_difference = difference\n\
    \        elif difference == second_smallest_difference:\n            if number\
    \ < smallest_difference:\n                second_smallest_difference = difference\n\
    \                smallest_difference = number\n            elif number > smallest_difference:\n\
    \                smallest_difference = number\n    return smallest_difference,\
    \ second_smallest_difference\n", "    elements = sorted(numbers)\n    return elements[0],\
    \ elements[1]\n", "    \n    if len(numbers) < 2:\n        raise ValueError(\"\
    The provided list must have at least two elements\")\n    \n    smallest_number\
    \ = numbers[0]\n    largest_number = numbers[-1]\n    \n    smallest_closest =\
    \ largest_number\n    largest_closest = smallest_number\n    \n    for element\
    \ in numbers[1:]:\n        diff = abs(element - smallest_number)\n        if diff\
    \ < smallest_closest:\n            smallest_closest = element\n        elif diff\
    \ > largest_closest:\n            largest_closest = element\n    \n    return\
    \ smallest_closest, largest_closest\n", "    smallest_number = min(numbers)\n\
    \    biggest_number = max(numbers)\n    return smallest_number, biggest_number\n",
  "    sorted_numbers = sorted(numbers)\n    closest_number = sorted_numbers[0]\n\
    \    closest_number_other = sorted_numbers[1]\n    return closest_number, closest_number_other\n\
    \n", "    if len(numbers) < 2:\n        raise ValueError(f\"list too small, min\
    \ length is 2, was given {len(numbers)} numbers\")\n\n    min_diff = None\n  \
    \  for num in numbers:\n        diff = (num - numbers[0])**2\n        if min_diff\
    \ is None:\n            min_diff = diff\n        elif diff < min_diff:\n     \
    \       min_diff = diff\n            closest = num\n    return (closest, numbers[0])\n\
    \n", "    smallest_difference = float('+inf')\n    largest_difference = float('-inf')\n\
    \    closest_numbers: List[float] = []\n    \n    sorted_numbers = numbers.copy()\n\
    \    sorted_numbers.sort()\n    \n    smallest_number = sorted_numbers[0]\n  \
    \  largest_number = sorted_numbers[-1]\n    \n    smallest_difference = largest_difference\
    \ - smallest_difference\n    \n    for number in sorted_numbers:\n        difference\
    \ = number - smallest_number\n        \n        if difference < smallest_difference:\n\
    \            smallest_difference = difference\n            closest_numbers = [smallest_number]\n\
    \            smallest_number = number\n        elif difference > largest_difference:\n\
    \            largest_difference = difference\n            closest_numbers = [largest_number]\n\
    \            largest_number = number\n        else:\n            closest_numbers.append(number)\n\
    \    \n    return smallest_number, largest_number\n\n", "    numbers = list(sorted(numbers))\n\
    \    half = len(numbers) // 2\n    \n    if half == 0:\n        return numbers[0],\
    \ numbers[-1]\n    \n    midpoint1 = numbers[half]\n    midpoint2 = numbers[half-1]\n\
    \    \n    if midpoint1 > midpoint2:\n        numbers, midpoint1, midpoint2 =\
    \ numbers[:half], midpoint2, midpoint1\n    \n    if midpoint1 > midpoint2:\n\
    \        numbers, midpoint1, midpoint2 = numbers[:half], midpoint1, midpoint2\n\
    \    \n    if midpoint1 < midpoint2:\n        numbers, midpoint1, midpoint2 =\
    \ numbers[:half], midpoint1, midpoint2\n    \n    return numbers[half], numbers[half-1]\n\
    \    ", "    differences = []\n    for i in range(len(numbers) - 1):\n       \
    \ differences.append(abs(numbers[i] - numbers[i + 1]))\n\n    closest_numbers\
    \ = [numbers[0]]\n    closest_difference = differences[0]\n    for d in differences[1:]:\n\
    \        if d < closest_difference:\n            closest_numbers.append(closest_numbers[-1])\n\
    \            closest_difference = d\n        else:\n            closest_difference\
    \ = closest_difference\n            closest_numbers.append(closest_numbers[-1])\n\
    \n    return closest_numbers[0], closest_numbers[-1]\n", "    return min(numbers,\
    \ key=lambda n: abs(n - numbers[0])), max(numbers, key=lambda n: abs(n - numbers[0]))\n",
  "    if len(numbers) < 2:\n        raise ValueError(\"find_closest_elements requires\
    \ at least one number\")\n    else:\n        smallest = min(numbers)\n       \
    \ largest = max(numbers)\n        return smallest, largest\n", "    lowest_value\
    \ = numbers[0]\n    highest_value = numbers[0]\n    for value in numbers:\n  \
    \      if value < lowest_value:\n            lowest_value = value\n        elif\
    \ value > highest_value:\n            highest_value = value\n    return (lowest_value,\
    \ highest_value)\n", "    if not numbers:\n        raise ValueError(f'Must pass\
    \ at least one number for searching.')\n    if len(numbers) == 1:\n        return\
    \ numbers[0], numbers[0]\n    numbers = sorted(numbers)\n    closest_index = bisect.bisect_right(numbers,\
    \ numbers[0])\n    return numbers[closest_index], numbers[closest_index - 1]\n",
  "    if len(numbers) < 2:\n        raise ValueError('Invalid number of numbers')\n\
    \n    smallest_num = numbers[0]\n    biggest_num = numbers[0]\n\n    for num in\
    \ numbers[1:]:\n        if num > biggest_num:\n            biggest_num = num\n\
    \        elif num < smallest_num:\n            smallest_num = num\n        else:\n\
    \            continue\n\n    return (smallest_num, biggest_num)\n", "    smaller,\
    \ larger = numbers[0], numbers[1]\n    for num in numbers[2:]:\n        if abs(num\
    \ - smaller) < abs(num - larger):\n            smaller = num\n        else:\n\
    \            larger = num\n    return smaller, larger\n\n", "    min_dist = float(\"\
    inf\")\n    min_index = -1\n    for index, number in enumerate(numbers):\n   \
    \     dist = abs(number - numbers[index])\n        if dist < min_dist:\n     \
    \       min_dist = dist\n            min_index = index\n    return (numbers[min_index],\
    \ numbers[min_index+1])\n", "    assert len(numbers) >= 2\n    assert len(numbers)\
    \ <= 100\n    numbers.sort()\n    smallest = numbers[0]\n    biggest = numbers[-1]\n\
    \    return smallest, biggest\n", "    # Find the two elements that are closest\
    \ to each other and in the correct order (smaller number, larger number)\n   \
    \ if len(numbers) < 2:\n        raise ValueError(\"find_closest_elements requires\
    \ a list of length at least two\")\n    low = min(numbers)\n    high = max(numbers)\n\
    \    closest_pair = (0, 0)\n    for n in range(1, len(numbers)):\n        delta\
    \ = abs(numbers[n] - low)\n        if delta < closest_pair[0]:\n            closest_pair\
    \ = (delta, n)\n    return closest_pair\n\n", "    if len(numbers) < 2:\n    \
    \    raise ValueError(f\"Supplied list less than two numbers, {len(numbers)} numbers\
    \ found\")\n\n    numbers = sorted(numbers)\n\n    if numbers[0] == numbers[-1]:\n\
    \        return (numbers[0], numbers[0])\n\n    midpoint = numbers[(len(numbers)\
    \ / 2)]\n    left_closest = numbers[0]\n    right_closest = numbers[0]\n\n   \
    \ for num in numbers[1:]:\n        if num > midpoint:\n            if right_closest\
    \ == midpoint:\n                right_closest = num\n            else:\n     \
    \           right_closest = midpoint\n        elif num < midpoint:\n         \
    \   if left_closest == midpoint:\n                left_closest = num\n       \
    \     else:\n                left_closest = midpoint\n\n    return (left_closest,\
    \ right_closest)\n", "    numbers.sort()\n    closest_values = []\n    smallest\
    \ = numbers[0]\n    largest = numbers[0]\n    smallest_element = numbers[0]\n\
    \    largest_element = numbers[0]\n    smallest_difference = float(\"inf\")\n\
    \    largest_difference = float(\"-inf\")\n    for element in numbers:\n     \
    \   difference = element - smallest_element\n        if difference < smallest_difference:\n\
    \            smallest_difference = difference\n            smallest_element =\
    \ element\n        difference = element - largest_element\n        if difference\
    \ > largest_difference:\n            largest_difference = difference\n       \
    \     largest_element = element\n    closest_values = [smallest_element, largest_element]\n\
    \    return tuple(closest_values)\n", "    assert len(numbers) >= 2\n    closest_pairs\
    \ = sorted(zip(numbers, numbers[1:]), key=lambda x:x[0]-x[1])\n    return closest_pairs[0]\n",
  "    if not numbers:\n        raise ValueError('The supplied list of numbers is\
    \ empty')\n    if len(numbers) < 2:\n        raise ValueError('The supplied list\
    \ of numbers is too short')\n    first = numbers[0]\n    second = numbers[1]\n\
    \    diff = float('Inf')\n    for x in numbers[2:]:\n        if abs(x - first)\
    \ < diff:\n            diff = abs(x - first)\n            first = x\n        elif\
    \ abs(x - second) < diff:\n            diff = abs(x - second)\n            second\
    \ = x\n    return (first, second)\n\n", "    closest_numbers = numbers[:]\n  \
    \  closest_numbers.sort()\n\n    # Find the first two numbers that differ by at\
    \ most one\n    closest_differ = closest_numbers[0] - closest_numbers[1]\n   \
    \ if closest_differ > 1:\n        closest_numbers.pop(1)\n        closest_numbers.insert(0,\
    \ closest_numbers[0])\n\n    return tuple(closest_numbers)\n", "    smallest =\
    \ numbers[0]\n    largest = numbers[0]\n\n    for n in numbers[1:]:\n        if\
    \ abs(smallest) > abs(n):\n            smallest = n\n        elif abs(largest)\
    \ > abs(n):\n            largest = n\n\n    return smallest, largest\n", "   \
    \ \n    # TODO: Write code to accomplish this task\n    \n    return None, None\n",
  "    min_number = min(numbers)\n    max_number = max(numbers)\n\n    closest_numbers\
    \ = [min_number, max_number]\n    closest_numbers = sorted(closest_numbers)\n\n\
    \    return closest_numbers\n", "    return min(numbers), max(numbers)\n\n", " \
    \   smallest = numbers[0]\n    largest = numbers[0]\n    for number in numbers:\n\
    \        if number < smallest:\n            smallest = number\n        if number\
    \ > largest:\n            largest = number\n    return (smallest, largest)\n\n",
  "    if len(numbers) < 2:\n        raise ValueError(f\"Expected a list of length\
    \ >= 2, got {numbers}\")\n\n    if numbers[0] > numbers[1]:\n        return numbers[0],\
    \ numbers[1]\n\n    closest_index = bisect.bisect_right(numbers, numbers[0])\n\
    \    if closest_index == 0:\n        return numbers[0], numbers[1]\n    if closest_index\
    \ == 1:\n        return numbers[0], numbers[closest_index]\n\n    closest_left\
    \ = numbers[closest_index-1]\n    closest_right = numbers[closest_index]\n\n \
    \   closest = min(closest_left, closest_right)\n\n    return numbers[closest_index],\
    \ closest\n", "    if len(numbers) < 2:\n        return numbers[0], numbers[0]\n\
    \    smaller = numbers[0]\n    bigger = numbers[0]\n    for num in numbers[1:]:\n\
    \        if abs(num - smaller) < abs(num - bigger) and num > smaller:\n      \
    \      smaller = num\n        elif abs(num - smaller) > abs(num - bigger) and\
    \ num > bigger:\n            bigger = num\n    return smaller, bigger\n\n", " \
    \   assert len(numbers) > 0\n    sorted_numbers = sorted(numbers)\n    closest\
    \ = sorted_numbers[0]\n    closest2 = sorted_numbers[1]\n    for i in range(2,\
    \ len(sorted_numbers)):\n        if abs(sorted_numbers[i] - closest) < abs(sorted_numbers[i]\
    \ - closest2):\n            closest = sorted_numbers[i]\n            closest2\
    \ = sorted_numbers[i - 1]\n    return closest, closest2\n", "    smallest_difference\
    \ = 9999999\n    smallest_value = None\n    biggest_difference = sys.float_info.max\n\
    \    biggest_value = None\n\n    for index, number in enumerate(numbers):\n  \
    \      difference = abs(smallest_difference - (number - smallest_value))\n   \
    \     if smallest_difference == 9999999 and (difference < biggest_difference):\n\
    \            biggest_difference = difference\n            biggest_value = number\n\
    \n        if smallest_difference > number:\n            smallest_difference =\
    \ number\n            smallest_value = number\n\n    return smallest_value, biggest_value\n\
    \n", "    return min(numbers), max(numbers)\n", "    smallest = numbers[0]\n \
    \   largest = numbers[0]\n    for n in numbers:\n        if n < smallest:\n  \
    \          smallest = n\n        if n > largest:\n            largest = n\n  \
    \  return (smallest, largest)\n", "    if len(numbers) < 2:\n        raise IndexError(\"\
    List must have at least two elements to compare\")\n\n    minimum = numbers[0]\n\
    \    maximum = numbers[0]\n    for number in numbers[1:]:\n        if number <\
    \ minimum:\n            minimum = number\n        elif number > maximum:\n   \
    \         maximum = number\n\n    return minimum, maximum\n\n", "    if len(numbers)\
    \ <= 1:\n        return numbers[0], numbers[0]\n\n    # sort by distance\n   \
    \ numbers.sort()\n\n    # find two closest numbers, return both in order\n   \
    \ closest_1, closest_2 = numbers[0], numbers[1]\n    for num in numbers[2:]:\n\
    \        if abs(num - closest_1) > abs(num - closest_2):\n            closest_1\
    \ = num\n        else:\n            closest_2 = num\n\n    return closest_1, closest_2\n",
  "    return min(numbers, key=lambda n: abs(n - numbers[0]))\n\n", "    \n    # Using\
    \ list comprehension here\n    closest_to_left = [n for n in numbers if abs(n)\
    \ < abs(numbers[0])]\n    closest_to_right = [n for n in numbers if abs(n) < abs(numbers[-1])]\n\
    \    \n    if closest_to_left and closest_to_right:\n        return min(closest_to_left,\
    \ closest_to_right), max(closest_to_left, closest_to_right)\n    elif closest_to_left:\n\
    \        return closest_to_left[0], closest_to_left[0]\n    elif closest_to_right:\n\
    \        return closest_to_right[0], closest_to_right[0]\n    else:\n        raise\
    \ ValueError\n    ", "    if len(numbers) < 2:\n        raise IndexError\n   \
    \ sorted_numbers = sorted(numbers)\n    closest_numbers = [sorted_numbers[0]]\n\
    \    for number in sorted_numbers[1:]:\n        diff1 = sorted_numbers[0] - number\n\
    \        diff2 = sorted_numbers[-1] - number\n        if diff1 < diff2:\n    \
    \        closest_numbers.append(number)\n        else:\n            closest_numbers.append(sorted_numbers[-1])\n\
    \    return tuple(closest_numbers)\n\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError(\"At least two numbers are required to calculate the distance.\"\
    )\n    else:\n        smallest_distance = numbers[0]\n        biggest_distance\
    \ = numbers[0]\n        closest_elements = [numbers[0]]\n        for i in range(1,\
    \ len(numbers)):\n            current_distance = abs(numbers[i] - numbers[0])\n\
    \            if current_distance < smallest_distance:\n                smallest_distance\
    \ = current_distance\n                closest_elements = [numbers[i]]\n      \
    \      elif current_distance > biggest_distance:\n                biggest_distance\
    \ = current_distance\n                closest_elements = [numbers[0]]\n      \
    \      elif current_distance == smallest_distance:\n                closest_elements.append(numbers[i])\n\
    \            elif current_distance == biggest_distance:\n                closest_elements.append(numbers[0])\n\
    \        return smallest_distance, biggest_distance\n</code>\n<|/ a |>\n<| c |>\n\
    The \"if current_distance == smallest_distance\" lines should be changed to \"\
    if current_distance == smallest_distance or current_distance == biggest_distance\"\
    , and also \"closest_elements.append(numbers[0])\" should be changed to \"closest_elements.append(numbers[i\
    \ - 1])\"\n<|/ c |>\n<| c |>\nGood catch, I edited my answer, thanks.\n<|/ c |>\n\
    <| a dscore=2 tags=algorithm,python,performance |>\nI came up with this solution:\n\
    <code>", "    numbers.sort()\n    nearest_one = numbers[0]\n    nearest_two =\
    \ numbers[1]\n    for number in numbers[2:]:\n        if abs(nearest_one) > abs(number):\n\
    \            nearest_two = nearest_one\n            nearest_one = number\n   \
    \     elif abs(nearest_two) > abs(number):\n            nearest_two = number\n\
    \        elif number == nearest_two:\n            nearest_one += 1\n    return\
    \ nearest_one, nearest_two\n", "    if len(numbers) < 2:\n        return None\n\
    \    numbers.sort()\n    half = len(numbers)//2\n    return numbers[half], numbers[-half]\n",
  "    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two\
    \ items\")\n\n    sorted_numbers = sorted(numbers)\n    closest = sorted_numbers[0]\n\
    \    second_closest = sorted_numbers[1]\n\n    return closest, second_closest\n",
  "    sorted_list = sorted(numbers)\n    closest_pair = [sorted_list[0], sorted_list[1]]\n\
    \    second_closest = [sorted_list[1], sorted_list[0]]\n    return closest_pair,\
    \ second_closest\n", "    if len(numbers) <= 1:\n        # No element can be closer\
    \ to itself\n        return numbers[0], numbers[0]\n    else:\n        closest_to_one\
    \ = numbers[0]\n        closest_to_two = numbers[1]\n        if closest_to_one\
    \ < closest_to_two:\n            return closest_to_one, closest_to_two\n     \
    \   else:\n            return closest_to_two, closest_to_one\n", "    assert len(numbers)\
    \ >= 2, \"At least two values must be given\"\n    return min(numbers), max(numbers)\n",
  "    if len(numbers) < 2:\n        raise ValueError('List must have at least two\
    \ elements before it can be sorted')\n\n    numbers.sort()\n\n    if numbers[1]\
    \ - numbers[0] == 0.0:\n        return numbers[0], numbers[0]\n\n    midpoint\
    \ = numbers[int(len(numbers)/2)]\n\n    closest = None\n    diff_from_midpoint\
    \ = 0.0\n\n    for index, val in enumerate(numbers):\n        if val == midpoint:\n\
    \            closest = (index, val)\n            diff_from_midpoint = val - midpoint\n\
    \        elif abs(val - midpoint) < diff_from_midpoint:\n            diff_from_midpoint\
    \ = abs(val - midpoint)\n            closest = (index, val)\n\n    return closest\n\
    \n", "    closest_pair = (min(numbers), max(numbers))\n    closest_pair_index\
    \ = numbers.index(closest_pair[0])\n    if closest_pair_index + 1 < len(numbers):\n\
    \        closest_pair_next_index = numbers.index(closest_pair[1], closest_pair_index\
    \ + 1)\n        if closest_pair_next_index < len(numbers):\n            closest_pair\
    \ = (numbers[closest_pair_index], numbers[closest_pair_next_index])\n    return\
    \ closest_pair\n\n", "    if len(numbers) < 2:\n        raise ValueError('At least\
    \ two numbers required')\n    numbers.sort()\n    closest = (numbers[0], numbers[1])\n\
    \    i = 0\n    j = 1\n    while i < len(numbers) - 1 and j < len(numbers) - 1\
    \ and abs(numbers[i] - numbers[j]) < closest[0]:\n        closest = (numbers[i],\
    \ numbers[j])\n        if closest[0] < numbers[0]:\n            i += 1\n     \
    \   if closest[0] > numbers[-1]:\n            j += 1\n    return closest\n</code>\n\
    <|/ a dscore=1 tags=python,loops,functional-programming |>\n<| a dscore=0 |>\n\
    This code solves your problem:\n<code>\nimport numpy as np\n", "    assert len(numbers)\
    \ >= 2, \"Cannot find closest pair. Numbers must have length >= 2.\"\n    assert\
    \ all(n > 0.0 for n in numbers), \"Cannot find closest pair. Numbers must have\
    \ length > 0.\"\n\n    # Find largest and smallest numbers in list\n    largest_number\
    \ = max(numbers)\n    smallest_number = min(numbers)\n\n    # Determine which\
    \ number in the list the larger number must be closer to\n    larger_number_index\
    \ = numbers.index(largest_number)\n    if largest_number == smallest_number:\n\
    \        # Find the second largest number and compare it with largest number\n\
    \        second_larger_number = max(numbers)\n        second_larger_number_index\
    \ = numbers.index(second_larger_number)\n        distance_between_numbers = largest_number\
    \ - second_larger_number\n        closest_numbers_2 = second_larger_number_index\n\
    \    else:\n        # Find the second largest number and compare it with smallest\
    \ number\n        second_smaller_number = min(numbers)\n        second_smaller_number_index\
    \ = numbers.index(second_smaller_number)\n        distance_between_numbers = second_smaller_number\
    \ - smallest_number\n        closest_numbers_2 = second_smaller_number_index\n\
    \n    # Find the third largest number and compare it with second smallest number\n\
    \    if second_smaller_number != largest_number:\n        third_smaller_number\
    \ = min(numbers)\n        third_smaller_number_index = numbers.index(third_smaller_number)\n\
    \        distance_between_numbers = second_smaller_number - third_smaller_number\n\
    \        closest_numbers_3 = third_smaller_number_index\n    else:\n        third_larger_number\
    \ = max(numbers)\n        third_larger_number_index = numbers.index(third_larger_number)\n\
    \        distance_between_numbers = largest_number - third_larger_number\n   \
    \     closest_numbers_3 = third_larger_number_index\n\n    # Return the closest\
    \ pair to the left and right numbers\n    return numbers[closest_numbers_3], numbers[closest_numbers_2]\n\
    \n", "    return min(numbers), max(numbers)\n", "    if len(numbers) < 2:\n  \
    \      raise ValueError(\"Supplied list must have at least 2 numbers\")\n    differences\
    \ = []\n    differences.append(numbers[1] - numbers[0])\n    differences.append(numbers[1]\
    \ - numbers[2])\n    if differences[0] < 0 and differences[1] > 0:\n        return\
    \ numbers[0], numbers[1]\n    elif differences[0] > 0 and differences[1] < 0:\n\
    \        return numbers[2], numbers[1]\n    else:\n        return numbers[0],\
    \ numbers[2]\n", "    smallest = numbers[0]\n    largest = numbers[0]\n    for\
    \ number in numbers:\n        if number < smallest:\n            smallest = number\n\
    \        elif number > largest:\n            largest = number\n    return smallest,\
    \ largest\n\n", "    smallest_distance = None\n    biggest_distance = None\n \
    \   for element in numbers:\n        if smallest_distance is None:\n         \
    \   smallest_distance = element\n            biggest_distance = element\n    \
    \    elif element < smallest_distance:\n            smallest_distance = element\n\
    \        elif element > biggest_distance:\n            biggest_distance = element\n\
    \    return smallest_distance, biggest_distance\n", "    if len(numbers) < 2:\n\
    \        raise IndexError(\"Can't find nearest elements to less than two elements\"\
    )\n\n    midpoint = (numbers[0] + numbers[-1]) / 2\n    smaller_number = numbers[0]\n\
    \    bigger_number = numbers[0]\n    for x in numbers:\n        if abs(x - midpoint)\
    \ < abs(smaller_number - midpoint):\n            smaller_number = x\n        elif\
    \ abs(x - midpoint) < abs(bigger_number - midpoint):\n            bigger_number\
    \ = x\n\n    return (smaller_number, bigger_number)\n\n", "    numbers = list(sorted(numbers))\n\
    \    smallest = numbers[0]\n    largest = numbers[-1]\n    if smallest == largest:\n\
    \        return smallest, largest\n    else:\n        i = -1\n        for j in\
    \ range(1, len(numbers)):\n            if numbers[j] - smallest > largest-numbers[j]:\n\
    \                largest = numbers[j]\n            elif numbers[j] - smallest\
    \ < largest-numbers[j]:\n                smallest = numbers[j]\n            i\
    \ += 1\n        return smallest, largest\n\n", "    diff1 = abs(numbers[1] - numbers[0])\n\
    \    diff2 = abs(numbers[2] - numbers[0])\n\n    if diff1 < diff2:\n        return\
    \ numbers[1], numbers[0]\n    else:\n        return numbers[0], numbers[1]\n\n",
  "    closest = min(numbers)\n    closest_other = numbers[0]\n    for number in numbers[1:]:\n\
    \        if number < closest:\n            closest = number\n            closest_other\
    \ = number\n        else:\n            break\n    return (closest_other, closest)\n",
  "    # Sort the numbers in ascending order\n    numbers.sort()\n    \n    closest_elements\
    \ = numbers[0], numbers[-1]\n    for n in numbers[1:]:\n        closest_elements\
    \ = min(closest_elements, n)\n    return closest_elements\n", "    smaller = min(numbers)\n\
    \    larger = max(numbers)\n    found = False\n    smallest = None\n    largest\
    \ = None\n    for n in numbers:\n        if found:\n            break\n      \
    \  if n < smaller:\n            if smallest is None:\n                smallest\
    \ = n\n            smallest = n\n        elif n > larger:\n            if largest\
    \ is None:\n                largest = n\n            largest = n\n        found\
    \ = True\n    return smallest, largest\n\n", "    if len(numbers) < 2:\n     \
    \   return (numbers[0], numbers[0])\n\n    numbers.sort()\n    return numbers[0],\
    \ numbers[-1]\n", "    minimum = numbers[0]\n    maximum = numbers[0]\n    for\
    \ i in range(len(numbers)):\n        current = numbers[i]\n        if minimum\
    \ > current:\n            minimum = current\n        if maximum < current:\n \
    \           maximum = current\n    return minimum, maximum\n", "    if not numbers\
    \ or len(numbers) < 2:\n        return None, None\n\n    numbers.sort()\n    return\
    \ numbers[numbers.index(min(numbers))], numbers[numbers.index(max(numbers))]\n",
  "    assert len(numbers) >= 2\n    closest_elements = (numbers[0] + numbers[1])/2.0,\
    \ (numbers[0] + numbers[1])/2.0\n    for number in numbers[2:]:\n        closest_elements\
    \ = (numbers[0] + number, numbers[1] + number)/2.0\n    return closest_elements\n",
  "    smallest_number = min(numbers)\n    greatest_number = max(numbers)\n    if\
    \ smallest_number == greatest_number:\n        return (smallest_number, greatest_number)\n\
    \    else:\n        midpoint = smallest_number+(greatest_number-smallest_number)/2\n\
    \        if midpoint == greatest_number:\n            return (greatest_number,\
    \ smallest_number)\n        else:\n            return (midpoint, greatest_number)\n",
  "    if len(numbers) < 2:\n        raise ValueError(\"must have at least two elements\"\
    )\n\n    smallest = numbers[0]\n    largest = numbers[0]\n\n    for num in numbers:\n\
    \        if abs(num - largest) < abs(num - smallest):\n            smallest =\
    \ num\n        elif abs(num - largest) > abs(num - smallest):\n            largest\
    \ = num\n\n    return (smallest, largest)\n", "    assert len(numbers) >= 2\n\
    \    smallest_diff = float('inf')\n    closest_elements = (numbers[0], numbers[1])\n\
    \    for num in numbers[2:]:\n        diff = (num - closest_elements[1]) ** 2\n\
    \        if diff < smallest_diff:\n            smallest_diff = diff\n        \
    \    closest_elements = (num, num)\n    return closest_elements\n", "    \n  \
    \  return min(numbers), max(numbers)\n", "    # Add 0 to the list and make it\
    \ a list with two elements, then sort them by distance and return the two numbers\n\
    \    # in order\n    numbers += [0]\n    numbers.sort()\n    return numbers[-2],\
    \ numbers[-1]\n", "    smallest_number = numbers[0]\n    biggest_number = numbers[0]\n\
    \    for number in numbers:\n        if number < smallest_number:\n          \
    \  smallest_number = number\n        if number > biggest_number:\n           \
    \ biggest_number = number\n    return (smallest_number, biggest_number)\n\n",
  "    # your code here\n    min_diff = min(numbers)\n    min_element = numbers[0]\n\
    \    for element in numbers[1:]:\n        diff = abs(element - min_element)\n\
    \        if diff < min_diff:\n            min_diff = diff\n            min_element\
    \ = element\n\n    return min_element, min_diff\n\n", "    smallest = min(numbers)\n\
    \    largest = max(numbers)\n    return smallest, largest\n", "    if len(numbers)\
    \ < 2:\n        return numbers[0], numbers[0]\n    numbers.sort()\n    return\
    \ numbers[0], numbers[1]\n", "    return min(numbers), max(numbers)\n", "    if\
    \ len(numbers) < 2:\n        raise Exception(\"You must supply a list of at least\
    \ two numbers\")\n\n    smallest = min(numbers)\n    largest = max(numbers)\n\
    \    for x in numbers:\n        if abs(x - smallest) < abs(x - largest):\n   \
    \         return (x, smallest)\n        else:\n            return (x, largest)\n\
    \n", "    assert len(numbers) > 1\n    closest_smaller = numbers[0]\n    closest_larger\
    \ = numbers[0]\n    for number in numbers[1:]:\n        if number < closest_smaller:\n\
    \            closest_smaller = number\n        elif number > closest_larger:\n\
    \            closest_larger = number\n    return closest_smaller, closest_larger\n",
  "    smallest = numbers[0]\n    largest = numbers[0]\n    smallest_index = -1\n\
    \    largest_index = -1\n\n    for i in range(len(numbers)):\n        if numbers[i]\
    \ > largest:\n            largest = numbers[i]\n            largest_index = i\n\
    \        if numbers[i] < smallest:\n            smallest = numbers[i]\n      \
    \      smallest_index = i\n\n    return smallest, largest, smallest_index, largest_index\n",
  "    closest_values = []\n    closest_values.append(min(numbers))\n    closest_values.append(max(numbers))\n\
    \    return tuple(closest_values)\n", "    largest = numbers[0]\n    smallest\
    \ = numbers[0]\n    for number in numbers[1:]:\n        if number > largest:\n\
    \            largest = number\n        elif number < smallest:\n            smallest\
    \ = number\n    return smallest, largest\n", "    diff1 = numbers[1] - numbers[0]\n\
    \    diff2 = numbers[2] - numbers[1]\n    diff3 = numbers[2] - numbers[0]\n\n\
    \    if diff1 == 0.0 and diff2 == 0.0 and diff3 == 0.0:\n        return (numbers[1],\
    \ numbers[2])\n    elif diff1 > diff2 and diff1 > diff3:\n        return (numbers[1],\
    \ numbers[0])\n    elif diff2 > diff3:\n        return (numbers[2], numbers[1])\n\
    \    else:\n        return (numbers[2], numbers[0])\n", "    if len(numbers) <=\
    \ 1:\n        raise ValueError(\"Number of elements to be closest must be greater\
    \ than one\")\n    numbers.sort()\n    return numbers[len(numbers) - 1], numbers[0]\n",
  "    numbers.sort() # sort the list in order from small to big\n    closest = numbers[0]\
    \ # initialize closest to the first element\n    second_closest = numbers[1] #\
    \ initialize the second closest to the second element\n    # loop through remaining\
    \ elements looking for the closest two and setting them if they match\n    for\
    \ number in numbers[2:]:\n        if abs(number - closest) < abs(closest - second_closest):\n\
    \            second_closest = number\n        closest = number\n    # return the\
    \ tuple\n    return closest, second_closest\n</cell>\n<cell>\nfind_closest_elements([1,2,3,4,5,6])\n\
    </cell>\n<text>\nWe will use these two functions to help us find the two closest\
    \ points in our data.\n\n\n</text>\n<cell>", "    minimum = numbers[0]\n    maximum\
    \ = numbers[0]\n    for n in numbers[1:]:\n        if n > maximum:\n         \
    \   maximum = n\n        elif n < minimum:\n            minimum = n\n    return\
    \ minimum, maximum\n\n", "    closest_number = None\n    closest_square = None\n\
    \    closest_square_root = None\n    for number in numbers:\n        if closest_number\
    \ is not None:\n            distance = math.sqrt(number ** 2 + closest_square\
    \ ** 2)\n            if distance < closest_square_root:\n                closest_number\
    \ = number\n                closest_square = closest_number * closest_number\n\
    \                closest_square_root = distance\n        else:\n            closest_number\
    \ = number\n            closest_square = closest_number * closest_number\n   \
    \         closest_square_root = math.sqrt(number ** 2 + closest_square ** 2)\n\
    \    return (closest_number, closest_square)\n", "    if len(numbers) < 2:\n \
    \       raise ValueError('A list must have at least two elements.')\n\n    # find\
    \ closest to the first element\n    closest_number = numbers[0]\n    closest_diff,\
    \ closest_idx = None, 0\n    for i in range(len(numbers)):\n        diff = abs(numbers[i]\
    \ - closest_number)\n        if diff < closest_diff:\n            closest_diff\
    \ = diff\n            closest_idx = i\n    # add one to the index\n    closest_idx\
    \ += 1\n\n    # find closest to the second element\n    closest_diff = float('inf')\n\
    \    closest_number = numbers[closest_idx]\n    closest_idx, closest_idx2 = None,\
    \ None\n    for i in range(len(numbers)):\n        diff = abs(numbers[i] - closest_number)\n\
    \        if diff < closest_diff:\n            closest_diff = diff\n          \
    \  closest_idx = i\n        if diff < closest_diff:\n            closest_diff\
    \ = diff\n            closest_idx2 = i\n\n    return closest_number, numbers[closest_idx]\n",
  "    \n    # Sort numbers to find the smallest and largest numbers\n    numbers.sort()\n\
    \    \n    # Select two numbers which are closest to eachother\n    smallest_number\
    \ = numbers[0]\n    largest_number = numbers[-1]\n    \n    # If the numbers are\
    \ close enough return both\n    if abs(smallest_number - largest_number) < 1.0E-8:\n\
    \        return smallest_number, largest_number\n    \n    # If the largest number\
    \ is not the smallest number then we will have to switch them\n    if largest_number\
    \ < smallest_number:\n        largest_number, smallest_number = smallest_number,\
    \ largest_number\n    \n    # Return the smallest and largest numbers\n    return\
    \ smallest_number, largest_number\n</cell>\n<cell>\nimport numpy as np\nimport\
    \ matplotlib.pyplot as plt\n%matplotlib inline\n</cell>\n<cell>", "    closest_to_larger\
    \ = min(numbers)\n    closest_to_smaller = max(numbers)\n\n    return closest_to_smaller,\
    \ closest_to_larger\n", "    # TODO use min and max instead of sort\n    return\
    \ numbers[1], numbers[0]\n", "    smallest_number = min(numbers)\n    closest_number\
    \ = numbers[0]\n    largest_number = max(numbers)\n    if closest_number == smallest_number:\n\
    \        return (closest_number, smallest_number)\n    if closest_number == largest_number:\n\
    \        return (closest_number, largest_number)\n    for number in numbers:\n\
    \        if closest_number == number:\n            continue\n        if abs(number\
    \ - smallest_number) < abs(closest_number - smallest_number):\n            closest_number\
    \ = number\n        elif abs(number - largest_number) < abs(closest_number - largest_number):\n\
    \            closest_number = number\n    return (closest_number, closest_number)\n\
    \n", "    \n    # sort numbers by absolute value\n    sorted_numbers = sorted(numbers)\n\
    \n    # find the midpoint of the list\n    midpoint = sorted_numbers[len(sorted_numbers)\
    \ // 2]\n\n    # find two closest numbers by binary search\n    lower_bound =\
    \ midpoint - abs(sorted_numbers[len(sorted_numbers) // 2 - 1]) * 0.5\n    upper_bound\
    \ = midpoint + abs(sorted_numbers[len(sorted_numbers) // 2 - 1]) * 0.5\n\n   \
    \ # find the two closest numbers\n    if lower_bound < upper_bound:\n        return\
    \ (sorted_numbers[lower_bound], sorted_numbers[upper_bound])\n\n    return (sorted_numbers[lower_bound],\
    \ sorted_numbers[0])\n\n", "    numbers.sort()\n    \n    if len(numbers) < 2:\n\
    \        raise RuntimeError(\"List must have at least two elements\")\n    \n\
    \    \n    \n    return numbers[0::2], numbers[1::2]\n", "    smallest = None\n\
    \    largest = None\n    for num in numbers:\n        if smallest is None:\n \
    \           smallest = num\n        elif num < smallest:\n            smallest\
    \ = num\n        if largest is None:\n            largest = num\n        elif\
    \ num > largest:\n            largest = num\n    return (smallest, largest)\n\n",
  "    assert len(numbers) >= 2\n    closest = sorted(numbers)\n    closest_distance\
    \ = closest - numbers\n    if closest_distance:\n        closest_distance_index\
    \ = closest_distance.index(min(closest_distance))\n        return (numbers[closest_distance_index],\
    \ numbers[closest_distance_index+1])\n    return numbers[0], numbers[-1]\n", " \
    \   sorted_numbers = sorted(numbers)\n    if len(sorted_numbers) < 2:\n      \
    \  raise ValueError(\"At least two numbers are required\")\n    smallest = sorted_numbers[0]\n\
    \    largest = sorted_numbers[-1]\n    return smallest, largest\n\n", "    if\
    \ len(numbers) < 2:\n        raise ValueError(\"numbers must be a list of length\
    \ at least two\")\n    closest1 = numbers[0]\n    closest2 = numbers[1]\n\n  \
    \  for n in range(1, len(numbers)):\n        diff = abs(numbers[n] - closest2)\n\
    \        if diff < closest1:\n            closest1 = diff\n            closest2\
    \ = numbers[n]\n        elif diff == closest1:\n            closest2 = numbers[n]\n\
    \    if closest1 < closest2:\n        closest1, closest2 = closest2, closest1\n\
    \    return closest1, closest2\n", "    smallest_diff = 0\n    closest_element\
    \ = None\n    closest_element_2 = None\n    for num in numbers:\n        diff\
    \ = abs(num - closest_element_2)\n        if smallest_diff == 0 or smallest_diff\
    \ > diff:\n            smallest_diff = diff\n            closest_element = num\n\
    \            closest_element_2 = closest_element\n        else:\n            if\
    \ diff < smallest_diff:\n                closest_element = num\n    return closest_element,\
    \ closest_element_2\n", "    sorted_numbers = sorted(numbers)\n    smallest_num\
    \ = sorted_numbers[0]\n    largest_num = sorted_numbers[-1]\n    return (smallest_num,\
    \ largest_num)\n", "    if len(numbers) < 2:\n        raise ValueError(\"List\
    \ must have at least 2 elements\")\n    smaller = numbers[0]\n    larger = numbers[1]\n\
    \    for num in numbers[2:]:\n        if abs(num - smaller) < abs(num - larger):\n\
    \            smaller = num\n        else:\n            larger = num\n    return\
    \ smaller, larger\n\n", "    smallest_number: float = numbers[0]\n    larger_number:\
    \ float = numbers[-1]\n    for index in range(1, len(numbers)):\n        candidate:\
    \ float = numbers[index]\n        if candidate <= smallest_number:\n         \
    \   smallest_number = candidate\n        elif candidate > larger_number:\n   \
    \         larger_number = candidate\n    return smallest_number, larger_number\n\
    \n", "    if len(numbers) < 2:\n        raise ValueError('At least two numbers\
    \ are required')\n\n    numbers.sort()\n\n    return numbers[1], numbers[0]\n\n",
  "    # Your code goes here.\n    return numbers[numbers.index(min(numbers))], numbers[numbers.index(max(numbers))]\n",
  "    # Sort the list\n    numbers.sort()\n\n    # Return the nearest two elements\n\
    \    closest_element_1 = numbers[0]\n    closest_element_2 = numbers[0]\n\n  \
    \  for i in range(1, len(numbers)):\n        element = numbers[i]\n        delta\
    \ = (element - closest_element_1) + (element - closest_element_2)\n        if\
    \ delta < 0.0:\n            closest_element_1 = element\n        else:\n     \
    \       closest_element_2 = element\n\n    return closest_element_1, closest_element_2\n\
    \n", "    if numbers[len(numbers) - 1] - numbers[0] < 0.000001:\n        return\
    \ numbers[0], numbers[-1]\n    else:\n        closest_number = min(numbers, key=lambda\
    \ x:abs(x - numbers[0]))\n        other_number = max(numbers, key=lambda x:abs(x\
    \ - numbers[0]))\n        if closest_number == other_number:\n            return\
    \ other_number, closest_number\n        else:\n            return closest_number,\
    \ other_number\n", "    smallest: float = numbers[0]\n    second: float = numbers[1]\n\
    \    for number in numbers[2:]:\n        if abs(number - second) < abs(number\
    \ - smallest):\n            second: float = number\n        elif abs(number -\
    \ smallest) < abs(number - second):\n            smallest: float = number\n  \
    \  return smallest, second\n", "    min_diff = min(abs(numbers[0] - x) for x in\
    \ numbers[1:])\n    closest_elements = (numbers[0], numbers[1])\n    for n in\
    \ range(2, len(numbers)):\n        if min_diff > abs(numbers[n] - closest_elements[0]):\n\
    \            closest_elements = (numbers[n], closest_elements[0])\n        elif\
    \ min_diff > abs(numbers[n] - closest_elements[1]):\n            closest_elements\
    \ = (closest_elements[1], numbers[n])\n    return closest_elements\n", "    \n\
    \    return min(numbers), max(numbers)\n    \n    ", "    # Select the first two\
    \ elements and then sort them, then return them\n    closest_to = []\n    closest_to_val\
    \ = numbers[0]\n    closest_to_val_2 = numbers[1]\n    if numbers[1] > numbers[0]:\n\
    \        closest_to.append(numbers[1])\n        closest_to_val = numbers[1]\n\
    \    else:\n        closest_to.append(numbers[0])\n        closest_to_val = numbers[0]\n\
    \    if numbers[2] > numbers[0]:\n        closest_to.append(numbers[2])\n    \
    \    closest_to_val_2 = numbers[2]\n    else:\n        closest_to.append(numbers[0])\n\
    \        closest_to_val_2 = numbers[0]\n    if closest_to_val > closest_to_val_2:\n\
    \        closest_to.append(closest_to_val)\n        closest_to.append(closest_to_val_2)\n\
    \        closest_to.sort()\n    else:\n        closest_to.append(closest_to_val_2)\n\
    \        closest_to.append(closest_to_val)\n        closest_to.sort()\n    return\
    \ closest_to\n\n", "    smallest = numbers[0]\n    biggest = numbers[0]\n\n  \
    \  for number in numbers:\n        if number < smallest:\n            smallest\
    \ = number\n        elif number > biggest:\n            biggest = number\n\n \
    \   return smallest, biggest\n\n", "    if len(numbers) <= 1:\n        raise IndexError('Must\
    \ have at least two elements')\n\n    closest_to_one = numbers[0]\n    closest_to_two\
    \ = numbers[0]\n    for x in numbers[1:]:\n        if abs(closest_to_one - x)\
    \ < abs(closest_to_two - x):\n            closest_to_one = x\n        else:\n\
    \            closest_to_two = x\n\n    return closest_to_one, closest_to_two\n",
  "    if len(numbers) < 2:\n        return (numbers[0], numbers[0])\n    smallest_diff\
    \ = abs(numbers[0] - numbers[1])\n    smallest_diff_index = -1\n    largest_diff\
    \ = abs(numbers[0] - numbers[2])\n    largest_diff_index = -1\n    for i in range(2,\
    \ len(numbers)):\n        diff = abs(numbers[i - 1] - numbers[i])\n        if\
    \ diff < smallest_diff:\n            smallest_diff = diff\n            smallest_diff_index\
    \ = i\n        elif diff > largest_diff:\n            largest_diff = diff\n  \
    \          largest_diff_index = i\n    if smallest_diff <= largest_diff:\n   \
    \     return (numbers[smallest_diff_index], numbers[largest_diff_index])\n   \
    \ return (numbers[smallest_diff_index], numbers[largest_diff_index])\n\n", " \
    \   pairs = []\n    for i in range(len(numbers)-1):\n        if numbers[i] ==\
    \ numbers[i+1]:\n            continue\n        pairs.append((numbers[i], numbers[i+1]))\n\
    \    if len(pairs) < 2:\n        return numbers[0], numbers[-1]\n    closest_left\
    \ = pairs[0]\n    closest_right = pairs[-1]\n    for pair in pairs[1:]:\n    \
    \    if pair[0] > closest_right[0]:\n            closest_right = pair\n      \
    \  elif pair[1] < closest_left[1]:\n            closest_left = pair\n    return\
    \ closest_left[0], closest_right[1]\n", "    if len(numbers) <= 1:\n        return\
    \ numbers[0], numbers[0]\n    sorted_numbers = sorted(numbers)\n    return sorted_numbers[0],\
    \ sorted_numbers[-1]\n\n", "    numbers.sort()\n    return numbers[0], numbers[-1]\n\
    \n", "    assert 2 <= len(numbers) <= 3\n\n    smallest_difference = numbers[1]\
    \ - numbers[0]\n    greatest_difference = numbers[-1] - numbers[-2]\n    closest_to_zero\
    \ = numbers[0]\n\n    if smallest_difference >= greatest_difference:\n       \
    \ closest_to_zero = numbers[-1]\n    else:\n        closest_to_zero = numbers[-2]\n\
    \    return closest_to_zero, closest_to_zero\n</code>\nFor a working example of\
    \ this in action:\n<code>\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n(2.0, 2.0)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    (2.0, 2.2)\n>>> find_closest_elements([1.1, 2.2, 3.3, 4.4, 5.5, 2.2])\n(2.2, 2.2)\n\
    >>> find_closest_elements([1.1, 2.2, 3.3, 4.4, 5.5, 2.1])\n(2.1, 1.1)\n>>> find_closest_elements([1.1,\
    \ 2.2, 3.3, 4.4, 5.5, 2.1])\n(2.1, 1.1)\n</code>\n<|/ a dscore=2 tags=python,arrays\
    \ |>\n<| c |>\nThanks for the response.  I wasn't sure if there was any built-in\
    \ or easy way to do this, so that's why I didn't post any code here.\n<|/ c |>\n\
    <| c |>\nI wasn't sure if it was you who wanted an answer so I posted mine. I\
    \ only thought it might come in handy later on to someone else. Not sure if that's\
    \ what you're looking for.\n<|/ c |>\n<| c |>\nI thought I'd upvote your answer\
    \ since it was a good answer to the question.  But I'm going to leave the question\
    \ open for a little longer to see if anyone else has a better answer.  But thank\
    \ you very much for your response.\n<|/ c |>\n<| a tags=python,arrays |>\n<code>\n\
    import math\n\narray = [1,2,3,4]\n", "    return min(numbers), max(numbers)\n",
  "    # Find the two closest values\n    sorted_numbers = sorted(numbers)\n    closest_number\
    \ = sorted_numbers[0]\n    closest_number_2 = sorted_numbers[1]\n    # Return\
    \ the tuple\n    return (closest_number, closest_number_2)\n\n", "    # Convert\
    \ to a set so that we don't try to find the same number twice\n    numbers = set(numbers)\n\
    \    if len(numbers) <= 1:\n        raise RuntimeError(\"Cannot find the closest\
    \ of two numbers with less than two numbers\")\n    smallest_number = min(numbers)\n\
    \    largest_number = max(numbers)\n    closest_numbers = [smallest_number, largest_number]\n\
    \    closest_numbers.sort()\n    return closest_numbers\n\n", "    if len(numbers)\
    \ < 2:\n        raise ValueError(f\"At least two numbers must be provided in order\
    \ to find two closest numbers\")\n    sorted_numbers = tuple(sorted(numbers))\n\
    \    return sorted_numbers[0], sorted_numbers[1]\n\n", "    sorted_numbers = sorted(numbers)\n\
    \    smallest = sorted_numbers[0]\n    largest = sorted_numbers[-1]\n    smallest_index\
    \ = numbers.index(smallest)\n    largest_index = numbers.index(largest)\n    return\
    \ smallest, sorted_numbers[smallest_index], sorted_numbers[largest_index]\n\n",
  "    minimum = numbers[0]\n    maximum = numbers[0]\n\n    # loop through list and\
    \ compare each element to each other\n    for i in range(1, min(len(numbers),\
    \ 2)):\n        if numbers[i] > maximum:\n            maximum = numbers[i]\n \
    \       if numbers[i] < minimum:\n            minimum = numbers[i]\n\n    return\
    \ minimum, maximum\n\n", "    if len(numbers) < 2:\n        raise ValueError('The\
    \ input list must contain at least two elements')\n    smallest = numbers[0]\n\
    \    biggest = numbers[1]\n    for number in numbers[2:]:\n        if number <\
    \ smallest:\n            smallest = number\n        if number > biggest:\n   \
    \         biggest = number\n    return smallest, biggest\n\n", "    closest_elements\
    \ = (numbers[0], numbers[0])\n    closest_distance  = numbers[0]\n    for num\
    \ in numbers[1:]:\n        distance = abs(closest_distance - num)\n        if\
    \ distance < closest_distance:\n            closest_distance = distance\n    \
    \        closest_elements = (num, closest_elements[1])\n    return closest_elements\n",
  "    # TODO\n    return None, None\n\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError(\"The supplied list must have at least two items\")\n\n    difference\
    \ = [abs(x - numbers[0]) for x in numbers]\n    closest_indexes = [i for i, x\
    \ in enumerate(difference) if x == min(difference)]\n    closest_index = closest_indexes[0]\n\
    \n    return numbers[closest_index], numbers[closest_index + 1]\n\n", "    smallest\
    \ = numbers[0]\n    largest = numbers[0]\n    for number in numbers:\n       \
    \ if number > largest:\n            largest = number\n        if number < smallest:\n\
    \            smallest = number\n    return smallest, largest\n", "    assert len(numbers)\
    \ > 0, \"Can't find closest pairs without numbers\"\n    smallest = numbers[0]\n\
    \    largest = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i]\
    \ < smallest:\n            smallest = numbers[i]\n        if numbers[i] > largest:\n\
    \            largest = numbers[i]\n    return smallest, largest\n", "    closest_number\
    \ = None\n    closeness_to_closest_number = None\n    closest_other_number = None\n\
    \    closeness_to_closest_other_number = None\n    \n    for index, number in\
    \ enumerate(numbers):\n        if (closest_number == None) or (abs(number - closest_number)\
    \ < abs(closest_other_number - number)):\n            closest_number = number\n\
    \            closeness_to_closest_number = index\n        else:\n            closest_other_number\
    \ = number\n            closeness_to_closest_other_number = index\n          \
    \  \n    if closest_other_number == None:\n        return (closest_number, numbers[0])\n\
    \    else:\n        return (closest_other_number, numbers[closeness_to_closest_other_number])\n\
    \n", "    smallest = numbers[0]\n    largest = numbers[0]\n\n    for num in numbers:\n\
    \        if num < smallest:\n            smallest = num\n        elif num > largest:\n\
    \            largest = num\n\n    return smallest, largest\n\n", "    if not numbers\
    \ or len(numbers) < 2:\n        raise ValueError(\"You supplied no valid numbers\
    \ to check against\")\n\n    numbers.sort()\n\n    if len(numbers) == 1:\n   \
    \     return numbers[0], numbers[0]\n\n    closest_pair = numbers[0], numbers[0]\n\
    \    for n in numbers[1:]:\n        delta = n - closest_pair[1]\n        if delta\
    \ >= closest_pair[0] - closest_pair[1]:\n            closest_pair = (n, closest_pair[1])\n\
    \        else:\n            closest_pair = (closest_pair[0], n)\n\n    return\
    \ closest_pair\n\n", "    if len(numbers) < 2:\n        raise ValueError('At least\
    \ two numbers must be supplied')\n\n    if len(numbers) == 1:\n        return\
    \ (numbers[0], numbers[0])\n\n    sorted_numbers = sorted(numbers)\n\n    if sorted_numbers[0]\
    \ - sorted_numbers[1] < .0000001:\n        return (sorted_numbers[1], sorted_numbers[0])\n\
    \    else:\n        return (sorted_numbers[0], sorted_numbers[1])\n\n", "    assert\
    \ (len(numbers) >= 2)\n    min_diff = float('inf')\n    min_diff_idx = None\n\
    \    for idx in range(0, len(numbers)):\n        diff = abs(numbers[idx] - numbers[idx\
    \ - 1])\n        if (diff < min_diff):\n            min_diff = diff\n        \
    \    min_diff_idx = idx\n    return numbers[min_diff_idx], numbers[min_diff_idx\
    \ + 1]\n\n", "    min_diff = float('inf')\n    min_number = None\n    for i in\
    \ range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n\
    \        if diff < min_diff:\n            min_diff = diff\n            min_number\
    \ = numbers[i] if diff == 0 else numbers[i + 1]\n    return min_number, min_number\n\
    \n", "    smallest_number: float = numbers[0]\n    greatest_number: float = numbers[0]\n\
    \    for num in numbers:\n        if num < smallest_number:\n            smallest_number\
    \ = num\n        elif num > greatest_number:\n            greatest_number = num\n\
    \    return smallest_number, greatest_number\n", "    # Find the two smallest\
    \ numbers in the list\n    min_number = min(numbers)\n    smallest_number = min_number\n\
    \    second_smallest_number = min_number\n\n    for number in numbers:\n     \
    \   if number == min_number:\n            pass\n        elif number == second_smallest_number:\n\
    \            pass\n        elif abs(number - min_number) < abs(number - second_smallest_number):\n\
    \            second_smallest_number = min_number\n        else:\n            smallest_number\
    \ = min_number\n            break\n\n    return smallest_number, second_smallest_number\n",
  "    if len(numbers) < 2:\n        raise IndexError(\"Must supply at least two numbers\"\
    )\n    smallest_number = min(numbers)\n    biggest_number = max(numbers)\n   \
    \ closest = biggest_number\n    closest_smaller = smallest_number\n    closest_larger\
    \ = biggest_number\n    for num in numbers:\n        if num == closest:\n    \
    \        closest = closest_smaller\n            closest_smaller = num\n      \
    \  elif num < closest:\n            closest = closest_larger\n            closest_larger\
    \ = num\n    return closest_smaller, closest_larger\n\n", "    number_1 = min(numbers)\n\
    \    number_2 = max(numbers)\n    diff = abs(number_1 - number_2)\n    closest_element_1\
    \ = number_1 if diff < numbers[-1] else number_2\n    closest_element_2 = number_1\
    \ if diff > numbers[0] else number_2\n    return closest_element_1, closest_element_2\n\
    \n", "    return min(numbers), max(numbers)\n", "    if len(numbers) < 2:\n  \
    \      raise IndexError(\"Please provide a list of at least two numbers to work\
    \ with\")\n\n    # Find the two numbers that are closest to each other\n    numbers_with_diff\
    \ = [(i + 1, x - numbers[0]) for i, x in enumerate(numbers[1:])]\n    closest_numbers\
    \ = min(numbers_with_diff, key=lambda tup: abs(tup[1] - tup[0]))\n\n    # Return\
    \ the first element and the second\n    return closest_numbers[0], closest_numbers[1]\n\
    \n", "    if len(numbers) < 2:\n        raise ValueError(f\"Number of values supplied\
    \ ({len(numbers)}) must be greater than one.\")\n    if numbers[0] > numbers[-1]:\n\
    \        return (numbers[-1], numbers[0])\n    distances = list(map(lambda x,\
    \ y: abs(x - y), numbers[:-1], numbers[1:]))\n    closest_to_first = min(distances)\n\
    \    closest_to_second = min(distances)\n    return (numbers[distances.index(closest_to_first)],\n\
    \            numbers[distances.index(closest_to_second)])\n", "    assert len(numbers)\
    \ > 1, \"Can't find a pair of elements if only have one element\"\n    difference\
    \ = numbers[1] - numbers[0]\n    smallest_number = numbers[0]\n    largest_number\
    \ = numbers[0]\n    for number in numbers:\n        diff = number - difference\n\
    \        if diff < smallest_number:\n            smallest_number = diff\n    \
    \    if diff > largest_number:\n            largest_number = diff\n    return\
    \ smallest_number, largest_number\n\n", "    assert len(numbers) >= 2\n    numbers.sort()\n\
    \    smallest_number = numbers[0]\n    larger_number = numbers[-1]\n    closest_number_index\
    \ = 0\n    closest_distance = sys.maxsize\n    for index in range(1, len(numbers)):\n\
    \        curr_distance = abs(numbers[index] - larger_number)\n        if curr_distance\
    \ < closest_distance:\n            closest_distance = curr_distance\n        \
    \    closest_number_index = index\n\n    if closest_distance == sys.maxsize:\n\
    \        return None, None\n    else:\n        return smallest_number, larger_number\n",
  "    if len(numbers) < 2:\n        raise ValueError('List must be of length at least\
    \ 2')\n    if all(number == numbers[0] for number in numbers):\n        return\
    \ numbers[0], numbers[0]\n    numbers.sort()\n    before, after = numbers[0],\
    \ numbers[1]\n    return before, after\n", "    return min(numbers), max(numbers)\n",
  "    smallest_diff = (numbers[0], numbers[1])\n    second_smallest_diff = (numbers[1],\
    \ numbers[0])\n    for element in numbers[1:]:\n        diff = (element - smallest_diff[0],\
    \ element - second_smallest_diff[0])\n        if diff == smallest_diff:\n    \
    \        smallest_diff = (element, element)\n        elif diff == second_smallest_diff:\n\
    \            second_smallest_diff = (element, element)\n    return smallest_diff,\
    \ second_smallest_diff\n", "    distances = sorted([abs(numbers[i] - numbers[i-1])\
    \ for i in range(1, len(numbers))])\n    return distances[0], distances[-1]\n",
  "    minimum = numbers[0]\n    maximum = numbers[0]\n    for number in numbers[1:]:\n\
    \        if number < minimum:\n            minimum = number\n        elif number\
    \ > maximum:\n            maximum = number\n    return minimum, maximum\n", " \
    \   assert len(numbers) >= 2\n    smallest_diff = numbers[0] - numbers[1]\n  \
    \  largest_diff = numbers[-1] - numbers[0]\n    for index in range(len(numbers)\
    \ - 1):\n        diff = numbers[index + 1] - numbers[index]\n        if diff <\
    \ smallest_diff:\n            smallest_diff = diff\n        if diff > largest_diff:\n\
    \            largest_diff = diff\n    return smallest_diff, largest_diff\n\n",
  "    return min(numbers, key=lambda n: abs(n - numbers[0])), max(numbers, key=lambda\
    \ n: abs(n - numbers[0]))\n", "    smallest_distance = numbers[0]\n    largest_distance\
    \ = numbers[0]\n    smallest_number = numbers[0]\n    largest_number = numbers[0]\n\
    \    smallest_number_index = -1\n    largest_number_index = -1\n    for index,\
    \ number in enumerate(numbers):\n        if number < smallest_distance:\n    \
    \        smallest_distance = number\n            smallest_number = number\n  \
    \          smallest_number_index = index\n        if number > largest_distance:\n\
    \            largest_distance = number\n            largest_number = number\n\
    \            largest_number_index = index\n    return smallest_number, largest_number\n\
    \n", "    smallest_number = min(numbers)\n    largest_number = max(numbers)\n\
    \    closest_pair_index = None\n    if smallest_number != largest_number:\n  \
    \      # find closest pair by binary search\n        closest_pair_index = find_closest_pair(numbers,\
    \ smallest_number, largest_number)\n        # find the pair with the smallest\
    \ difference\n        closest_pair = numbers[closest_pair_index]\n        difference\
    \ = largest_number - closest_pair\n        return (closest_pair, difference)\n\
    \    else:\n        return None, None\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError(\"List must have at least two elements\")\n    # First find smallest\
    \ and largest values\n    smallest_number = min(numbers)\n    largest_number =\
    \ max(numbers)\n    # Now find the pair\n    pair_numbers = (i for i in numbers\
    \ if i >= smallest_number and i <= largest_number)\n    smallest_pair = min(pair_numbers)\n\
    \    largest_pair = max(pair_numbers)\n    # And return both\n    return (smallest_pair,\
    \ largest_pair)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
