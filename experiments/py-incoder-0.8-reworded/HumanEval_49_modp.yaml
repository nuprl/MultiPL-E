name: HumanEval_49_modp
language: py
prompt: "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
  \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
  \    1\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101,\
  \ 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n\
  \    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert\
  \ candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n"
completions: ["    return pow(2, n, p)\n\n", "    if not p:\n        return 0\n  \
    \  res = 1\n    while n > 0:\n        if n & 1:\n            res = (res % p +\
    \ 1) * p % p\n        n >>= 1\n    return res\n", "    p %= n\n    return ((n\
    \ & (n-1)) * p + n) % (p-1)\n\n", "    return -(-n & -p) if (n & p) < 0 else (n\
    \ & ~p)\n\n", "    if n == 0:\n        return 0\n    elif n % p == 0:\n      \
    \  return p\n    else:\n        return n % p + p\n\n", "    return -(-n & n-1)%p\n",
  "    if n == 0:\n        return 0\n    elif n & 1 and n != p:\n        return p\
    \ - modp(n // 2, p)\n    else:\n        return modp(n // 2, p) + p\n", "    return\
    \ pow(2, n, p)\n\n", "    assert n >= 0\n    assert p >= 0\n    if n == 0:\n \
    \       return 0\n    if p == 0:\n        return n\n    if n <= p - 1:\n     \
    \   return modp(n - 1, p) - 1\n    else:\n        q = p // n\n        r = n %\
    \ p\n        return modp(q * n, p) + r\n\n", "    if not p:\n        return 1\n\
    \    while p < 0:\n        p += p\n    return p % n\n\n", "    return n & (-p-1)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return p\n \
    \   else:\n        return modp(n // 2, p) + p\n\n", "    if n == 0:\n        return\
    \ 0\n    if n == 1:\n        return p\n    if not p & 1:\n        raise ValueError(\"\
    p must be an odd integer\")\n    k = n >> 1\n    t = p\n    while k & 1 == 0:\n\
    \        k >>= 1\n        t *= p\n    t %= p\n    if k > n:\n        return modp(k,\
    \ p)\n    return t\n\n", "    if p == 2:\n        return n\n    return n & (p\
    \ - 1)\n\n", "    assert isinstance(n, int) and isinstance(p, int), 'args must\
    \ be integers'\n    if n == 0:\n        return 0\n    if n == 1 or n == -1:\n\
    \        return p\n    return p%n\n\n", "    return 2 << n & -p\n\n", "    if\
    \ n == 0:\n        return 0\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n\
    \    n |= n >> 8\n    n |= n >> 16\n    if p == 2:\n        return n\n    if p\
    \ == 4:\n        return n + (n >> 1)\n    if p == 8:\n        return n + (n >>\
    \ 2) + (n >> 3)\n    if p == 16:\n        return n + (n >> 4) + (n >> 5) + (n\
    \ >> 6) + (n >> 7)\n    if p == 32:\n        return n + (n >> 8) + (n >> 9) +\
    \ (n >> 10) + (n >> 11)\n    if p == 64:\n        return n + (n >> 12) + (n >>\
    \ 13) + (n >> 14) + (n >> 15)\n    return 0\n\n", "    # see https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\
    \    # it is the same algorithm as used by gmpy\n    if p == 2:\n        return\
    \ n\n\n    if n % 2 == 0:\n        x, r = divmod(n, p)\n        if r == 0:\n \
    \           return x\n\n        while x > 0:\n            if x % p == 0:\n   \
    \             x //= p\n            else:\n                x += p\n        return\
    \ x\n\n    if p % 2 == 0:\n        x, r = divmod(n, p)\n        if r == 0:\n \
    \           return x\n\n        while x > 0:\n            if x % p == 0:\n   \
    \             x //= p\n            else:\n                x -= p\n        return\
    \ x\n    raise ValueError(\"n must be positive and a power of 2 >= p or negative\"\
    )\n\n", "    if n == 0:\n        return p\n    return p - 1\n\n", "    if not\
    \ n:\n        return n\n    if n == 1:\n        return 0\n    if n <= 8:\n   \
    \     return ((n * (n - 1)) // 2 if n < 9 else n) - 1\n    if n % 2 == 0 or n\
    \ % 3 == 0:\n        n = n % 7 + (1 if n < 8 else 4)\n    else:\n        n = n\
    \ % 7\n    if n % 5 == 0:\n        return 2 * modp(n // 5, p)\n    if n % 7 ==\
    \ 0:\n        return 2 * modp(n // 7, p) * p\n    return 2 * modp(n % 7, p) *\
    \ p\n", "    return ((n) % (p)) + (((n) % (p)) == 0)\n", "    if p == 2:\n   \
    \     return n\n    return n & (p - 1)\n\n", "    # Extended Euclidean algorithm\n\
    \    # http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    if n ==\
    \ 0 or (p == 1 and n) == 1:\n        return n\n    if n == 1:\n        return\
    \ p\n    if p == 1 or n == 0:\n        return n\n\n    b = 1\n    while p != 0:\n\
    \        if p & 1:\n            a = (n % b)\n            n = n // b\n        \
    \    if p == 1:\n                return a\n            else:\n               \
    \ p = (p >> 1)\n                b = a\n        else:\n            a = (n % b)\n\
    \            n = n // b\n            if n == 1:\n                return a\n  \
    \          else:\n                p = (p >> 1)\n                b = a\n    raise\
    \ RuntimeError(\"modp: illegal input\")\n\n", "    return 1<<(n%p)\n", "    i\
    \ = 0\n    j = 1\n    while i < n:\n        j = i\n        while j < n:\n    \
    \        if ((p >> i) & ((p >> j) & 1)) == 1:\n                j += 1\n      \
    \      else:\n                i += 1\n                break\n        return i\n\
    \    return n\n\n", "    if n == 0:\n        return 0\n    k = n % p\n    if k\
    \ == 0:\n        return p\n    if k == 1 or k == p - 1:\n        return k\n  \
    \  return k - p + (p - 1) % p\n\n", "    return n & (p - 1)\n\n", "    if n ==\
    \ 0:\n        return p\n\n    if n == 1:\n        return p\n\n    return pow(2,\
    \ n, p)\n\n", "    while p & 1 == 0:\n        p >>= 1\n        n -= 1\n    return\
    \ ((n << 1) + 1) % (p)\n\n", "    base = 2 << n\n    if p == 0 or p == 2:\n  \
    \      return base\n    p -= 1\n    k = base - 1\n    while p & 1:\n        k\
    \ -= 1\n        p >>= 1\n    p += 1\n    assert k > 0\n    if k == p - 1:\n  \
    \      return k\n    if p == 1 or p == 3:\n        return base\n    if p == 5:\n\
    \        return base + 4\n    if p == 7:\n        return base + 8\n    return\
    \ base\n\n", "    return ((n ** p + 1) // p) if (n and p) else None\n\n", "  \
    \  n = int(n)\n    if n == 0:\n        return 0\n    i, r = divmod(p, n)\n   \
    \ if r:\n        return n - i\n    return i\n\n", "    from math import log2\n\
    \    return pow(2, n, p) if n & 1 else 1\n\n", "    if p == 2:\n        return\
    \ n\n    if n < 0:\n        return modp(n - 2, p) % p\n    if n == 0:\n      \
    \  return 0\n    if n == 1:\n        return p\n    r = n & -p\n    return (r *\
    \ p + 2) % p\n", "    return n & (-p-1)\n", "    return ((n&1)^(p-1)) + modp(n>>1,\
    \ p-1)\n", "    if n == 0:\n        return 0\n    if p == 0 or p == 2:\n     \
    \   return n\n    if p % 2 == 0:\n        power = 2\n    else:\n        power\
    \ = 1\n    while p < n:\n        p = pow(p, 2)\n        power += 1\n    return\
    \ p\n\n", "    return 2 ** (n & -p) - 2 ** (n & 1)\n", "    n = int(n)\n    if\
    \ n == 0:\n        return 0\n    if n < 0:\n        return modp(abs(n), p)\n \
    \   if p == 2:\n        return n\n    low = 0\n    high = p\n    while high %\
    \ 2 == 1:\n        high /= 2\n    while high % 2 == 0:\n        high /= 2\n  \
    \  return high\n\n", "    return pow(2, n, p)\n\n", "    if n == 0:\n        return\
    \ p\n    return ((-p & -n) % p + n) % p\n\n", "    return ((n) % (p)) + (((n)\
    \ % (p)) > 0)\n\n", "    if n < 0:\n        raise ValueError(\"Negative inputs\
    \ not supported\")\n    k = bit_length(n)\n    p = p % p\n    if p > 31:\n   \
    \     return ((n >> k) + 1) // p\n    else:\n        return (n >> k) & 1\n\n",
  "    if n == 1:\n        return p\n    if n & 1 != 0:\n        return p - 1\n  \
    \  return p - 2\n\n", "    res = 0\n    while p != 0:\n        if p & 1:\n   \
    \         res = (res << 1) ^ n\n        p >>= 1\n        n >>= 1\n    return res\n\
    \n", "    if n == 0:\n        return 0\n    elif n < 0:\n        return n % p\n\
    \    elif n == 1:\n        return p\n    else:\n        modulus = p ** 2 if p\
    \ % 2 else p\n        mod = n % modulus\n        if mod == 0:\n            mod\
    \ = p\n        return mod\n\n", "    assert n >= 0\n    result = 0\n    while\
    \ p is not None:\n        if p & 1:\n            result = (result * n) % p\n \
    \       n >>= 1\n        p >>= 1\n    return result\n\n", "    if n == 0:\n  \
    \      return 0\n    if n < 0:\n        return modp(n - 1, p) * p\n    return\
    \ ((n - 1) % p + p) % p\n\n", "    if n == 0:\n        return p\n    return p\
    \ - (p%n)\n", "    return 2**(n + p - 1) if n >= 0 and p >= 0 else 2**(-n + 1)\n",
  "    num = pow(2, n, p)\n    if num <= p:\n        return num\n    return p - num\n\
    \n", "    return n & -p  # Bitwise and with itself is the identity modulo p\n",
  "    if n == 0:\n        return 0\n    if n < 0:\n        n -= p\n        if n ==\
    \ 0:\n            return -p\n        if n < 0:\n            return 0\n    else:\n\
    \        n -= p\n        if n == 0:\n            return p\n        if n > 0:\n\
    \            return 0\n    return 1\n", "    p, q = abs(p), abs(n)\n    if p ==\
    \ n:\n        return q\n    if q == p:\n        return p % q\n    a, b = divmod(p,\
    \ q)\n    return a - q * b\n", "    return (1 << (p - 1)) + n & (2**p-1)\n\n",
  "    if not is_integer(n):\n        raise TypeError(\"n must be integer\")\n   \
    \ if not is_integer(p):\n        raise TypeError(\"p must be integer\")\n    return\
    \ n & (-p) \n\n", "    if n == 1:\n        return p\n    q = p - 1\n    r = n\
    \ % p\n    return ((n // p) * p + r) % p\n\n", "    return ((n << 1) + 1) % (p\
    \ + 1)\n\n", "    return n % p\n\n", "    assert isinstance(n, int)\n    assert\
    \ isinstance(p, int)\n    if p == 0:\n        return 1\n    if p < 0:\n      \
    \  p = -p\n        if p < n:\n            return p - (n % p)\n        else:\n\
    \            return n\n    else:\n        if n < 0:\n            n = -n\n    \
    \        if n < p:\n                return n - (n % p)\n            else:\n  \
    \              return n\n        else:\n            return n\n\n", "    return\
    \ ((n-1) & -n) + (n & -n)\n\n", "    if n == 0:\n        return 0\n    x = 1\n\
    \    while n % p == 0:\n        n //= p\n        x += 1\n    return x\n\n", " \
    \   return n & -p\n", "    if n == 0:\n        return 0\n    if n < 0:\n     \
    \   return modp(abs(n), p)\n    if n < p:\n        return modp(n, p % p)\n   \
    \ if n == 1:\n        return p\n    low = 1\n    high = p\n    while high % 2\
    \ == 0:\n        high = high // 2\n    while low % 2 == 0:\n        low = low\
    \ // 2 \n    while low % 3 == 0:\n        low = low // 3\n    while high % 3 ==\
    \ 0:\n        high = high // 3\n    while high % 5 == 0:\n        high = high\
    \ // 5\n    while low % 5 == 0:\n        low = low // 5\n    while low % 7 ==\
    \ 0:\n        low = low // 7\n    while high % 7 == 0:\n        high = high //\
    \ 7\n    return low\n\n", "    return ((n + p + 1) // p) * p\n\n", "    if p <\
    \ 0:\n        return -modp(-n, p)\n    if n == 0:\n        return 0\n    if p\
    \ > n:\n        return modp(-n, p)\n    if n & 1:\n        return modp(n-1, p-1)\n\
    \    else:\n        return modp(n-1, p)\n", "    if p == 1: return n\n    return\
    \ n % p\n\n", "    if n < 0:\n        raise ValueError(\"n must be nonnegative\"\
    )\n    if n == 0:\n        return 1\n    d, r = divmod(p, n)\n    if r:\n    \
    \    return r\n    else:\n        return 2 ** n\n", "    return 2 ** n & -p\n\n",
  "    return 1  # XXX: implement with long division\n    while p:\n        if p &\
    \ 1:\n            n = n & -p\n        p >>= 1\n    return n\n\n", "    bit = 1\n\
    \    while n & bit != 0:\n        bit *= 2\n        n &= ~bit\n    return n\n\n",
  "    if p == 0:\n        raise ZeroDivisionError('division by zero')\n    if n ==\
    \ 0:\n        raise ZeroDivisionError('division by zero')\n    if p == n:\n  \
    \      return p\n\n    # Find GCD of n and p\n    g, x, _ = extended_gcd(n, p)\n\
    \    if g != 1:\n        raise ZeroDivisionError('modular inverse does not exist')\n\
    \n    # Extended GCD algorithm (see formula 3.1) iteratively reduces\n    # modulo.\
    \ Use the formula again to calculate iteratively.\n    r = a % p\n    while r:\n\
    \        a, r = r, a % p\n        g, x, y = extended_gcd(y, x)\n        if g !=\
    \ 1:\n            raise ZeroDivisionError('modular inverse does not exist')\n\
    \    return x % p\n\n", "    from collections import deque\n    a, b = 0, 1\n\
    \    while n > 1:\n        q, r = divmod(n, p)\n        n, b, a = b + (a << q),\
    \ b, a\n    return a\n", "    if p == 0:\n        raise ZeroDivisionError('modp(0,\
    \ %r) does not exist' % p)\n    if p == n:\n        return p\n    n, rem = divmod(n,\
    \ p)\n    if rem > 0:\n        return modp(rem * 2, p) % p\n    else:\n      \
    \  return modp(rem, p) % p\n", "    if n == 1:\n        return 0\n    t = int(math.ceil(p))\n\
    \    return t * (2 - t) ** (n - 1)\n\n", "    from math import modf\n    m, r\
    \ = divmod(n, p)\n    if r:\n        return p\n    else:\n        return 2 * m\
    \ - p\n\n", "    return ((n - 1) * (p + 1) + 1) // 2\n\n", "    return n & -p\n\
    \n", "    return ((p-1)//n)*n + (p % n)\n", "    if p < 0:\n        n %= -p\n\
    \    elif n < 0:\n        n = 0\n    return ((1 << n) ^ ((1 << (n % p)) - (1 <<\
    \ p)))\n\n", "    return ((n + p + 1) // p)\n", "    return ((n-1)//p + 1) * (p-1)\n\
    \n", "    # Bitwise operations are faster than modulo when both\n    # arguments\
    \ are small and when p is small.\n    # See https://bugs.python.org/issue32883\
    \ for more details\n    if p > n:\n        p, n = n, p\n    if n & p == n:  #\
    \ n is even, p is even\n        return n\n    if n & -p == p:  # n is odd, p is\
    \ odd\n        return -p\n    return p - 1\n\n", "    if n & 1:\n        return\
    \ n\n    if p & 1:\n        return p - 1\n    n >>= 1\n    p >>= 1\n    while\
    \ p:\n        if n % p == 0:\n            return n\n        n //= p\n        p\
    \ //= p\n    return n\n\n", "    if not n:\n        return n\n    result = 1\n\
    \    while n:\n        if n % p == 0:\n            result *= p\n            n\
    \ //= p\n        else:\n            result *= p\n            n -= 1\n    return\
    \ result\n\n", "    if n == 0:\n        return 0\n    if n % p == 0:\n       \
    \ return pow(2, n, p)\n    if not n & 1:\n        return modp(n // 2, p)\n   \
    \ return modp(n // 2, p) + p\n\n", "    if n == 0:\n        return 0\n    res\
    \ = 1\n    while p & 1 == 0:\n        p >>= 1\n        n -= 1\n    res = (res\
    \ << p) ^ n\n    return res\n\n", "    assert isinstance(n, int)\n    assert isinstance(p,\
    \ int)\n    assert n >= 0\n    assert p >= 0\n    if not n and not p:\n      \
    \  return 0\n    if n == 1:\n        return p\n    if n == p:\n        return\
    \ n\n    while n > 0:\n        if (p & 1) == 0:\n            p >>= 1\n       \
    \     n -= 1\n        else:\n            n >>= 1\n            p &= p + 1\n   \
    \ return p\n\n", "    return n & (p-1)\n\n", "    return ((n) ** (p - 1) * (n\
    \ % p)) % p\n", "    return (n & -p) | ((n & p) == 0)\n\n", "    assert n >= 0\n\
    \    return ((n|1)|p|1) - (((n&1)|p&1)<<(p-1))\n\n", "    ans = 0\n    while n:\n\
    \        if n % p == 0:\n            ans = ans * p + (n - p) % p\n           \
    \ n = n // p\n        else:\n            ans = ans + (n - 1) % p\n           \
    \ n = (n - 1) % p\n    return ans\n", "    if p < 1:\n        raise ValueError(f\"\
    p must be positive ({p} was given).\")\n    if n == 0:\n        return 0\n   \
    \ d, r = divmod(n, p)\n    return d + (1 if r == 0 else 0)\n\n", "    return ((n\
    \ << 1) + 1) // p\n\n", "    if n == 0:\n        return 0\n    if n < 0:\n   \
    \     return 1 << (p - 1)\n    if p < 2 or p != int(p):\n        return 0 # force\
    \ casts\n    return 1 << (p - 1) * (n % p)\n\n", "    if p == 0:\n        raise\
    \ ZeroDivisionError(\"division by zero\")\n    while p < n:\n        if p & 1:\n\
    \            p = p + 1\n        else:\n            p = p >> 1\n    return p\n\n",
  "    if n == 0:\n        return 0\n    elif n < 0:\n        return modp(n - 1, p)\
    \ * (p - 1) % p\n    else:\n        return modp(n + 1, p) * (p - 1) % p\n\n",
  "    if n == 0:\n        return 0\n    if p == 0 or p == n:\n        return 1\n\
    \    if n < 0:\n        n += p\n        p -= 1\n    return p\n\n", "    return\
    \ 1 & ((n - p) >> (p - 1))\n\n", "    if n == 0:\n        return p\n    if n <\
    \ 0:\n        raise ValueError(f\"Modulus cannot be negative: {n}\")\n    if p\
    \ < 0:\n        raise ValueError(f\"Modulus cannot be negative: {p}\")\n    if\
    \ p == 0 or p == 1:\n        return p\n    if n == 1:\n        return p\n    if\
    \ n == 2:\n        return p + p % p\n    return (p * pow(2, n, p)) % p\n\n", " \
    \   # Extremely conservative bounds check\n    if p < 1 or (p > 2 and n > 0 and\
    \ n % 1 == 0):\n        raise ValueError(f\"Modulus must be positive, got {n}\
    \ and {p}\")\n    # Optimizations\n    if n == 0:\n        return 0\n    p -=\
    \ 1\n    x = n\n    while p > 0 and x > 1:\n        x //= p\n        p -= 1\n\
    \    return x\n\n", "    # see https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_multiplicative_inverse\n\
    \    if p == 2:\n        return n\n    if n < 0:\n        return modp(-n, p)\n\
    \    if p == 2:\n        return p\n    m = n\n    p1 = 0\n    while m % 2 == 0:\n\
    \        m >>= 1\n        p1 += 1\n    while p1 < p:\n        if n % p1 == p1\
    \ - 1:\n            m = m % p1\n            p1 += 1\n        else:\n         \
    \   m = (m + 1) // 2\n            p1 += 1\n    if p1 < p:\n        return m\n\
    \    else:\n        return m % p\n\n", "    if not n:\n        return n\n    k\
    \ = pow(2, n)\n    return (-p * k + n) % (p * k)\n\n", "    if n == 0:\n     \
    \   return 0\n    a, b = n >> 1, p\n    while b:\n        a, b = b, a % b\n  \
    \  return a\n\n", "    if p == 2:\n        return n\n    if p < 1:\n        raise\
    \ ValueError(f\"p must be >= 1, got {p}\")\n    if n == 0:\n        return 0\n\
    \    if n == 1 or n == 2:\n        return n\n    if n % 2 == 0:\n        return\
    \ modp(n // 2, p)\n    return modp((n - 1) // 2, p) * p\n\n", "    # This is pretty\
    \ slow, but we do it in Python.\n    # Do the exponentiation with Python integers\
    \ (not doubles!)\n    # then return the result as long as there is no overflow.\n\
    \    result = 1\n    while n:\n        if n % 2:\n            result = (result\
    \ * n) % p\n        n //= 2\n    return result\n", "    q, r = divmod(n, p)\n\
    \    if r:\n        return q + r\n    else:\n        return q\n\n", "    if n\
    \ == 0:\n        return 0\n    if p == 0:\n        return n\n    if p == n:\n\
    \        return p\n    if p > n:\n        p %= n\n    n, rem = divmod(n, p)\n\
    \    if rem == 0:\n        return p\n    if n == 0:\n        return 0\n    p,\
    \ n = n, p\n    n, rem = divmod(n, p)\n    return p + (n << rem | n >> (32 - rem))\n\
    \n", "    return n & -p\n", "    r = n % p\n    return r if r != 0 else p\n\n",
  "    return ((n & (n - 1)) * p + 1) // 2\n\n", "    # adapted from code in _Py_Power\
    \ and CPython's heapq\n    if n == 0:\n        return 0\n    elif n % p == 0:\n\
    \        return p\n    elif p < 0:\n        return modp(n % p, -p) % p\n    else:\n\
    \        k, r = divmod(n, p)\n        if k == 0:\n            return r\n     \
    \   else:\n            return modp(k, p) % p\n\n", "    if n < 0:\n        raise\
    \ ValueError(\"modp() doesn't handle negative numbers\")\n    if n == 0:\n   \
    \     return 1\n    if p == 0 or p == 1:\n        return n\n    if not isqrt(n)\
    \ and isqrt(p) > 8:\n        return modp(n // p, p)\n    if not isqrt(p) and isqrt(p)\
    \ > 8:\n        return modp((n * p) // 4, p)\n    if p % 4 == 0:\n        return\
    \ modp(n // 2, p)\n    if p % 8 == 0:\n        return modp((n * p) // 4, p)\n\
    \    if p % 16 == 0:\n        return modp((n * p) // 8, p)\n    if p % 32 == 0:\n\
    \        return modp(n // 32, p)\n    if isqrt(p) > 8:\n        return modp(n\
    \ // p, p)\n    return modp(n, p)\n", "    if n == 0:\n        return 0\n    if\
    \ p == 0:\n        return n\n    return (n - 1) * (n % p)\n\n", "    bits = bin(n)[2:]\n\
    \    bits = [0 if x.isdigit() else x for x in bits]\n    return int(\"\".join(bits[p:p+p]),\
    \ 2)\n\n", "    return -(-n // p) if n % p == 0 else n % p\n\n", "    if n ==\
    \ 0:\n        return 0\n    if n == 1:\n        return 1\n    if p < 1:\n    \
    \    if p % 2 != 0:\n            return 0\n        return p\n    i = 1\n    while\
    \ p // i:\n        i <<= 1\n    if i == 1:\n        return 1\n    if n&(1<<(n-1)):\n\
    \        return 0\n    return p\n\n", "    return ((n + p) % (p - 1)) * 2 - p\n",
  "    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if p <\
    \ 0:\n        raise ValueError(\"no negative divisor\")\n    if p >= n:\n    \
    \    raise ValueError(\"no positive divisor\")\n    d, r = divmod(p, n)\n    return\
    \ d * (n - r) + r\n\n", "    assert n >= 0\n    return ((n % p) + p) % p\n\n",
  "    return ((n + p + 1) // p) * p\n\n", "    if p == 2:\n        return n\n   \
    \ n %= p\n    return n and n * 2 - n % p\n", "    if n == 0:\n        return 0\n\
    \    if n == 1:\n        return p\n    if p == 2:\n        return n\n    while\
    \ p % 4 == 0:\n        p //= 4\n    if p % 8 == 0:\n        p //= 8\n    return\
    \ p\n\n", "    return 1 & (n & -p).__xor__(n)\n\n", "    ret = pow(2, n, p)\n\
    \    if n < 0:\n        ret %= p\n    if p > 0:\n        ret %= p\n    return\
    \ ret\n\n", "    if n == 0:\n        return 0\n    n &= 0xFFFFFFFF\n    if n ==\
    \ 0 and (p == 0 or p == 1):\n        return p\n    if n == 1:\n        return\
    \ p % p\n    if p == 2:\n        return ((p ** 2) % p) % p\n    lo = 0\n    hi\
    \ = p-1\n    while lo < hi:\n        mid = (lo+hi)//2\n        if n == (2**mid)\
    \ % p:\n            hi = mid\n        else:\n            lo = mid+1\n    if lo\
    \ < p:\n        return lo\n    else:\n        return p-1\n\n", "    return n &\
    \ -p\n\n", "    return ((n & -p) == n) == ((n % p) == p)\n", "    return ((n -\
    \ 1) * (n + 1)) // p & (p - 1)\n\n", "    return ((n & 1) << (p & 1)) + modp(n\
    \ >> 1, p) if n >> p == 0 else n\n", "    if n == 0:\n        return 0\n    if\
    \ n == 1:\n        return p\n    result = 1\n    while result * p < n:\n     \
    \   result *= p\n        p += 1\n    result %= p\n    if p == 0:\n        result\
    \ = 1\n    else:\n        result *= p\n    return result\n\n", "    return ((n\
    \ << p) + 1) % (p + 1)\n", "    if p == 2:\n        return n\n    if p == n:\n\
    \        return p\n    if p == 0:\n        return 0\n\n    if n % p == 0:\n  \
    \      q = n // p\n        return modp(q, p)\n    return modp(p, n)\n", "    return\
    \ n & -p\n", "    n, remainder = divmod(n, p)\n    if remainder:\n        return\
    \ n * p + p\n    return n\n", "    if n == 0:\n        return 0\n    ret = n &\
    \ -p\n    ret2 = n >> p\n    if ret < 0:\n        if ret2 < 0 or -ret2 > ret:\n\
    \            return ret ^ ret2\n        else:\n            return ret\n    else:\n\
    \        if ret2 < 0 or -ret2 > -ret:\n            return ret ^ ret2\n       \
    \ else:\n            return ret\n\n", "    if n < 0:\n        return n % p\n \
    \   elif n == 0:\n        return 0\n    elif n == 1:\n        return p\n    else:\n\
    \        return p - (p // p * n) % p\n\n", "    if n == 0:\n        return 0\n\
    \    elif n == 1:\n        return p\n    else:\n        q = p - 1\n        quotient,\
    \ remainder = _modp_bang_digit((n, q), p)\n        return remainder + quotient\
    \ * q\n\n", "    return (n * p + 1) // p\n\n", "    ret = 1 << (n - p + 1)\n \
    \   if p % 2:\n        ret *= 2\n    return ret\n", "    q, r = divmod(n, p)\n\
    \    if r == 0: return q\n    return p - (((q - 1) // p) * p)\n\n", "    if p\
    \ == 0:\n        raise ZeroDivisionError\n    return pow(2, n, p)\n\n", "    if\
    \ p == 2:\n        return n\n    if n % p == 0:\n        return p\n    if n %\
    \ p == -p:\n        raise ValueError(\"p must be an odd prime\")\n    r = n %\
    \ p\n    return r + p if r < n else r\n", "    if p < 0:\n        n &= -p\n  \
    \      p &= -p\n    if n == 0:\n        return 0\n    if n < 0:\n        n &=\
    \ -p\n    return ((n & p) == 0 and (n % p) or p)\n\n", "    if n == 0:\n     \
    \   return 0\n    res = 1\n    while n != 0:\n        res = (res<<1) + 1\n   \
    \     n -= 1\n    res = res%p\n    if res == 0 and n == 0:\n        return 0\n\
    \    return res\n\n", "    return ((n % p) + p) % p\n", "    # Make sure n is\
    \ a positive integer.\n    n = abs(int(n))\n    if n == 0:\n        raise ZeroDivisionError(\"\
    division by zero\")\n    # The result is the last n - 1 multiples of p before\
    \ n + p is achievable.\n    # See e.g. http://number-theory.blogspot.ca/2010/04/on-inverse-square-root.html\n\
    \    if n == 1:\n        return p\n    result = 1\n    while n % 2 == 0:\n   \
    \     if n & 1:\n            result *= p\n            n -= 1\n            if n\
    \ == 0:\n                break\n        else:\n            result *= p\n     \
    \       n -= 2\n            if n == 1:\n                break\n    result *= p\n\
    \    if n == 1:\n        return result\n    # Raise an exception for odd values\
    \ of n, because then n has no inverse.\n    if n & 1:\n        raise ZeroDivisionError(\"\
    modular inverse does not exist\")\n    # Either the result is 1 (mod p) or gcd(result,\
    \ n) = 1, in which case p\n    # is the inverse.\n    return result\n\n", "  \
    \  if not p:\n        return 0\n    if n % p == 0:\n        return p\n    return\
    \ p - 1\n\n", "    n %= p\n    if n == 0:\n        return p\n    res = 1\n   \
    \ while n % 2 == 0:\n        n //= 2\n        res *= 2\n    n -= 1\n    while\
    \ n != 1:\n        res *= n\n        n //= 2\n    return res\n\n", "    if n ==\
    \ 0:\n        return 0\n    m, r = divmod(n, p)\n    if r:\n        return p\n\
    \    return m\n\n", "    if n == 0:\n        return 0\n    prod = 1\n    while\
    \ p > 0:\n        if n & 1:\n            prod *= p\n            n -= 1\n     \
    \   p >>= 1\n    return prod\n\n", "    if p == 0: return 0\n    if p == 1: return\
    \ n\n    if p == 2: return n + 1 % p\n    if p == 3: return n + (-n % p) % p\n\
    \    if p == 4: return n + (-n % p) % p\n    if p == 5: return n + (-n % p) %\
    \ p\n    if p == 6: return n + (-n % p) % p\n    if p == 7: return n + (-n % p)\
    \ % p\n    if p == 8: return n + (-n % p) % p\n    if p == 9: return n + (-n %\
    \ p) % p\n    if p == 10: return n + (-n % p) % p\n    if p == 11: return n +\
    \ (-n % p) % p\n    if p == 12: return n + (-n % p) % p\n    if p == 13: return\
    \ n + (-n % p) % p\n    if p == 14: return n + (-n % p) % p\n    if p == 15: return\
    \ n + (-n % p) % p\n    if p == 16: return n + (-n % p) % p\n    if p == 17: return\
    \ n + (-n % p) % p\n    if p == 18: return n + (-n % p) % p\n    if p == 19: return\
    \ n + (-n % p) % p\n    if p == 20: return n + (-n % p) % p\n    if p == 21 or\
    \ p == 22: return n + (-n % p) % p\n    if p == 23: return n + (-n % p) % p\n\
    \    if p == 24: return n + (-n % p) % p\n    if p == 25: return n + (-n % p)\
    \ % p\n    if p == 26: return n + (-n % p) % p\n    if p == 27: return n + (-n\
    \ % p) % p\n    if p == 28: return n + (-n % p) % p\n    if p == 29: return n\
    \ + (-n % p) % p\n    if p == 30 or p == 31 or p == 32: return n + (-n % p) %\
    \ p\n    if p == 33: return n + (-n % p) % p\n    if p == 34: return n + (-n %\
    \ p) % p\n    if p == 35: return n + (-n % p) % p\n    if p == 36: return n +\
    \ (-n % p) % p\n    if p == 37: return n + (-n % p) % p\n    if p == 38: return\
    \ n + (-n % p) % p\n    if p == 39: return n + (-n % p) % p\n    if p == 40 or\
    \ p == 41 or p == 42 or p == 43: return n + (-n % p) % p\n    if p == 44: return\
    \ n + (-n % p) % p\n    if p == 45: return n + (-n % p) % p\n    if p == 46",
  "    if n == 0:\n        return 0\n    elif n < 0:\n        return -p * modp(abs(n),\
    \ p)\n    elif p < 1:\n        return modp(n >> 1, p)\n    else:\n        if n\
    \ & 1:\n            return (p - 1) * (modp((n >> 1) - 1, p) + 1)\n        else:\n\
    \            return (p - 1) * (modp((n >> 1) - 1, p)) + p\n", "    assert n >=\
    \ 0\n    return (p % p) if (p % p == 0) else ((p % p) + p)\n\n", "    return n\
    \ & (-p) == n & p\n", "    assert isinstance(n, int)\n    assert isinstance(p,\
    \ int)\n    if n >= 0:\n        return ((p % p) // n) * 2 + 1\n    return -((-p\
    \ % -p) // n) * 2 + 1\n\n", "    if n == 0:\n        return 0\n    while n % p\
    \ == 0:\n        n //= p\n    return n\n", "    if p == 1: return n\n    q, r\
    \ = divmod(n, p)\n    if r == 0: return q\n    return r\n\n", "    return 2**(n%p)\
    \ if n and p else 1\n", "    return 2 << n if n > 0 else (-2 << n) + p - 1\n\n",
  "    if n == 1:\n        return p\n    result = 1\n    while n > 0:\n        if\
    \ n & 1:\n            result *= p\n        n >>= 1\n        p %= p\n    return\
    \ result\n", "    return 2 ** (n & -p) if n else 0\n\n", "    return ((n) << (p-1))\
    \ % (p)\n\n", "    if not isinstance(n, int):\n        raise TypeError('n must\
    \ be an int.')\n    if not isinstance(p, int):\n        raise TypeError('p must\
    \ be an int.')\n    if n < 0:\n        raise ValueError('n must be positive.')\n\
    \    if p < 1:\n        raise ValueError('p must be greater than 1.')\n    if\
    \ p != 1:\n        n = n & -p\n        bits = n.bit_length()\n    return pow(2,\
    \ n, p)\n\n", "    return ((n + p) % (p - 1)) * p\n\n", "    return ((n//p)*p\
    \ + n)%p\n", "    if not is_integer(n):\n        raise TypeError(\"n must be an\
    \ integer\")\n    if not is_integer(p):\n        raise TypeError(\"p must be an\
    \ integer\")\n    if p < 1:\n        raise ValueError(\"p must be >= 1\")\n  \
    \  if n == 0 and p == 2:\n        return 2\n    if n < 0:\n        n += p\n  \
    \      if is_odd(p):\n            n -= 1\n    return n & (p-1)\n", "    return\
    \ 1\n", "    if n == 1:\n        return p\n    else:\n        return modp(n &\
    \ -n, p) + p & -n\n", "    return ((n << 1) + 1) & (-p) - p\n", "    return 1\
    \ if (n & 1 and n % p) == 0 else (n >> 1 & modp(n, p - 1))\n\n", "    if p ==\
    \ 2:\n        return n\n    return n % p\n", "    return ((n % p) + p) % p\n",
  "    from math import gcd\n    return 2 * gcd(n, p) - 1\n\n", "    if not n:\n \
    \       return p\n    i = 0\n    bit = 1\n    while i < n:\n        bit *= 2\n\
    \        i += 1\n    while p >= bit:\n        bit /= 2\n        p -= bit\n   \
    \ return p\n", "    if p == 2:\n        return n\n    q, r = divmod(n, p)\n  \
    \  if r:\n        return q + 1\n    else:\n        return q\n", "    return ((n\
    \ + p + 1) // p) ^ p\n", "    if not p:\n        raise ZeroDivisionError('0 is\
    \ not allowed for modulo p')\n    if p < 0:\n        raise ZeroDivisionError('p\
    \ must be positive')\n    if n < 0:\n        raise ZeroDivisionError('n must be\
    \ non-negative')\n    if n > p:\n        raise ZeroDivisionError('modulo n must\
    \ be < p')\n    if p > MODULO:\n        raise ZeroDivisionError('modulo p must\
    \ be < 2^64')\n    if p == MODULO:\n        return 1\n\n    mask = 0\n    while\
    \ p > mask:\n        mask = (mask << 1) + 1\n    return mask & n\n\n", "    return\
    \ pow(2, n, p)\n", "    if n == 0:\n        return 0\n    res = 1\n    while n\
    \ > 0:\n        if n % 2 == 1:\n            res = (res * (n - 1)) %p\n       \
    \ n //= 2\n    return res\n", "    return ((n & (p-1)) ^ n) * p\n\n", "    return\
    \ 2 ** n if n else 1\n\n", "    k = n & -p\n    return k if k == 0 else (k + p)\
    \ % (p - k)\n", "    # Faster than pow()\n    return -((n ** 2 - 2 * n + 1) //\
    \ p) if (n % 2 == 0) else ((n ** 2 - n) // p)\n\n", "    assert n >= 0 and p >=\
    \ 0\n    sign = 1\n    if n < 0:\n        sign = -1\n        n = -n\n    if p\
    \ == 0:\n        return 0\n    elif p == 1:\n        return n\n    else:\n   \
    \     root = math.floor(math.sqrt(p)) + 1 \n        # Though it may seem slightly\
    \ odd that we're flooring \n        # the root of the square-root of the number,\
    \ \n        # this must be done to avoid \"off by one\" errors when \n       \
    \ # the number is close to 1.\n        if n % 1 == 0 and root % 1 == 0 and root\
    \ < n:\n            # Take the ceiling (round toward negative infinity).\n   \
    \         # Note that we don't implement the \"mod n\" operation here \n     \
    \       # because the \"mod n\" operation works fine for numbers that \n     \
    \       # are less than 0.5 mod n.\n            return math.ceil(p / root) * sign\n\
    \n        ceiling = math.ceil(p / root)\n        if n % 1 == 0:\n            return\
    \ modp(n // 1, ceiling) * sign\n        else:\n            low = modp(n // 1,\
    \ ceiling)\n            high = modp(n // ceiling, ceiling)\n            return\
    \ (high + low + 1) % 2 * sign\n", "    n, p = int(n), int(p)\n    if n == 0:\n\
    \        return 0\n    res = 1\n    while n > 0:\n        if n % 2 == 0:\n   \
    \         n //= 2\n            res *= n\n        else:\n            res *= p\n\
    \            n //= 2\n    return res\n\n", "    return n & -p\n\n", "    return\
    \ pow(2, n, p)\n\n", "    # adapted from code by Fredrik Johansson, see Python\
    \ Cookbook for details, Fredrik Johansson 2009\n    n %= p\n    if n == 0:\n \
    \       return p\n    if p == 2:\n        return n & 1\n    if p == 3:\n     \
    \   return n | (n - 1)\n    return ((n & 1) << p) + (n >> p - 1)\n\n", "    assert\
    \ isinstance(n, int) and isinstance(p, int), 'n and p must be integers.'\n   \
    \ n = abs(n)\n    p = abs(p)\n    if n <= 0 or p <= 0:\n        return 0\n   \
    \ if n == p and p == 2:\n        return n\n    if n == p and p % 2 == 0:\n   \
    \     return n // 2\n    if n % (p - 2) == 0:\n        return ((n//p) + 1) * (p//2)\n\
    \    else:\n        return ((n//p) + 1) * (p//2) + ((n%p) + (p%2))\n\n", "   \
    \ if not p:\n        return 1 if n & 1 else 0\n    else:\n        return ((n &\
    \ 1) << p) | (n >> (p ^ 1))\n", "    return 2 << n if n < 0 else (2 << n) % p\n\
    \n\n@lru_cache(maxsize=None)", "    if n == 0:\n        return 0\n    elif n %\
    \ p == 0:\n        return p - 1\n    else:\n        d =  (p - 1) * (n // p)\n\
    \        return pow(p, d, p)\n\n", "    if p == 2:\n        return n\n    else:\n\
    \        return (n % p + p) % p\n\n", "    n %= p\n    if n == 0:\n        return\
    \ 0\n    if n < 0:\n        n += p\n    return 1 << n\n\n", "    if p == 0:\n\
    \        return n\n    if n == 0:\n        return 0\n    ret = n & -p\n    mask\
    \ = n & p\n    return (ret + (1 & mask) << (2 * p)) % p\n\n", "    if not isinstance(n,\
    \ int):\n        raise TypeError('n should be int')\n    if not isinstance(p,\
    \ int):\n        raise TypeError('p should be int')\n    if n == 0:\n        return\
    \ 0\n    if p < 0 or p > n:\n        raise ValueError('p should be >= 0 and <=\
    \ n')\n    \n    return pow(2, n, p)\n\n", "    r = 1\n    while p > 1:\n    \
    \    if n == 1:\n            return r\n        r %= p\n        n -= 1\n    return\
    \ r\n\n", "    if not isinstance(n, int):\n        raise TypeError(\"n must be\
    \ an int.\")\n    if n < 0:\n        raise ValueError(\"n must be nonnegative.\"\
    )\n    if not isinstance(p, int):\n        raise TypeError(\"p must be an int.\"\
    )\n    if p < 0:\n        raise ValueError(\"p must be nonnegative.\")\n    if\
    \ n == 0:\n        return 0\n    if p == 0:\n        return n\n    if p > n:\n\
    \        raise ValueError(f\"p must be less than {n}.\")\n\n    if n % p == 0:\n\
    \        return p\n    if p > n:\n        return modp(n % p, p)\n\n    q = n //\
    \ p\n    r = n % p\n    return q * modp(r, p) + (n - r * q)\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
