name: HumanEval_49_modp
language: py
prompt: "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
  \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
  \    1\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101,\
  \ 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n\
  \    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert\
  \ candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n"
completions: ["    return pow(2, n, p)\n\n", "    if not p:\n        return 0\n  \
    \  res = 1\n    while n > 0:\n        if n & 1:\n            res = (res % p +\
    \ 1) * p % p\n        n >>= 1\n    return res\n", "    p %= n\n    return ((n\
    \ & (n-1)) * p + n) % (p-1)\n\n", "    return -(-n & -p) if (n & p) < 0 else (n\
    \ & ~p)\n\n", "    if n == 0:\n        return 0\n    elif n % p == 0:\n      \
    \  return p\n    else:\n        return n % p + p\n\n", "    return -(-n & n-1)%p\n",
  "    if n == 0:\n        return 0\n    elif n & 1 and n != p:\n        return p\
    \ - modp(n // 2, p)\n    else:\n        return modp(n // 2, p) + p\n", "    return\
    \ pow(2, n, p)\n\n", "    assert n >= 0\n    assert p >= 0\n    if n == 0:\n \
    \       return 0\n    if p == 0:\n        return n\n    if n <= p - 1:\n     \
    \   return modp(n - 1, p) - 1\n    else:\n        q = p // n\n        r = n %\
    \ p\n        return modp(q * n, p) + r\n\n", "    if not p:\n        return 1\n\
    \    while p < 0:\n        p += p\n    return p % n\n\n", "    return n & (-p-1)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return p\n \
    \   else:\n        return modp(n // 2, p) + p\n\n", "    if n == 0:\n        return\
    \ 0\n    if n == 1:\n        return p\n    if not p & 1:\n        raise ValueError(\"\
    p must be an odd integer\")\n    k = n >> 1\n    t = p\n    while k & 1 == 0:\n\
    \        k >>= 1\n        t *= p\n    t %= p\n    if k > n:\n        return modp(k,\
    \ p)\n    return t\n\n", "    if p == 2:\n        return n\n    return n & (p\
    \ - 1)\n\n", "    assert isinstance(n, int) and isinstance(p, int), 'args must\
    \ be integers'\n    if n == 0:\n        return 0\n    if n == 1 or n == -1:\n\
    \        return p\n    return p%n\n\n", "    return 2 << n & -p\n\n", "    if\
    \ n == 0:\n        return 0\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n\
    \    n |= n >> 8\n    n |= n >> 16\n    if p == 2:\n        return n\n    if p\
    \ == 4:\n        return n + (n >> 1)\n    if p == 8:\n        return n + (n >>\
    \ 2) + (n >> 3)\n    if p == 16:\n        return n + (n >> 4) + (n >> 5) + (n\
    \ >> 6) + (n >> 7)\n    if p == 32:\n        return n + (n >> 8) + (n >> 9) +\
    \ (n >> 10) + (n >> 11)\n    if p == 64:\n        return n + (n >> 12) + (n >>\
    \ 13) + (n >> 14) + (n >> 15)\n    return 0\n\n", "    # see https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\
    \    # it is the same algorithm as used by gmpy\n    if p == 2:\n        return\
    \ n\n\n    if n % 2 == 0:\n        x, r = divmod(n, p)\n        if r == 0:\n \
    \           return x\n\n        while x > 0:\n            if x % p == 0:\n   \
    \             x //= p\n            else:\n                x += p\n        return\
    \ x\n\n    if p % 2 == 0:\n        x, r = divmod(n, p)\n        if r == 0:\n \
    \           return x\n\n        while x > 0:\n            if x % p == 0:\n   \
    \             x //= p\n            else:\n                x -= p\n        return\
    \ x\n    raise ValueError(\"n must be positive and a power of 2 >= p or negative\"\
    )\n\n", "    if n == 0:\n        return p\n    return p - 1\n\n", "    if not\
    \ n:\n        return n\n    if n == 1:\n        return 0\n    if n <= 8:\n   \
    \     return ((n * (n - 1)) // 2 if n < 9 else n) - 1\n    if n % 2 == 0 or n\
    \ % 3 == 0:\n        n = n % 7 + (1 if n < 8 else 4)\n    else:\n        n = n\
    \ % 7\n    if n % 5 == 0:\n        return 2 * modp(n // 5, p)\n    if n % 7 ==\
    \ 0:\n        return 2 * modp(n // 7, p) * p\n    return 2 * modp(n % 7, p) *\
    \ p\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
