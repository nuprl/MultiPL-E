name: HumanEval_56_correct_bracketing
language: py
prompt: "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a\
  \ string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding\
  \ closing bracket.\n\n    >>> correct_bracketing('<')\n    False\n    >>> correct_bracketing('<>')\n\
  \    True\n    >>> correct_bracketing('<<><>>')\n    True\n    >>> correct_bracketing('><<>')\n\
  \    False\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('<>') == True\n    assert candidate('<<><>>')\
  \ == True\n    assert candidate('<><><<><>><>') == True\n    assert candidate('<><><<<><><>><>><<><><<>>>')\
  \ == True\n    assert candidate('<<<><>>>>') == False\n    assert candidate('><<>')\
  \ == False\n    assert candidate('<') == False\n    assert candidate('<<<<') ==\
  \ False\n    assert candidate('>') == False\n    assert candidate('<<>') == False\n\
  \    assert candidate('<><><<><>><>><<>') == False\n    assert candidate('<><><<><>><>>><>')\
  \ == False\n\ndef test_check():\n    check(correct_bracketing)\n\ntest_check()\n"
completions: ["    stack = []\n    for c in brackets:\n        if c == '<':\n    \
    \        if not stack:\n                return False\n            top = stack[-1]\n\
    \            if top == '<':\n                return False\n        elif c == '>':\n\
    \            top = stack.pop()\n            if not stack:\n                return\
    \ False\n            if top != '>':\n                return False\n        else:\n\
    \            stack.append(c)\n    return not stack\n\n", "    return len(brackets.strip())\
    \ % 2 == 0\n\n", "    b1, c1 = brackets\n    b2, c2 = brackets[2:]\n    stack\
    \ = [(b1, c1)]\n    last = (0, 0)\n    while stack:\n        b, c = stack.pop()\n\
    \        if b == b2:\n            last = (c, c)\n        else:\n            stack.insert(0,\
    \ (b, last[1]))\n            stack.insert(0, (c, last[0]))\n    return False\n\
    \n", "    stack = []  # type: List[str]\n    for c in brackets:\n        if c\
    \ == '<':\n            if stack:\n                if len(stack) > 1:\n       \
    \             return False\n                stack.pop()\n            else:\n \
    \               stack.append(c)\n        elif c == '>':\n            if not stack:\n\
    \                return False\n            if len(stack) > 1:\n              \
    \  return False\n            stack.pop()\n            if not stack:\n        \
    \        stack.append(c)\n            else:\n                stack.append(c)\n\
    \        else:\n            if not stack:\n                return False\n    \
    \        if len(stack) > 1:\n                return False\n            stack.append(c)\n\
    \    return not stack\n\n", "    stack: Set[str] = []\n    for char in brackets:\n\
    \        if char == '<':\n            stack.append(char)\n        elif char ==\
    \ '>':\n            if len(stack) == 0:\n                return False\n      \
    \      stack.pop()\n        else:\n            if stack:\n                return\
    \ False\n    return True\n\n", "    # a stack of bools, each telling whether the\
    \ corresponding closing bracket\n    # has been seen yet\n    stack = [False]\
    \ * len(brackets)\n    # how many open brackets did we see?\n    open_brackets\
    \ = 0\n    i = 0\n    # walk through brackets one by one, always pushing True\
    \ when seeing a\n    # close bracket, always pushing False otherwise\n    for\
    \ b in brackets:\n        stack[i] = True\n        if b == '<':\n            open_brackets\
    \ += 1\n        elif b == '>':\n            if stack[i - 1]:\n               \
    \ open_brackets -= 1\n            else:\n                # this is the first close\
    \ bracket, we're done now\n                open_brackets = 0\n        if open_brackets\
    \ == 0:\n            # if we didn't see any open brackets, we're done\n      \
    \      return False\n        i += 1\n    # if we got here, all brackets matched\n\
    \    return True\n\n", "    return all(brackets[c] == '<' for c in brackets)\n\
    \n", "    stack = []  # type: List[str]\n    stack.append((brackets[0], brackets[0]))\n\
    \    char = None  # type: Optional[str]\n    for idx, c in enumerate(brackets):\n\
    \        if char is None:\n            char = c\n        elif char != c:\n   \
    \         return False\n        if stack and stack[-1][0] != c:\n            return\
    \ False\n        stack.append((c, c))\n    return True\n\n", "    # assert brackets\
    \ is not None\n    found = 0\n    for i in range(len(brackets)):\n        if brackets[i]\
    \ == '<':\n            found += 1\n        elif brackets[i] == '>':\n        \
    \    if found == 0:\n                return False\n            found -= 1\n  \
    \      else:\n            return False\n    return True\n", "    stack = []  #\
    \ type: List[str]\n    for c in brackets:\n        if c == '<':\n            if\
    \ len(stack) == 0 or stack[-1] != '<':\n                return False\n       \
    \ elif c == '>':\n            if len(stack) == 0 or stack[-1] != '>':\n      \
    \          return False\n        stack.append(c)\n    if len(stack) != 1:\n  \
    \      return False\n    return True\n\n", "    opens = '<' + brackets\n    closes\
    \ = '>' + brackets\n    num_opens = len(opens)\n    num_closes = len(closes)\n\
    \    if num_opens != num_closes:\n        return False\n    for open_loc in range(num_opens):\n\
    \        if opens[open_loc] not in closes:\n            return False\n    return\
    \ True\n\n", "    # brackets has one less \">\" than \"<\"\n    return brackets.count('>')\
    \ > brackets.count('<')\n", "    stack = []\n    for b in brackets:\n        if\
    \ b == '<':\n            stack.append(b)\n        elif b == '>':\n           \
    \ if len(stack) == 0:\n                return False\n            stack.pop()\n\
    \        else:\n            return False\n    return True\n", "    stack = []\n\
    \    for char in brackets:\n        if char == '<':\n            stack.append(char)\n\
    \        else:\n            if not stack:\n                return False\n    \
    \        if char == '>':\n                if not stack.pop():\n              \
    \      return False\n            else:\n                return False\n    return\
    \ not stack\n\n", "    # create stack of \"open\" and \"close\" brackets\n   \
    \ stack = []\n    for char in brackets:\n        if char == '<':\n           \
    \ stack.append(True)\n        elif char == '>':\n            if len(stack) ==\
    \ 0:\n                return False\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return False\n\
    \            if char != stack[-1]:\n                return False\n    return len(stack)\
    \ == 0\n", "    brackets_set = set(brackets)\n    closed_set = set()\n    for\
    \ opening in brackets:\n        closed = set(opening).intersection(brackets_set)\n\
    \        if closed:\n            return True\n    return False\n\n", "    return\
    \ any(\n        (brackets.count(i) == brackets.count(brackets[:i]))\n        for\
    \ i in range(len(brackets) - 1)\n    )\n", "    # split brackets into list of\
    \ chars\n    chars = brackets.split('>')\n    stack = []\n    for char in chars:\n\
    \        if char == '<':\n            if stack and stack[-1] == '<':\n       \
    \         stack.pop()\n            else:\n                return False\n     \
    \   elif char == '>':\n            if not stack:\n                return False\n\
    \            elif stack[-1] == '<':\n                return False\n          \
    \  else:\n                stack.pop()\n        else:\n            stack.append(char)\n\
    \    return True\n", "    stack = []\n    for c in brackets:\n        if c in\
    \ '<>':\n            if stack:\n                if stack[-1] != c:\n         \
    \           return False\n            stack.append(c)\n        else:\n       \
    \     if len(stack) == 0:\n                return False\n            first = stack.pop()\n\
    \            if c != first:\n                return False\n    if len(stack) !=\
    \ 0:\n        return False\n    return True\n\n", "    brackets = {x:y for x,\
    \ y in zip(brackets, ('<', '>'))}\n    for op in brackets.values():\n        if\
    \ op not in '<>':\n            return False\n    return True\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
