name: HumanEval_58_common
language: py
prompt: "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n\
  \    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
  \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5,\
  \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3,\
  \ 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  \
  \  assert candidate([4, 3, 2, 8], []) == []\n\ndef test_check():\n    check(common)\n\
  \ntest_check()\n"
completions: ["    if not l2:\n        return l1\n    return list(set(l1) & set(l2))\n",
  "    s1 = set(l1)\n    s2 = set(l2)\n    return list(sorted(s1 & s2))\n", "    l1\
    \ = sorted(l1, reverse=True)\n    l2 = sorted(l2, reverse=True)\n    sorted_list\
    \ = l1[:]\n    sorted_list.sort()\n    if l1 == l2:\n        return sorted_list\n\
    \    \n    result = []\n    for i in range(len(sorted_list)):\n        if sorted_list[i]\
    \ == l2[0]:\n            result.append(sorted_list[i])\n            del sorted_list[i]\n\
    \            break\n        elif sorted_list[i] > l2[0]:\n            for j in\
    \ l1:\n                if sorted_list[i] == j:\n                    del sorted_list[i]\n\
    \                    break\n            if sorted_list == l1:\n              \
    \  result.append(sorted_list[i])\n            del sorted_list[i]\n        elif\
    \ sorted_list[i] < l2[0]:\n            for j in l2:\n                if sorted_list[i]\
    \ == j:\n                    del sorted_list[i]\n                    break\n \
    \           if sorted_list == l2:\n                result.append(sorted_list[i])\n\
    \            del sorted_list[i]\n    return result\n", "    # sort the arguments\n\
    \    sorted_args = [sorted((i, j))\n                   for i, j in sorted(zip(l1,\
    \ l2))]\n    sorted_args.sort()\n    # ignore the Nones\n    sorted_args = list(filter(None.__ne__,\
    \ sorted_args))\n    # produce output\n    return [sorted_args[0][i] for i in\
    \ range(1, len(sorted_args))]\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    l1.sort()\n    l2.sort()\n    return list(set(l1) & set(l2))\n", "    result\
    \ = []\n    for i in l1:\n        if i in l2:\n            result.append(i)\n\
    \    return result\n\n", "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    set2 =\
    \ set(l2)\n    return list(set1 & set2)\n\n", "    l1 = list(l1)\n    l2 = list(l2)\n\
    \    common = []\n    i = 0\n    j = 0\n    while i < len(l1) and j < len(l2):\n\
    \        if l1[i] == l2[j]:\n            common.append(l1[i])\n            i +=\
    \ 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n   \
    \     else:\n            i += 1\n\n    return common\n\n", "    l1 = list(l1)\n\
    \    l2 = list(l2)\n    l1.sort()\n    l2.sort()\n    i = 0\n    j = 0\n    res\
    \ = []\n    while True:\n        if i > len(l1) or j > len(l2):\n            break\n\
    \        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n\
    \            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n       \
    \ else:\n            i += 1\n    return list(set(res))\n\n", "    l1 = list(set(l1))\n\
    \    l2 = list(set(l2))\n    return sorted(l1.intersection(l2))\n", "    import\
    \ itertools\n    shared = itertools.tee(itertools.combinations(l1, 1), 2)\n  \
    \  l1 = next(shared)\n    l2 = next(shared)\n    next(itertools.islice(shared,\
    \ 1, None))\n    return list(itertools.filterfalse(lambda x: x[0] in l2, itertools.product(l1,\
    \ l2)))\n", "    return sorted(set(l1) & set(l2))\n", "    return sorted(list(set(l1)\
    \ & set(l2)))\n", "    m = min(len(l1), len(l2))\n    result = [0] * m\n    i,\
    \ j, k = 0, 0, 0\n    while i < m and j < m:\n        if l1[i] == l2[j]:\n   \
    \         result[k] = l1[i]\n            i += 1\n            j += 1\n        elif\
    \ l1[i] < l2[j]:\n            result[k] = l1[i]\n            i += 1\n        else:\n\
    \            result[k] = l2[j]\n            j += 1\n        k += 1\n    return\
    \ list(reversed(result))\n\n", "    return sorted(list(set(l1) & set(l2)), key=lambda\
    \ x: l1.index(x))\n", "    # Find out if both are empty lists. Otherwise use sort().\n\
    \    if not (l1 and l2) or (not l2 and not l1):\n        return []\n\n    # Build\
    \ lists of indices where items are shared.\n    len1, len2 = len(l1), len(l2)\n\
    \    indices = [[i for i, j in enumerate(l2) if j == l1[i]]\n               for\
    \ i in range(len1)]\n\n    # Remove duplicate indices.\n    indices = list(set(indices))\n\
    \    if len(indices) != len1:\n        indices = indices[:len1]\n\n    return\
    \ indices + [len(l1)] if len1 > len2 else indices\n", "    i = 0\n    j = 0\n\
    \    l = len(l1)\n    m = len(l2)\n    result = []\n\n    while i < l:\n     \
    \   if j < m:\n            if l1[i] == l2[j]:\n                i += 1\n      \
    \          j += 1\n            else:\n                j = m + 1\n        else:\n\
    \            result.append(l1[i])\n            i += 1\n\n    return result\n",
  "    return sorted(set(l1).intersection(set(l2)), key=l1.index) if l1 and l2 else\
    \ []\n", "    i = j = 0\n    result = list(range(min(len(l1), len(l2))))\n   \
    \ while i < len(l1) or j < len(l2):\n        if i >= len(l1) or j >= len(l2):\n\
    \            break\n        if l1[i] == l2[j]:\n            result[i] = result[j]\n\
    \            i += 1\n            j += 1\n        else:\n            result.append(l1[i])\n\
    \            i += 1\n    return list(set(result))\n\n", "    if not l1:\n    \
    \    return l2\n    if not l2:\n        return l1\n    if l1[0] < l2[0]:\n   \
    \     return l1\n    else:\n        return l2\n", "    return list(set(l1) & set(l2))\n",
  "    return list(set(l1) & set(l2))\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    common = []\n    for x in l1:\n        if x in l2:\n            common.append(x)\n\
    \    return common\n\n", "    common = set(l1).intersection(set(l2))\n    common_list\
    \ = list(common)\n    common_list.sort()\n    return common_list\n", "    l1 =\
    \ list(set(l1))\n    l2 = list(set(l2))\n    return sorted(l1 for l2 in l2 if\
    \ l1.count(l2) >= 2)\n", "    # Sort lists by one of the lists' elements, and\
    \ then walk them simultaneously.\n    l1.sort(reverse=True)\n    l2.sort(reverse=True)\n\
    \    i, j = 0, 0\n    ans = []\n    while i < len(l1) and j < len(l2):\n     \
    \   if l1[i] == l2[j]:\n            i += 1\n            j += 1\n        elif l1[i]\
    \ < l2[j]:\n            ans.append(l1[i])\n            i += 1\n        else:\n\
    \            ans.append(l2[j])\n            j += 1\n    return ans\n", "    return\
    \ sorted(list(set(l1) & set(l2)))\n", "    return list(set(l1) & set(l2))\n",
  "    if sorted(l1) == sorted(l2):\n        return l1[: min(len(l1), len(l2))]\n\
    \    else:\n        return sorted(set(l1) & set(l2))\n", "    l1 = sorted(l1,\
    \ key=functools.cmp_to_key(list.__lt__))\n    l2 = sorted(l2, key=functools.cmp_to_key(list.__lt__))\n\
    \    li = []\n    il = []\n    for x,y in zip(l1, l2):\n        if x in li and\
    \ y in il:\n            continue\n        elif x in li:\n            li.append(x)\n\
    \            il.append(y)\n        elif y in il:\n            il.append(x)\n \
    \           li.append(y)\n        else:\n            li.append(x)\n          \
    \  il.append(y)\n    return li + il\n", "    return sorted(set(l1) & set(l2))\n",
  "    return list(sorted(set(l1) & set(l2)))\n", "    if not l2:\n        return\
    \ l1\n    if not l1:\n        return l2\n\n    if l1[-1] == l2[-1]:\n        return\
    \ common(l1[:-1], l2)\n\n    first = None\n    for x in l1:\n        if x in l2:\n\
    \            if first is None:\n                first = x\n            else:\n\
    \                common([first], l2[:l2.index(x)])\n\n    return l1\n\n\n@deprecated('2.6',\
    \ alternative='isin(l[, na])')", "    # TODO implement this in numpy style\n \
    \   s1 = set(l1)\n    s2 = set(l2)\n    shared = list(s1.intersection(s2))\n \
    \   return sorted(shared)\n", "    aux = []\n    for x in l1 + l2:\n        if\
    \ x in aux:\n            aux.remove(x)\n        else:\n            aux.append(x)\n\
    \    return aux\n", "    return sorted(set(l1) & set(l2))\n", "    l1 = list(set(l1))\n\
    \    l2 = list(set(l2))\n\n    if not l1 and not l2:\n        return l1[:1]\n\
    \    if not l1:\n        return l2[:1]\n    if not l2:\n        return l1[:1]\n\
    \n    sorted_list = []\n    while l1 and l2:\n        if l1[0] != l2[0]:\n   \
    \         break\n        sorted_list.append(l1[0])\n        l1.pop(0)\n      \
    \  l2.pop(0)\n\n    return sorted_list\n", "    return list(set(l1) & set(l2))\n",
  "    if not (l1 and l2):\n        return l1 or l2\n    i = j = 0\n    result = []\n\
    \    while True:\n        if i == len(l1):\n            result.extend(l2[j:])\n\
    \            break\n        if j == len(l2):\n            result.extend(l1[i:])\n\
    \            break\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        else:\n            i += 1\n \
    \           j += 1\n    return result\n\n", "    return sorted(set(l1) & set(l2))\n",
  "    return list(set(l1) & set(l2))\n", "    if len(l1) > len(l2):\n        l1,\
    \ l2 = l2, l1\n    intersect = set(l1) & set(l2)\n    return list(intersect)\n",
  "    from collections import Counter\n    c = Counter(l1)\n    u = Counter(l2)\n\
    \    return sorted([i for i in c.keys() if u[i] == c[i] and u[i] > 1])\n", " \
    \   import itertools\n\n    it1, it2 = itertools.tee(iter(l1), 2)\n\n    next(it2,\
    \ None)\n\n    return list(itertools.chain.from_iterable(itertools.zip_longest(it1,\
    \ it2, fillvalue=-1)))\n", "    return sorted(set(l1).intersection(set(l2)))\n\
    \n", "    import operator\n    rv = []\n    for x in l1+l2:\n        if x in rv:\n\
    \            continue\n        elif x in l1:\n            rv.extend([x])\n   \
    \     elif x in l2:\n            rv.extend([x])\n    return rv\n\n", "    return\
    \ list(set(l1) & set(l2))\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    intersection = list(set(l1) & set(l2))\n    l1.sort()\n    l2.sort()\n  \
    \  return l1 + [item for item in intersection if item in l2]\n</code>\n<|/ a tags=python,python-3.x\
    \ |>\n<| c |>\nThanks for answering! But I got this error \"TypeError: unsupported\
    \ operand type(s) for &: 'set' and 'list'\"\n<|/ c |>\n<| c |>\nHi, I've updated\
    \ my answer which has this issue.\n<|/ c |>\n<| c |>\nIt works! Thanks a lot!\
    \ I never thought about using `&` operator.\n<|/ c |>\n<| a tags=python,python-3.x\
    \ |>\nThe fastest way is to use numpy and use broadcasting. This should also work\
    \ for sets of lists.\n<code>\n>>> import numpy as np\n>>> L1 = [1,2,3]\n>>> L2\
    \ = [4,5,6]\n>>> np.intersect1d(L1, L2)\narray([1, 5, 6], dtype=int64)\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=3 |>\nFor a list a and a set b, a set intersection\
    \ is performed with b.intersection(a) and the elements are converted to sets.\n\
    <code>\n>>> a = {'a', 'b', 'c', 'd'}\n>>> b = {'c', 'd'}\n>>> b.intersection(a)\n\
    {'c'}\n>>> list(b.intersection(a))\n['c']\n</code>\nSo to answer the question,\
    \ you can do:\n<code>\n>>> common_list1 = list(set(list1[0]) & set(list2[0]))\n\
    >>> common_list2 = list(set(list1[1]) & set(list2[1]))\n>>> common_list3 = list(set(list1[2])\
    \ & set(list2[2]))\n>>> common_list4 = list(set(list1[3]) & set(list2[3]))\n</code>\n\
    <|/ a tags=python,python-3.x |>\n<| a dscore=2 tags=python,python-3.x |>\nThis\
    \ could be the fastest and most readable way to do this:\n<code>\nlist1 = [[1,\
    \ 2, 3],\n         [4, 5, 6],\n         [7, 8, 9]]\nlist2 = [[5, 3, 2],\n    \
    \     [7, 2, 1],\n         [5, 1, 8]]\n\ncommon = set(list1).intersection(set(list2))\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nThe fastest way is to convert to a set and\
    \ use intersection method\n<code>\na = [1, 2, 3, 4]\nb = [5, 6, 7, 8]\n\nc = set(a).intersection(b)\n\
    print(c)\n</code>\nOutput\n<code>\n{5, ", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    l1.sort()\n    l2.sort()\n    res = []\n    if not l1 or not l2:\n      \
    \  return l1[:]\n    i = -1\n    j = 0\n    while i < len(l1) and j < len(l2):\n\
    \        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n\
    \            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n       \
    \ else:\n            j += 1\n    return res\n", "    l1 = list(set(l1))\n    l2\
    \ = list(set(l2))\n    l1.sort()\n    l2.sort()\n    return l1+l2\n", "    return\
    \ sorted(list(set(l1) & set(l2))) if l1 and l2 else []\n\n", "    \n    l1 = list(set(l1))\n\
    \    l2 = list(set(l2))\n\n    return list(set(l1) & set(l2))\n", "    return\
    \ list(set(l1).intersection(set(l2))) # using sets to make it more efficient instead\
    \ of list\n", "    first = l1[:] # copy since we are going to alter it\n    second\
    \ = l2[:]  # copy since we are going to alter it\n\n    if len(first) < len(second):\n\
    \        first, second = second, first\n    intersection = list(set(first) & set(second))\n\
    \    first = first[:]\n    second = second[:]\n    first.sort()\n    second.sort()\n\
    \    common_elements = []\n\n    # go through first list\n    for k in range(len(first)):\n\
    \        if first[k] == second[k]:\n            common_elements.append(first[k])\n\
    \            first.pop(k)\n            second.pop(k)\n            continue\n \
    \       while second[k] == first[k]:\n            first.pop(k)\n            second.pop(k)\n\
    \            k += 1\n\n    # go through second list\n    for k in range(len(second)):\n\
    \        while first[k] == second[k]:\n            common_elements.append(second[k])\n\
    \            first.pop(k)\n            second.pop(k)\n        k += 1\n\n    return\
    \ common_elements\n", "    return sorted(set(l1) & set(l2))\n", "    # Find out\
    \ the duplicates and return them in a sorted list\n    both = [x for x in l1 if\
    \ x in l2]\n    both.sort()\n    return both\n\n", "    d = defaultdict(list)\n\
    \    seen = set(l1)\n    for x in l1 + l2:\n        if x in seen: continue\n \
    \       d[x].append(x)\n        seen.add(x)\n    return list(d.values())\n", " \
    \   l1 = list(set(l1))\n    l2 = list(set(l2))\n    l1.sort()\n    l2.sort()\n\
    \    l1_idx = 0\n    l2_idx = 0\n    while l1_idx < len(l1) and l2_idx < len(l2):\n\
    \        equal = (l1[l1_idx] == l2[l2_idx])\n        if equal:\n            l1_idx\
    \ += 1\n            l2_idx += 1\n        else:\n            if l1_idx < l2_idx:\n\
    \                l1.pop(l1_idx)\n                l1_idx += 1\n            elif\
    \ l2_idx < l1_idx:\n                l2.pop(l2_idx)\n                l2_idx +=\
    \ 1\n            else: # equal and smaller\n                l1.pop(l1_idx)\n \
    \               l2.pop(l2_idx)\n                l1_idx += 1\n                l2_idx\
    \ += 1\n\n    l1.sort()\n    return l1\n", "    l = sorted(set(l1) & set(l2))\n\
    \    l.sort()\n    return l\n", "    from collections import Iterable\n\n    if\
    \ not all(isinstance(i, Iterable) for i in [l1, l2]):\n        raise TypeError(\"\
    Arguments must be lists or iterables\")\n\n    return sorted(list(set(l1) & set(l2)))\n",
  "    li1, li2 = list(set(l1)), list(set(l2))\n    if len(li1) > len(li2):\n    \
    \    li1, li2 = li2, li1\n    \n    return list(sorted(set(li1) & set(li2)))\n",
  "    return sorted(set(l1) & set(l2))\n", "    common = []\n    for i in l2:\n \
    \       if i in l1:\n            common.append(i)\n    return common\n\n", " \
    \   return list(set(l1) & set(l2))\n", "    return sorted(set(l1).intersection(set(l2)))\
    \ \n</cell>\n<text>\nThe function common returns a sorted list of common elements\
    \ of two lists.\n\n\n</text>\n<cell>\nassert common([1, 2, 3], [3, 4, 5]) == [1,\
    \ 3]\nassert common([6, 5, 8], [3, 6, 2, 8, 4, 7]) == [6, 8]\n</cell>\n<text>\n\
    We will create a helper function called isCandidate() that implements the following\
    \ logic:\n\nIf the first element of a list is smaller than the second element,\
    \ we will call it a candidate of the first list.\nIf the second element of a list\
    \ is smaller than the first element, we will call it a candidate of the second\
    \ list.\nThe sorted unique common elements will be taken to compare the two lists.\
    \ If the length of the sorted common elements is less than the length of the unsorted\
    \ lists, we will return False, otherwise we will return True.\n\n\n</text>\n<cell>",
  "    return list(sorted(set(l1) & set(l2)))\n\n", "    from heapq import nsmallest,\
    \ nlargest\n    if len(l1) != len(l2):\n        return l1[:1]+l2[:1]\n    c =\
    \ nsmallest(sorted(l1), sorted(l2))\n    if c: return c\n    return nlargest(sorted(l1),\
    \ sorted(l2))\n", "    def find(l1, l2):\n        l1 = list(l1)\n        l2 =\
    \ list(l2)\n        while l1 and l2:\n            a, b = l1.pop(), l2.pop()\n\
    \            if a < b:\n                l1.append(a)\n                l2.append(b)\n\
    \            else:\n                l1.append(b)\n                l2.append(a)\n\
    \        return l1, l2\n\n    return find(l1, l2)\n", "    l1 = sorted(l1)\n \
    \   l2 = sorted(l2)\n    return list(set(l1) & set(l2))\n", "    common = []\n\
    \    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n\
    \            common.append(l1[i])\n            i += 1\n            j += 1\n  \
    \      elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j +=\
    \ 1\n    return common\n\n", "    import functools as func\n    from functools\
    \ import reduce\n    sim = lambda l1, l2: int(reduce(func.or_, map(lambda a, b:\
    \ a == b, l1, l2)))\n    return sorted(reduce(lambda l1, l2: l1 + l2, filter(sim,\
    \ [l1, l2])))\n", "    c = Counter(l1)\n    ct2 = Counter(l2)\n\n    def countitem(c):\n\
    \        \"\"\"Return sorted (by key) list of items in c and its count.\n    \
    \    >>> countitem(Counter('abcdeabcdeab'))\n        [('a', 5), ('b', 2), ('c',\
    \ 1), ('d', 2), ('e', 2), ('e', 3)]\n        \"\"\"\n        return sorted(list(c),\
    \ key=c.get, reverse=True)\n\n    return countitem(common_key(c,ct2)) + countitem(common(c,ct2))\n",
  "    return sorted(set(l1) & set(l2))\n\n", "    from collections import defaultdict\n\
    \n    shared = defaultdict(list)\n    len_shared_items = len(shared)\n\n    for\
    \ a, b in zip(l1, l2):\n        if a in shared:\n            shared[a].append(b)\n\
    \        else:\n            shared[a] = [b]\n\n    if len_shared_items == len(shared):\n\
    \        return shared\n\n    # No common items found\n    return []\n\n", " \
    \   set1 = set(l1)\n    set2 = set(l2)\n    return list(set1 & set2)\n", "   \
    \ m = len(l1)\n    n = len(l2)\n    i, j = 0, 0\n    l = []\n    while i < m and\
    \ j < n:\n        if l1[i] == l2[j]:\n            l.append(l1[i])\n          \
    \  i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n\
    \        else:\n            j += 1\n    return l\n", "    def f(a: List[int],\
    \ b: List[int]) -> List[int]:\n        return [el for el in sorted(set(a) & set(b))\
    \ if el]\n    return f([e for e in l1 if e not in l2],\n            [e for e in\
    \ l1 if e not in l2])\n\n", "    from collections import Counter\n    count =\
    \ Counter(x for x in l1 if x in l2)\n    return sorted(list(set(l1) & set(l2)\
    \ - set(count.keys())))\n", "    l1 = list(l1)\n    l2 = list(l2)\n    i = 0\n\
    \    j = 0\n    common = []\n    while i < len(l1) and j < len(l2):\n        if\
    \ l1[i] == l2[j]:\n            common.append(l1[i])\n            i += 1\n    \
    \        j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n\
    \            j += 1\n    return common\n\n\n@deprecated() # TODO: Remove in v1.2",
  "    l1 = list(l1)\n    l2 = list(l2)\n    li, num1, num2 = l1[0], l1[1:], l2[0],\
    \ l2[1:]\n    li_next, num1_next, num2_next = li[0], num1[0], num2[0]\n    while\
    \ li not in (l2, l1):\n        li, li_next, num1, num1_next, num2 = li_next, li[0],\
    \ num1_next, num2[0], num2[1:]\n        num2_next = num2[0]\n    while num1 not\
    \ in (num2, num2_next):\n        num1, num1_next = num1_next, num1[0]\n    return\
    \ li + [num1] + num2_next\n", "    return list(set(l1) & set(l2))\n", "    return\
    \ sorted(set(l1) & set(l2))\n", "    a, b = l1[:], l2[:]\n    common = []\n  \
    \  while a and b:\n        if a[0] <= b[0]: common.append(a.pop(0))\n        else:\
    \ common.append(b.pop(0))\n    return common\n", "    common = set(l1) & set(l2)\n\
    \    common = list(common)\n    common.sort()\n    return common\n", "    list1\
    \ = list(l1)\n    list2 = list(l2)\n    if not list1 or not list2:\n        return\
    \ []\n    list1_counts = {}\n    list2_counts = {}\n    for item in list1 + list2:\n\
    \        if item not in list1_counts:\n            list1_counts[item] = 1\n  \
    \      else:\n            list1_counts[item] += 1\n        if item not in list2_counts:\n\
    \            list2_counts[item] = 1\n        else:\n            list2_counts[item]\
    \ += 1\n    common_count = min(len(list1_counts), len(list2_counts))\n    if common_count\
    \ == 0:\n        return []\n    result = list1_counts[list1[common_count]]\n \
    \   result.extend(list2_counts[list2[common_count]])\n    return result\n\n",
  "    if not l1:\n        return l2\n    if not l2:\n        return l1\n    return\
    \ list(set(l1) & set(l2))\n\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    l1.sort()\n    l2.sort()\n    return list(set(l1) & set(l2))\n", "    if\
    \ not l1 or not l2:\n        return []\n\n    if not l1 or not l2:\n        return\
    \ list(l1)\n\n    shared = []\n    i = 0\n    while i < len(l1) and i < len(l2):\n\
    \        if l1[i] == l2[i]:\n            i += 1\n        else:\n            shared.append(l1[i])\n\
    \            i += 1\n\n    return shared\n\n", "    return list(sorted(set(l1)\
    \ & set(l2)))\n", "    return list(set(l1) & set(l2))\n", "    l1 = sorted(l1,\
    \ reverse=True)\n    l2 = sorted(l2, reverse=True)\n    l1.extend(l2)\n    return\
    \ sorted(set(l1), reverse=True)\n", "    l1 = list(l1)\n    l2 = list(l2)\n\n\
    \    common = []\n    i = 0\n    j = 0\n\n    while i < len(l1) and j < len(l2):\n\
    \        if l1[i] == l2[j]:\n            common += l1[i]\n            i += 1\n\
    \            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n       \
    \ else:\n            i += 1\n\n    return list(set(common))\n", "    return list(set(l1)\
    \ & set(l2))\n", "    sorted_l1 = sorted(l1)\n    sorted_l2 = sorted(l2)\n   \
    \ common = sorted_l1[:]\n    for i, j in zip(sorted_l1, sorted_l2):\n        index_i\
    \ = sorted_l1.index(i)\n        index_j = sorted_l2.index(j)\n        if index_i\
    \ == index_j:\n            continue\n        common.append(i)\n        common.append(j)\n\
    \    return sorted(common)\n", "    common = []\n    for i in l1:\n        if\
    \ i in l2:\n            if i not in common:\n                common.append(i)\n\
    \        else:\n            if i not in common:\n                common.extend([i]*(i\
    \ in l2))\n    return common\n", "    l1, l2 = sorted(l1), sorted(l2)\n    res\
    \ = []\n    while l1 and l2:\n        if l1[0] != l2[0]:\n            res.append(l1[0])\n\
    \            l1.pop(0)\n        else:\n            res.append(l2[0])\n       \
    \     l2.pop(0)\n    return res + l1[:1] + l2[:1] if l1 else l1 + l2\n", "   \
    \ if l1==l2: return l1[:]\n    res = []\n    i, j, k = 0, 0, 0\n    while i <\
    \ len(l1) and j < len(l2):\n        while l1[i]==l2[j]:\n            i += 1\n\
    \            j += 1\n        res.append(l1[i])\n        i += 1\n        j += 1\n\
    \    while i < len(l1):\n        res.append(l1[i])\n        i += 1\n    while\
    \ j < len(l2):\n        res.append(l2[j])\n        j += 1\n    return res\n",
  "    try:\n        if len(l1) > len(l2):\n            l1, l2 = l2, l1\n        common\
    \ = [n for n in l1 if n in l2]\n    except (ValueError, TypeError):\n        return\
    \ []\n\n    common.sort()\n    return common\n\n", "    s = set()\n    s1 = set(l1)\n\
    \    s2 = set(l2)\n    for e in s1 - s2:\n        s.add(e)\n    for e in s2 -\
    \ s1:\n        s.add(e)\n    return list(s)\n", "    l1 = sorted(l1)\n    l2 =\
    \ sorted(l2)\n    res = []\n    while l1 and l2:\n        if l1[0] < l2[0]:\n\
    \            l1.pop(0)\n        else:\n            l2.pop(0)\n        if l1:\n\
    \            res.append(l1[0])\n        if l2:\n            res.append(l2[0])\n\
    \    return res\n</code>\n<|/ a |>\n<| c |>\nCould you explain the logic behind\
    \ your `if` statements?\n<|/ c |>\n<| a tags=python |>\nA simple solution with\
    \ set intersection and list comprehension:\n<code>\n>>> a=[1,4,3,34,653,5,9,121]\n\
    >>> b=[5,7,1,5,9,653,121]\n>>> [x for x in range(max(a),min(a))\\\n if a.count(x)\
    \ > b.count(x)]\n[1, 5, 653]\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>",
  "    return list(set(l1) & set(l2))\n", "    return sorted(set(l1) & set(l2))\n\n",
  "    return sorted(set(l1) & set(l2))\n\n", "    return sorted(set(l1) & set(l2))\n\
    \n", "    d1 = collections.defaultdict(int)\n    d2 = collections.defaultdict(int)\n\
    \    d1_all = []\n    d2_all = []\n    for x, y in zip(l1, l2):\n        d1[x]\
    \ += 1\n        d2[y] += 1\n        d1_all.append(x)\n        d2_all.append(y)\n\
    \    d1_all.sort()\n    d2_all.sort()\n    return list(set(d1_all).intersection(set(d2_all)))\n",
  "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    result = []\n    if l1 != l2:\n \
    \       l1s = l1\n        l2s = l2\n    else:\n        return l1\n    i = 0\n\
    \    j = 0\n    while i < len(l1s) and j < len(l2s):\n        if l1s[i] == l2s[j]:\n\
    \            result.append(l1s[i])\n            i += 1\n            j += 1\n \
    \       elif l1s[i] > l2s[j]:\n            j += 1\n        else:\n           \
    \ i += 1\n    return list(set(result))\n\n", "    from collections import defaultdict\n\
    \    common = defaultdict(list)\n    for x in l1+l2:\n        if x in common:\n\
    \            common[x].append(x)\n        else:\n            common[x] = [x]\n\
    \    return list(common.values())\n", "    i = j = 0\n    lst = []\n    while\
    \ i < len(l1) and j < len(l2):\n        if l1[i] < l2[j]:\n            lst.append(l1[i])\n\
    \            i += 1\n        else:\n            lst.append(l2[j])\n          \
    \  j += 1\n\n    return lst + l1[i:] + l2[j:]\n", "    seen = set(l1)\n    seen_add\
    \ = seen.add\n    seen_remove = seen.remove\n    answer = []\n    for item in\
    \ l2:\n        if item in seen:\n            seen_remove(item)\n        else:\n\
    \            seen_add(item)\n            answer.append(item)\n    return answer\n\
    \n", "    def sortlist(a):\n        return sorted(set(a))\n    return [x for x,\
    \ _ in sorted(zip(sortlist(l1), sortlist(l2)))]\n\n", "    l1 = list(set(l1))\n\
    \    l2 = list(set(l2))\n    res = []\n    lis = list(zip(l1, l2))\n    for e\
    \ in lis:\n        if e[0]==e[1]:\n            res.append(e[0])\n    return list(set(res))\n",
  "    s1 = sorted(l1)\n    s2 = sorted(l2)\n    return list(set(s1).intersection(set(s2)))\n",
  "    m = len(l1)\n    n = len(l2)\n    if m < n:\n        l1, l2 = l2, l1\n    li_1\
    \ = l1[:m]\n    li_2 = l2[:n]\n    li_com = li_1 + li_2\n    return li_com\n\n",
  "    m = min(len(l1), len(l2))\n    l1 = sorted(l1)[:m]\n    l2 = sorted(l2)[:m]\n\
    \    li = []\n    li.append(0)\n    li.append(-1)\n    for x in l1:\n        j\
    \ = li[0]\n        left = l2[j:]\n        if x < left:\n            li.append(j)\n\
    \            li[0] = x\n    for x in l2:\n        j = li[-1]\n        right =\
    \ l1[:j]\n        if x > right:\n            li.append(j)\n            li[-1]\
    \ = x\n    return li\n", "    common = []\n    match = 0\n    for i in range(len(l1)):\n\
    \        match2 = match\n        match = 0\n        for i2 in range(len(l2)):\n\
    \            if l1[match] == l2[match2]:\n                match += 1\n       \
    \     else:\n                break\n        if match == match2:\n            common.append(l1[match])\n\
    \    return common\n", "    m = len(l1)\n    n = len(l2)\n    if n == 0:\n   \
    \     return l1[:]\n    if m == 0:\n        return l2[:]\n    i, j = 0, 1\n  \
    \  result = []\n    while i < m and j < n:\n        if l1[i] == l2[j]:\n     \
    \       result.append(l1[i])\n            i += 1\n            j += 1\n       \
    \ elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n\
    \    if len(l1) > len(l2):\n        return result + [l1[i] for i in xrange(len(l1)\
    \ - len(l2))]\n    else:\n        return result + [l2[i] for i in xrange(len(l2)\
    \ - len(l1))]\n", "    l1 = list(l1)\n    l2 = list(l2)\n    return sorted(set(l1)\
    \ & set(l2))\n\n", "    s1 = set(l1)\n    s2 = set(l2)\n    return list(s1 & s2)\n",
  "    res = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n\
    \    return res\n\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n    lst\
    \ = []\n    if l1 and l2:\n        for k in l1.intersection(l2):\n           \
    \ lst.append(k)\n    return lst\n\n", "    a = list(set(l1))\n    b = list(set(l2))\n\
    \    return sorted(list(a+b))\n", "    \n    \n    return sorted(list(set(l1).intersection(set(l2))))\n\
    \n", "    def dfs(i: int, j: int):\n        if i > j:\n            return\n  \
    \      if i > len(l1) or j > len(l2):\n            return\n        if l1[i] ==\
    \ l2[j]:\n            common.append(l1[i])\n            dfs(i + 1, j + 1)\n  \
    \          dfs(i - 1, j + 1)\n            dfs(i, j + 1)\n            dfs(i + 1,\
    \ j - 1)\n            dfs(i - 1, j - 1)\n    dfs(0, 0)\n    return sorted(common)\n\
    \n", "    common = []\n    for item in l1:\n        if item in l2:\n         \
    \   common.append(item)\n    return sorted(set(common))\n", "    s = set(l1)\n\
    \    for e in l2:\n        if e in s:\n            s.remove(e)\n        else:\n\
    \            return list(s)\n    return []\n", "    return sorted(set(l1) & set(l2))\n\
    \n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\n    common = list(set.intersection(*[set(l1),\
    \ set(l2)]))\n\n    return sorted(common)\n", "    return list(set(l1) & set(l2))\n",
  "    li, lj = l1[0], l1[-1]\n    r1, r2 = l2[0], l2[-1]\n\n    if r1 < r2:\n   \
    \     return common(l1, l2)\n\n    elif r1 > r2:\n        return common(l2, l1)\n\
    \n    else:\n        return l1[: :-1] + l2[:: -1]\n", "    l1 = set(l1) if l1\
    \ else []\n    l2 = set(l2) if l2 else []\n    return list(l1 & l2)\n", "    li,\
    \ l2 = list(l1), list(l2)\n    if l1 == l2:\n        return l1\n    return sorted(set(l1).intersection(set(l2)))\
    \ or sorted(set(l2).difference(set(l1)))\n", "    d1 = defaultdict(int)\n    d2\
    \ = defaultdict(int)\n    for e in l1+l2:\n        d1[e] += 1\n        d2[e] -=\
    \ 1\n    commons = []\n    for k in d1.keys():\n        if d1[k] != 0 and d2[k]\
    \ != 0:\n            commons.append(k)\n    return sorted(commons)\n", "    l1\
    \ = sorted(l1)\n    l2 = sorted(l2)\n    l1 = l1 if l1 is not None else []\n \
    \   l2 = l2 if l2 is not None else []\n    return list(set(l1) & set(l2))\n",
  "    s1 = list(l1)\n    s2 = list(l2)\n    i, j = 0, 0\n    while i < len(s1) and\
    \ j < len(s2):\n        if s1[i] == s2[j]:\n            i += 1\n            j\
    \ += 1\n        else:\n            i += 1\n    s1.sort()\n    s2.sort()\n    return\
    \ s1[:len(s1) -len(s2)] + s2\n", "    # Find overlaps between two lists\n    i\
    \ = j = 0\n    length1 = len(l1)\n    length2 = len(l2)\n    overlap = []\n  \
    \  while i < length1 and j < length2:\n        if l1[i] == l2[j]:\n          \
    \  overlap.append(l1[i])\n            i += 1\n            j += 1\n        elif\
    \ l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return\
    \ overlap\n", "    return sorted(set(l1) & set(l2))\n", "    if 1 in l2 or 2 in\
    \ l1 or len(l1) > len(l2):\n        return list(set(l1) & set(l2))\n    else:\n\
    \        return list(set(l1) | set(l2))\n", "    return list(set(l1) & set(l2))\n",
  "    if not l1 or not l2:\n        return []\n    a, b = l1[0], l2[0]\n    if a\
    \ != b:\n        return sorted(list(set(a) & set(b)))\n    else:\n        return\
    \ sorted(list(set(a)))\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n \
    \   return l1 if len(l1) <= len(l2) else l2\n", "    common_elements = []\n\n\
    \    for a in l1:\n        if a in l2:\n            common_elements.append(a)\n\
    \n    return sorted(common_elements)\n\n", "    return list(set(l1) & set(l2))\n",
  "    d = collections.Counter(l1) ^ collections.Counter(l2)\n    return sorted(d\
    \ & d.keys())\n\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n    res =\
    \ []\n    while l1 and l2:\n        if l1[0] <= l2[0]:\n            res.append(l1[0])\n\
    \            l1.remove(l1[0])\n        else:\n            res.append(l2[0])\n\
    \            l2.remove(l2[0])\n    return res + sorted(l1 + l2)\n", "    res:\
    \ List[int] = []\n    for x in l1:\n        if x in l2:\n            res.append(x)\n\
    \        else:\n            break\n    return res\n", "    _set1 = set(l1)\n \
    \   _set2 = set(l2)\n    return sorted(list(_set1 & _set2)) + sorted(list(_set1\
    \ & _set2), reverse=True)\n", "    s1 = set(l1)\n    s2 = set(l2)\n    return\
    \ sorted(list(s1 & s2))\n\n", "    common = []\n    for i in l1:\n        if i\
    \ in l2:\n            common.append(i)\n\n    return common\n", "    s = list(l1)\n\
    \    s.extend(l2)\n    return sorted(set(s))\n\n", "    def common1(cw1, cw2):\n\
    \        for i in cw1:\n            if i in cw2:\n                return i\n \
    \       return None\n\n    def common2(cw1, cw2):\n        for i in cw2:\n   \
    \         if i in cw1:\n                return i\n        return None\n\n    if\
    \ len(l1) > len(l2):\n        return common1(cw2, l1)\n    else:\n        return\
    \ common2(cw1, l2)\n\n", "    a, b = l1, l2\n    i = 0\n    j = 0\n    a_len =\
    \ len(a)\n    b_len = len(b)\n    result = []\n\n    while i < a_len and j < b_len:\n\
    \        if a[i] < b[j]:\n            result.append(a[i])\n            i += 1\n\
    \        else:\n            result.append(b[j])\n            j += 1\n        \
    \    \n    while i < a_len:\n        result.append(a[i])\n        i += 1\n\n \
    \   while j < b_len:\n        result.append(b[j])\n        j += 1\n\n    return\
    \ result\n", "    set1 = set(l1)\n    set2 = set(l2)\n    return list(set1 & set2)\n",
  "    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1 & set2))\n\n",
  "    l1_count = {}\n    l2_count = {}\n    for i in l1:\n        if i in l1_count:\n\
    \            l1_count[i] += 1\n        else:\n            l1_count[i] = 1\n  \
    \  for i in l2:\n        if i in l2_count:\n            l2_count[i] += 1\n   \
    \     else:\n            l2_count[i] = 1\n    return list(set(l1_count.keys())\
    \ & set(l2_count.keys()))\n", "    return list(set(l1) & set(l2))\n", "    return\
    \ sorted(set(l1) & set(l2))\n", "    return list(set(l1) & set(l2))\n", "    l1\
    \ = sorted(l1)\n    l2 = sorted(l2)\n    common = []\n    i = j = 0\n    while\
    \ i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            common.append(l1[i])\n\
    \            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n       \
    \     j += 1\n        else:\n            i += 1\n    return common\n", "    #\
    \ TODO Optimize\n    return sorted(set(l1) & set(l2))\n\n", "    l1 = sorted(l1)\n\
    \    l2 = sorted(l2)\n    i = 0\n    j = 0\n    k = len(l1)\n    m = len(l2)\n\
    \    while i < m and j < k:\n        if l1[i] == l2[j]:\n            i += 1\n\
    \            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n       \
    \ else:\n            j += 1\n    return l1[:i]\n", "    shared = set()\n    for\
    \ x in l1:\n        if x in shared:\n            continue\n        shared.add(x)\n\
    \        for y in l2:\n            if y in shared:\n                continue\n\
    \            shared.add(y)\n            return sorted(shared)\n    return []\n",
  "    return list(set(l1).intersection(set(l2)))\n", "    def _inner(lst1: List[int],\
    \ lst2: List[int]) -> List[int]:\n        diff1 = set(lst1) - set(lst2)\n    \
    \    diff2 = set(lst2) - set(lst1)\n        return sorted(list(diff1 & diff2))\n\
    \n    if len(l1) != len(l2):\n        raise ValueError(\"Lists are of different\
    \ sizes. l1: {}, l2: {}\".format(len(l1), len(l2)))\n\n    return _inner(l1, l2)\n\
    \n", "    a = sorted(list(set(l1)), key=l1.__getitem__)  # type: ignore\n    b\
    \ = sorted(list(set(l2)), key=l2.__getitem__)  # type: ignore\n    return list(a.intersection(b))\
    \ if a!=b else []\n", "    set = set()\n    return [x for x in l1 if x in set\
    \ or set.add(x) in set] + \\\n        [x for x in l2 if x in set or set.add(x)\
    \ in set]\n\n", "    return sorted(set(l1) & set(l2))\n", "    # Quickly try common\
    \ prefix first\n    a = l1[:]\n    b = l2[:]\n    try:\n        while True:\n\
    \            while a and a[0] < b[0]:\n                a.pop(0)\n            while\
    \ b and b[0] < a[0]:\n                b.pop(0)\n            if a and b and a[0]\
    \ == b[0]:\n                a.pop(0)\n                b.pop(0)\n    except IndexError:\n\
    \        return l1[:]\n    else:\n        return a + b\n", "    if l1 == l2:\n\
    \        return l1\n\n    intersection = set(l1).intersection(l2)\n    common\
    \ = sorted(list(intersection))\n\n    return common\n", "    return sorted(list(set(l1)\
    \ & set(l2)))\n", "    if not l2:\n        return l1[:]\n    return sorted(list(set(l1).intersection(set(l2))))\n\
    \n", "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    \n    return list(set().union(l1,\
    \ l2))\n", "    if not l1 or not l2:\n        return []\n    return sorted(set(l1)\
    \ & set(l2))\n\n", "    l1 = list(l1)\n    l2 = list(l2)\n    common = set()\n\
    \    i = -1\n    while i < len(l1) and i < len(l2):\n        if l1[i] == l2[i]:\n\
    \            common.add(l1[i])\n            i += 1\n        else:\n          \
    \  break\n    return list(common)\n", "    if len(l1) > len(l2):\n        l1,\
    \ l2 = l2, l1\n\n    i = j = 0\n    res = []\n    while i < len(l1) or j < len(l2):\n\
    \        if i == len(l1) and j == len(l2):\n            res.append(l1[i])\n  \
    \          i += 1\n            j += 1\n        elif l1[i] == l2[j]:\n        \
    \    i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            res.append(l1[i])\n\
    \            i += 1\n        else:\n            res.append(l2[j])\n          \
    \  j += 1\n    return res\n", "    result = []\n    sorted_l1 = sorted(l1)\n \
    \   sorted_l2 = sorted(l2)\n    for element in sorted_l1:\n        if element\
    \ in sorted_l2:\n            result.append(element)\n    return result\n", " \
    \   l1 = sorted(l1)\n    l2 = sorted(l2)\n    i, j = 0, 0\n    resl = []\n   \
    \ while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n           \
    \ i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            resl.append(l1[i])\n\
    \            i += 1\n        else:\n            resl.append(l2[j])\n         \
    \   j += 1\n    return resl\n", "    return list(set(l1) & set(l2))\n", "    if\
    \ not l1:\n        return l2\n    if not l2:\n        return l1\n    if l1[0]\
    \ > l2[0]:\n        return common(l1[1:], l2)\n    return common(l1, l2[1:])\n\
    \n", "    lst1, lst2 = list(l1), list(l2)\n    for x in lst2:\n        if x in\
    \ lst1:\n            lst1.remove(x)\n        else:\n            lst2.remove(x)\n\
    \    return lst1\n", "    lst1 = l1.sort()\n    lst2 = l2.sort()\n    li = []\n\
    \    li.append(lst1[0])\n    for i in range(1, len(lst1)):\n        if lst1[i]\
    \ == lst1[i - 1]:\n            continue\n        li.append(lst1[i])\n    return\
    \ li\n", "    out = []\n    common = 0\n    for i1 in l1:\n        if i1 in l2:\n\
    \            if common != 0:\n                out.append(common)\n           \
    \ common = i1\n        else:\n            common += 1\n            if common !=\
    \ 0:\n                out.append(common)\n    if common != 0:\n        out.append(common)\n\
    \    return out\n\n", "    return list(set(l1) & set(l2))\n", "    lst1 = set(l1)\n\
    \    lst2 = set(l2)\n    common = lst1.intersection(lst2)\n    return sorted(list(common))\n",
  "    c = {}\n    for item in l1 + l2:\n        c[item] = None\n    return sorted(set(l1)\
    \ & set(l2))\n", "    from bisect import bisect_left\n    l1 = sorted(l1)\n  \
    \  l2 = sorted(l2)\n    \n    matches = []\n    start = min([bisect_left(l1, i)\
    \ for i in l2])\n    end = max([bisect_left(l2, i) for i in l1])\n    \n    for\
    \ i in range(start, end + 1):\n        if l1[i] == l2[i]:\n            matches.append(l1[i])\n\
    \    return matches\n", "    s = set(l1) & set(l2)\n    if s:\n        return\
    \ sorted(list(s))\n    return []\n", "    # Quickly return the pair of lists if\
    \ there are exactly the same\n    # elements.\n    if l1 == l2:\n        return\
    \ l1, l2\n    # If the lists are different lengths, use a faster algorithm.\n\
    \    if len(l1) != len(l2):\n        return common(l1[: len(l1) // 2], l2[: len(l2)\
    \ // 2])\n    # Build list of unique elements.\n    elements = l1 + l2\n    #\
    \ Remove common elements from each list.\n    common = []\n    for e in elements:\n\
    \        if e in common:\n            # Keep elements found in both lists.\n \
    \           continue\n        # Remove element from other list, if present.\n\
    \        count = 0\n        for l in [l for l in [elements[:i] for i in range(1,\
    \ len(elements))] if l in common]:\n            count += 1\n            if count\
    \ == 2:\n                common.append(e)\n                break\n        else:\n\
    \            common.append(e)\n    return common\n", "    a = set(l1)\n    b =\
    \ set(l2)\n    return sorted(a.intersection(b)) # TODO fix for duplicates\n",
  "    return list(set(l1) & set(l2))\n", "    return list(set(l1) & set(l2))\n\n",
  "    return sorted(list(set(l1).intersection(set(l2))))\n\n", "    if not l1:\n\
    \        return l2\n    if not l2:\n        return l1\n    if l1 == l2:\n    \
    \    return list(l1)\n    common_list = []\n    for x in l1:\n        if x in\
    \ l2:\n            common_list.append(x)\n    return common_list\n\n", "    lst\
    \ = set(l1)\n    lst2 = set(l2)\n    return sorted(lst.intersection(lst2))\n",
  "    l1_set = set(l1)\n    l2_set = set(l2)\n    l1_list.sort()\n    l2_list.sort()\n\
    \    return l1_list & l2_list\n", "    common = []\n    for i in l1:\n       \
    \ if i in l2:\n            common.append(i)\n    return common\n", "    return\
    \ list(set(l1) & set(l2))\n", "    from functools import reduce\n    common =\
    \ list(reduce(set.intersection, map(lambda x, y: set(x) & set(y), l1, l2)))\n\
    \    return sorted(common)\n", "    d = {}\n    for x in l1 + l2:\n        if\
    \ x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    return\
    \ list(d.keys())\n", "    if not l1:\n        return l2\n    if not l2:\n    \
    \    return l1\n    i = j = 0\n    while True:\n        if l1[i] < l2[j]:\n  \
    \          l1[i] += 1\n            if l1:\n                i += 1\n        elif\
    \ l2[j] < l1[i]:\n            l2[j] += 1\n            if l2:\n               \
    \ j += 1\n        else:\n            break\n    return l1 + l2[j:]\n\n", "   \
    \ return list(set(l1) & set(l2))\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
