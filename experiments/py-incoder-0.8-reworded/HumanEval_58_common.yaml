name: HumanEval_58_common
language: py
prompt: "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n\
  \    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
  \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5,\
  \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3,\
  \ 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  \
  \  assert candidate([4, 3, 2, 8], []) == []\n\ndef test_check():\n    check(common)\n\
  \ntest_check()\n"
completions: ["    if not l2:\n        return l1\n    return list(set(l1) & set(l2))\n",
  "    s1 = set(l1)\n    s2 = set(l2)\n    return list(sorted(s1 & s2))\n", "    l1\
    \ = sorted(l1, reverse=True)\n    l2 = sorted(l2, reverse=True)\n    sorted_list\
    \ = l1[:]\n    sorted_list.sort()\n    if l1 == l2:\n        return sorted_list\n\
    \    \n    result = []\n    for i in range(len(sorted_list)):\n        if sorted_list[i]\
    \ == l2[0]:\n            result.append(sorted_list[i])\n            del sorted_list[i]\n\
    \            break\n        elif sorted_list[i] > l2[0]:\n            for j in\
    \ l1:\n                if sorted_list[i] == j:\n                    del sorted_list[i]\n\
    \                    break\n            if sorted_list == l1:\n              \
    \  result.append(sorted_list[i])\n            del sorted_list[i]\n        elif\
    \ sorted_list[i] < l2[0]:\n            for j in l2:\n                if sorted_list[i]\
    \ == j:\n                    del sorted_list[i]\n                    break\n \
    \           if sorted_list == l2:\n                result.append(sorted_list[i])\n\
    \            del sorted_list[i]\n    return result\n", "    # sort the arguments\n\
    \    sorted_args = [sorted((i, j))\n                   for i, j in sorted(zip(l1,\
    \ l2))]\n    sorted_args.sort()\n    # ignore the Nones\n    sorted_args = list(filter(None.__ne__,\
    \ sorted_args))\n    # produce output\n    return [sorted_args[0][i] for i in\
    \ range(1, len(sorted_args))]\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    l1.sort()\n    l2.sort()\n    return list(set(l1) & set(l2))\n", "    result\
    \ = []\n    for i in l1:\n        if i in l2:\n            result.append(i)\n\
    \    return result\n\n", "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    set2 =\
    \ set(l2)\n    return list(set1 & set2)\n\n", "    l1 = list(l1)\n    l2 = list(l2)\n\
    \    common = []\n    i = 0\n    j = 0\n    while i < len(l1) and j < len(l2):\n\
    \        if l1[i] == l2[j]:\n            common.append(l1[i])\n            i +=\
    \ 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n   \
    \     else:\n            i += 1\n\n    return common\n\n", "    l1 = list(l1)\n\
    \    l2 = list(l2)\n    l1.sort()\n    l2.sort()\n    i = 0\n    j = 0\n    res\
    \ = []\n    while True:\n        if i > len(l1) or j > len(l2):\n            break\n\
    \        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n\
    \            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n       \
    \ else:\n            i += 1\n    return list(set(res))\n\n", "    l1 = list(set(l1))\n\
    \    l2 = list(set(l2))\n    return sorted(l1.intersection(l2))\n", "    import\
    \ itertools\n    shared = itertools.tee(itertools.combinations(l1, 1), 2)\n  \
    \  l1 = next(shared)\n    l2 = next(shared)\n    next(itertools.islice(shared,\
    \ 1, None))\n    return list(itertools.filterfalse(lambda x: x[0] in l2, itertools.product(l1,\
    \ l2)))\n", "    return sorted(set(l1) & set(l2))\n", "    return sorted(list(set(l1)\
    \ & set(l2)))\n", "    m = min(len(l1), len(l2))\n    result = [0] * m\n    i,\
    \ j, k = 0, 0, 0\n    while i < m and j < m:\n        if l1[i] == l2[j]:\n   \
    \         result[k] = l1[i]\n            i += 1\n            j += 1\n        elif\
    \ l1[i] < l2[j]:\n            result[k] = l1[i]\n            i += 1\n        else:\n\
    \            result[k] = l2[j]\n            j += 1\n        k += 1\n    return\
    \ list(reversed(result))\n\n", "    return sorted(list(set(l1) & set(l2)), key=lambda\
    \ x: l1.index(x))\n", "    # Find out if both are empty lists. Otherwise use sort().\n\
    \    if not (l1 and l2) or (not l2 and not l1):\n        return []\n\n    # Build\
    \ lists of indices where items are shared.\n    len1, len2 = len(l1), len(l2)\n\
    \    indices = [[i for i, j in enumerate(l2) if j == l1[i]]\n               for\
    \ i in range(len1)]\n\n    # Remove duplicate indices.\n    indices = list(set(indices))\n\
    \    if len(indices) != len1:\n        indices = indices[:len1]\n\n    return\
    \ indices + [len(l1)] if len1 > len2 else indices\n", "    i = 0\n    j = 0\n\
    \    l = len(l1)\n    m = len(l2)\n    result = []\n\n    while i < l:\n     \
    \   if j < m:\n            if l1[i] == l2[j]:\n                i += 1\n      \
    \          j += 1\n            else:\n                j = m + 1\n        else:\n\
    \            result.append(l1[i])\n            i += 1\n\n    return result\n",
  "    return sorted(set(l1).intersection(set(l2)), key=l1.index) if l1 and l2 else\
    \ []\n", "    i = j = 0\n    result = list(range(min(len(l1), len(l2))))\n   \
    \ while i < len(l1) or j < len(l2):\n        if i >= len(l1) or j >= len(l2):\n\
    \            break\n        if l1[i] == l2[j]:\n            result[i] = result[j]\n\
    \            i += 1\n            j += 1\n        else:\n            result.append(l1[i])\n\
    \            i += 1\n    return list(set(result))\n\n", "    if not l1:\n    \
    \    return l2\n    if not l2:\n        return l1\n    if l1[0] < l2[0]:\n   \
    \     return l1\n    else:\n        return l2\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
