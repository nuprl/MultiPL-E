name: HumanEval_131_digits
language: py
prompt: "def digits(n: int) -> int:\n    \"\"\"Given a positive integer n, return\
  \ the product of the odd digits.\n    Return 0 if all digits are even.\n    For\
  \ example:\n    >>> digits(1)\n    1\n    >>> digits(4)\n    0\n    >>> digits(235)\n\
  \    15\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(5) == 5\n    assert candidate(54)\
  \ == 5\n    assert candidate(120) == 1\n    assert candidate(5014) == 5\n    assert\
  \ candidate(98765) == 315\n    assert candidate(5576543) == 2625\n    assert candidate(2468)\
  \ == 0\n\ndef test_check():\n    check(digits)\n\ntest_check()\n"
completions: ["    product = 1\n    while n > 9:\n        product *= n % 10\n    \
    \    n = n // 10\n    return product\n\n", "    assert n >= 0\n    if n == 0:\n\
    \        return 0\n    elif n % 2 == 0:\n        return digits(n / 2)\n    else:\n\
    \        return digits(n / 2) + 1\n\n", "    if n < 0:\n        return 0\n   \
    \ count = 0\n    while n > 0:\n        n, r = divmod(n, 10)\n        if r == 0:\n\
    \            count += 1\n    return count\n\n", "    if n < 0:\n        return\
    \ digits(-n)\n    if n < 10:\n        return n\n    even = True\n    while n >\
    \ 0 and n % 2 == 0:\n        n = n // 2\n        even = not even\n    return 0\
    \ if even else n\n\n", "    return product_of_digits(math.floor(n))\n\n", "  \
    \  return n//(10*(n%10))\n", "    product = 1\n    while n:\n        product *=\
    \ n % 2\n        n //= 2\n    return product\n\n", "    assert n > 0\n    digits\
    \ = 1\n    while n > 0:\n        digits = digits * n % 10\n        n = n // 10\n\
    \    return digits\n\n", "    assert n > 0\n    if not (n & 1):\n        return\
    \ 0\n    else:\n        return 1 + digits(n >> 1)\n\n", "    if n == 0:\n    \
    \    return 0\n    else:\n        return 1 << (n - 1).bit_length()\n\n", "   \
    \ return 0 if not n % 2 else ((n % 10) * (digits(n // 10) * 2))\n\n", "    if\
    \ n == 0:\n        return 0\n    else:\n        product = 1\n        while n !=\
    \ 0:\n            product *= n % 10\n            n //= 10\n        return product\n\
    \n", "    # todo: optimize this function\n    product = 1\n    digits = str(n)\n\
    \    if len(digits) < n:\n        return 0\n    len_digits = len(digits)\n   \
    \ if len_digits == 2:\n        if digits[0] % 2 and digits[1] % 2:\n         \
    \   return 0\n        return product\n    for idx in range(len_digits - 2, -1,\
    \ -2):\n        if digits[idx] % 2:\n            product *= 2\n        else:\n\
    \            product += 1\n    return product\n\n", "    count = 0\n    while\
    \ n > 0:\n        if n % 2 != 0:\n            count += 1\n            n = n /\
    \ 2\n        else:\n            n = 0\n    return count\n", "    # from https://en.wikipedia.org/wiki/Odd_parity\n\
    \    if n < 10:\n        return n\n    else:\n        odd = n % 10\n        return\
    \ digit * digits(n // 10) for digit in str(odd)\n\n", "    product = 1\n    for\
    \ d in str(n):\n        product *= int(d)\n    return product\n\n", "    return\
    \ n // 10 + (n % 10 and digits(n % 10) or 0)\n", "    if n == 0:\n        return\
    \ 0\n    else:\n        return sum([int(x) for x in str(n) if int(x) % 2 == 1])\n\
    \n", "    if not n & 1:\n        return 0\n    return n & 1\n\n", "    product\
    \ = 1\n    while n >= 10:\n        product *= n % 10\n        n //= 10\n    return\
    \ product\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
