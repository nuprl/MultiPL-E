{
  "name": "HumanEval_119_match_parens",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] parens = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 0) {\n                for (int j = 0; j < n; j++) {\n                    if (i != j && parens[j] == 1) {\n                        parens[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpptrv9xzo.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] dp = new int[n];\n        for(int i = 0; i < n; i++) {\n            dp[i] = 0;\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(j) == '(' && lst.get(j).charAt(i) == ')') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(dp[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpbodfb2_m.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                sb.append(lst.get(i));\n            } else if (lst.get(i).equals(\")\")) {\n                if (sb.length() == 0) return \"No\";\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmperdjaqx8.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        if(len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < len; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp03s6oi27.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (paren[i] == 1 && paren[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2g9tdjsh.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else if (lst.get(i).equals(\")\")) p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (p[j] == -1) {\n                        p[j] = 1;\n                        p[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == -1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp72y8zwc_.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"No\";\n        if (n == 1) return \"Yes\";\n        int[] parens = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpra8dyzx4.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int count = 0;\n        int len = lst.size();\n        while (i < len) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            }\n            i++;\n        }\n        while (j < len) {\n            if (lst.get(j).equals(\")\")) {\n                count--;\n            }\n            j++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5mahem4e.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        if(len == 1) return \"No\";\n        int[] arr = new int[len];\n        for(int i = 0; i < len; i++) {\n            arr[i] = 0;\n        }\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                arr[i]++;\n            } else {\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(arr[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpb7mwedf5.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i]++;\n            else paren[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpatxmbuv1.java:36)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int count = 0;\n        int len = lst.size();\n        while (i < len) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            } else if (lst.get(i).equals(\")\")) {\n                count--;\n            }\n            i++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpctarr9sj.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> stack = new Stack<>();\n        for(String s: lst) {\n            for(int i = 0; i < s.length(); i++) {\n                if(s.charAt(i) == '(') {\n                    stack.push('(');\n                } else if(s.charAt(i) == ')') {\n                    if(stack.isEmpty()) {\n                        return \"No\";\n                    } else if(stack.pop() == '(') {\n                        continue;\n                    } else {\n                        return \"No\";\n                    }\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3_nx53i2.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] stack = new int[lst.size()];\n        int i = 0;\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                stack[i]++;\n            } else if(s.equals(\")\")) {\n                stack[i]--;\n            }\n            i++;\n        }\n        for(i = 0; i < stack.length; i++) {\n            if(stack[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptieihd5c.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = i + 1; j < lst.size(); j++) {\n                if (parens[i] == 1 && parens[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv13dpy_3.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i, j, len, count;\n        String s;\n        for (i = 0; i < lst.size(); i++) {\n            s = lst.get(i);\n            len = s.length();\n            count = 0;\n            for (j = 0; j < len; j++) {\n                if (s.charAt(j) == '(') {\n                    count++;\n                } else if (s.charAt(j) == ')') {\n                    count--;\n                }\n            }\n            if (count != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp72t5x77g.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int count = 0;\n        int len = lst.size();\n        while (i < len) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            }\n            if (lst.get(i).equals(\")\")) {\n                count--;\n            }\n            i++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp1ab_ox37.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] dp = new int[n];\n        for(int i = 0; i < n; i++) {\n            dp[i] = 0;\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(j) == '(') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(j) == '(') {\n                    if(dp[i] == dp[j] + 1) {\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpecbgf1ym.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < parens.length; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfrxtzraw.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            paren[i] = 0;\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i]++;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i]--;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(paren[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxp2ysf_a.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                sb.append(s);\n            } else if(s.equals(\")\")) {\n                if(sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length()-1);\n            } else {\n                sb.append(s);\n            }\n        }\n        if(sb.length() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_e5vklf0.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmuh7xxan.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n            c[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i]++;\n            } else {\n                p[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\")\")) {\n                c[i]++;\n            } else {\n                c[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0 || c[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpn94o9ana.java:52)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == 1) {\n                        parens[j] = 0;\n                        parens[i] = 0;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpekmv1ugb.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                stack.push(i);\n            } else if(lst.get(i).equals(\")\")) {\n                if(stack.isEmpty()) {\n                    return \"No\";\n                } else {\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpu2f2fmie.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                sb.append(\"(\");\n            } else if(s.equals(\")\")) {\n                if(sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.append(\")\");\n            }\n        }\n        if(sb.length() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpo4pxlogh.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int count = 0;\n        while (i < lst.size() && j < lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            }\n            if (lst.get(j).equals(\")\")) {\n                count--;\n            }\n            if (count == 0) {\n                i++;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        if (count == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqqletj_b.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n        for(String s : lst) {\n            for(int i = 0; i < s.length(); i++) {\n                if(s.charAt(i) == '(') {\n                    stack.push('(');\n                } else if(s.charAt(i) == ')') {\n                    if(stack.isEmpty()) {\n                        return \"No\";\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpleszgitu.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> stack = new Stack<>();\n        for(String s : lst) {\n            for(char c : s.toCharArray()) {\n                if(c == '(') {\n                    stack.push('(');\n                } else if(c == ')') {\n                    if(stack.isEmpty()) {\n                        return \"No\";\n                    } else {\n                        stack.pop();\n                    }\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkrdichmv.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"No\";\n        if (len == 1) return \"Yes\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                sb.append(lst.get(i));\n            } else {\n                if (sb.length() == 0) return \"No\";\n                sb.append(lst.get(i));\n            }\n        }\n        if (sb.length() == 0) return \"No\";\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwpdms75g.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if(lst.size() == 0) return \"No\";\n        int l = lst.size();\n        int r = lst.size();\n        int[] left = new int[l];\n        int[] right = new int[r];\n        for(int i = 0; i < l; i++) left[i] = 0;\n        for(int i = 0; i < r; i++) right[i] = 0;\n        for(int i = 0; i < l; i++) {\n            for(int j = 0; j < r; j++) {\n                if(lst.get(i).charAt(j) == '(') left[i]++;\n                if(lst.get(i).charAt(j) == ')') right[i]++;\n            }\n        }\n        for(int i = 0; i < l; i++) {\n            if(left[i] != right[i]) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 1\n\tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\tat Problem.matchParens(tmpaio7rznv.java:32)\n\tat Problem.main(tmpaio7rznv.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[26];\n        for(String s: lst) {\n            for(int i = 0; i < s.length(); i++) {\n                count[s.charAt(i) - 'a']++;\n            }\n        }\n        for(int i = 0; i < 26; i++) {\n            if(count[i] % 2 != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index -57 out of bounds for length 26\n\tat Problem.matchParens(tmp6wtxis5f.java:26)\n\tat Problem.main(tmp6wtxis5f.java:37)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmperlhjg__.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        if (n == 2) return \"Yes\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i]++;\n            else if (lst.get(i).equals(\")\")) p[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpg34cj2wx.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                sb.append(lst.get(i));\n                if (i + 1 < len && lst.get(i + 1).equals(\")\")) {\n                    sb.append(lst.get(i + 1));\n                    i++;\n                } else {\n                    return \"No\";\n                }\n            } else {\n                sb.append(lst.get(i));\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp0kana_r.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\") && lst.get(j).equals(\")\")) {\n                lst.set(i, \")\");\n                lst.set(j, \"(\");\n            } else if (lst.get(i).equals(\"(\") && lst.get(j).equals(\"(\")) {\n                lst.set(i, \")\");\n                lst.set(j, \"(\");\n            } else if (lst.get(i).equals(\")\") && lst.get(j).equals(\"(\")) {\n                lst.set(i, \"(\");\n                lst.set(j, \")\");\n            } else if (lst.get(i).equals(\"(\") && lst.get(j).equals(\")\")) {\n                lst.set(i, \")\");\n                lst.set(j, \"(\");\n            } else {\n                i++;\n                j--;\n            }\n        }\n        if (lst.get(i).equals(\"(\") && lst.get(j).equals(\")\")) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjkadbged.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else if (s.equals(\")\")) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(s);\n            }\n        }\n        return sb.length() == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmparxmoysy.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        int[] q = new int[n];\n        for(int i = 0; i < n; i++) {\n            p[i] = 0;\n            q[i] = 0;\n        }\n        for(int i = 0; i < n; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                p[i]++;\n            } else {\n                q[i]++;\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(p[i] > q[i]) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpm2oxbdjm.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] open = new int[len];\n        int[] close = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) open[i] = 1;\n            else if (lst.get(i).equals(\")\")) close[i] = 1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (open[i] == 1 && close[i] == 1) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (open[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (close[j] == 1) {\n                        open[i]--;\n                        open[j]--;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (close[i] == 1) {\n                for (int j = i - 1; j >= 0; j--) {\n                    if (open[j] == 1) {\n                        close[i]--;\n                        close[j]--;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (open[i] != 0 || close[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9k_2ugc5.java:64)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        for(int i = 0; i < arr.length; i++) {\n            arr[i] = 0;\n        }\n        for(int i = 0; i < arr.length; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                arr[i] = 1;\n            }\n            else if(lst.get(i).equals(\")\")) {\n                arr[i] = -1;\n            }\n        }\n        for(int i = 0; i < arr.length; i++) {\n            if(arr[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6fpt3mbk.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                sb.append(s);\n            } else {\n                if(sb.length() > 0 && s.equals(\")\")) {\n                    sb.deleteCharAt(sb.length() - 1);\n                } else {\n                    sb.append(s);\n                }\n            }\n        }\n        return sb.length() == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqk_m1pzx.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (parens[i] == 1) {\n                sb.append(lst.get(i));\n            } else if (parens[i] == -1) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                } else {\n                    sb.deleteCharAt(sb.length() - 1);\n                }\n            }\n        }\n        if (sb.length() == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppg96zfs0.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] p = new int[n];\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else p[i] = 0;\n            if (lst.get(i).equals(\")\")) c[i] = 1;\n            else c[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0 && c[i] == 0) return \"No\";\n            if (p[i] == 1 && c[i] == 0) return \"No\";\n            if (p[i] == 0 && c[i] == 1) return \"No\";\n            if (p[i] == 1 && c[i] == 1) return \"Yes\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkblfs7bb.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        int[] dp = new int[len];\n        dp[0] = 1;\n        for(int i = 1; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) dp[i] = dp[i-1] + 1;\n            else dp[i] = dp[i-1];\n        }\n        for(int i = len-1; i >= 0; i--) {\n            if(lst.get(i).equals(\")\")) dp[i] = dp[i] - 1;\n            else if(dp[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpu_t8z191.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (lst.get(i).equals(\")\")) {\n                dp[i] = dp[i + 1] + 1;\n            } else {\n                dp[i] = dp[i + 1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2\n\tat Problem.matchParens(tmp0v9wdeo8.java:38)\n\tat Problem.main(tmp0v9wdeo8.java:49)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmvms5rxm.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            if(s.charAt(0) == '(') {\n                count[0]++;\n            } else {\n                count[1]++;\n            }\n        }\n        if(count[0] == 0 || count[1] == 0) {\n            return \"No\";\n        }\n        if(count[0] == count[1]) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwsnl6cjk.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        int count = 0;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            }\n            if (lst.get(j).equals(\")\")) {\n                count--;\n            }\n            i++;\n            j--;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpd5491ndm.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                count[0]++;\n            } else {\n                count[1]++;\n            }\n        }\n        if(count[0] == 0 || count[1] == 0) {\n            return \"No\";\n        }\n        if(count[0] == count[1]) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplhcbgfy7.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp88iswb8f.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i]++;\n            } else {\n                p[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpz5jz_lqf.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] stack = new int[lst.size()];\n        int top = 0;\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                stack[top++] = 1;\n            } else if(s.equals(\")\")) {\n                if(stack[top-1] == 0) {\n                    return \"No\";\n                } else {\n                    stack[--top] = 0;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n\tat Problem.matchParens(tmpil1jxr7a.java:29)\n\tat Problem.main(tmpil1jxr7a.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        int i = 0;\n        for(String s : lst) {\n            arr[i++] = s.length();\n        }\n        return matchParens(arr);\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpl8jd2axu.java:28: error: incompatible types: int[] cannot be converted to ArrayList<String>\n        return matchParens(arr);\n                           ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5vamb7w4.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmvms5rxm.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        String s = lst.get(0);\n        for (int i = 1; i < n; i++) {\n            s += lst.get(i);\n        }\n        int[] p = new int[n];\n        int[] q = new int[n];\n        int[] r = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n            q[i] = 0;\n            r[i] = 0;\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '(') {\n                p[i]++;\n                cnt++;\n            } else if (s.charAt(i) == ')') {\n                q[i]++;\n                cnt++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != q[i]) return \"No\";\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != r[i]) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa619ik18.java:57)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else if (lst.get(i).equals(\")\")) p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0) {\n                for (int j = i + 1; j < n; j++) {\n                    if (p[j] == 0) {\n                        if (lst.get(i).equals(\")\") && lst.get(j).equals(\"(\")) {\n                            p[i] = 1;\n                            p[j] = -1;\n                            break;\n                        }\n                        if (lst.get(i).equals(\"(\")) {\n                            p[i] = 1;\n                            p[j] = -1;\n                            break;\n                        }\n                        if (lst.get(j).equals(\")\")) {\n                            p[i] = -1;\n                            p[j] = 1;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpo84z_caj.java:60)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i, j, len, len1, len2, parens, parens1, parens2;\n        StringBuilder sb = new StringBuilder();\n        for (i = 0; i < lst.size(); i++) {\n            len = lst.get(i).length();\n            parens = 0;\n            for (j = 0; j < len; j++) {\n                if (lst.get(i).charAt(j) == '(') {\n                    parens++;\n                } else if (lst.get(i).charAt(j) == ')') {\n                    parens--;\n                }\n            }\n            if (parens != 0) {\n                return \"No\";\n            }\n            len1 = lst.get(i).length();\n            parens1 = 0;\n            for (j = 0; j < len1; j++) {\n                if (lst.get(i).charAt(j) == '(') {\n                    parens1++;\n                } else if (lst.get(i).charAt(j) == ')') {\n                    parens1--;\n                }\n            }\n            if (parens1 != 0) {\n                return \"No\";\n            }\n            len2 = lst.get(i).length();\n            parens2 = 0;\n            for (j = 0; j < len2; j++) {\n                if (lst.get(i).charAt(j) == '(') {\n                    parens2++;\n                } else if (lst.get(i).charAt(j) == ')') {\n                    parens2--;\n                }\n            }\n            if (parens2 != 0) {\n                return \"No\";\n            }\n            sb.append(lst.get(i));\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppkugq7or.java:67)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < lst.size(); j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5i68uccc.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] parens = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (parens[j] == 1) {\n                        parens[j] = 0;\n                        parens[i] = 0;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpng_3se4k.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else if (lst.get(i).equals(\")\")) p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0) {\n                for (int j = 0; j < n; j++) {\n                    if (p[j] == 1 && i != j) {\n                        p[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc11b2urd.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                count[0]++;\n            } else if (s.equals(\")\")) {\n                count[1]++;\n            }\n        }\n        if (count[0] == count[1]) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprbb2f5zd.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        if (n == 2) return \"Yes\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                p[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptp5j6vet.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 0) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == 0) {\n                        if (lst.get(i).equals(\")\") && lst.get(j).equals(\"(\")) {\n                            parens[i] = 1;\n                            parens[j] = -1;\n                            continue;\n                        }\n                        if (lst.get(i).equals(\"(\")) {\n                            parens[i] = 1;\n                            parens[j] = -1;\n                            continue;\n                        }\n                        if (lst.get(j).equals(\")\")) {\n                            parens[i] = -1;\n                            parens[j] = 1;\n                            continue;\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsj7xqg6t.java:60)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i]++;\n            else if (lst.get(i).equals(\")\")) p[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpn5kkbzff.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for(int i = 0; i < paren.length; i++) {\n            if(paren[i] == 1) {\n                for(int j = i + 1; j < paren.length; j++) {\n                    if(paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < paren.length; i++) {\n            if(paren[i] == 1) {\n                return \"Yes\";\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpw_vfjaqm.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    i++;\n                    j--;\n                } else {\n                    return \"No\";\n                }\n            } else {\n                if (lst.get(j).equals(\")\")) {\n                    return \"No\";\n                } else {\n                    j--;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpf7x_d4q0.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < parens.length; j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcztupmpt.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        int[] left = new int[lst.size()];\n        int[] right = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            arr[i] = lst.get(i).length();\n            left[i] = 0;\n            right[i] = 0;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = i + 1; j < lst.size(); j++) {\n                if (lst.get(i).charAt(left[i]) == '(' && lst.get(j).charAt(right[j]) == ')') {\n                    left[i]++;\n                    right[j]++;\n                } else if (lst.get(i).charAt(left[i]) == ')' && lst.get(j).charAt(right[j]) == '(') {\n                    left[i]++;\n                    right[j]++;\n                } else if (lst.get(i).charAt(left[i]) == '(' && lst.get(j).charAt(right[j]) == ')') {\n                    left[i]++;\n                    right[j]++;\n                } else if (lst.get(i).charAt(left[i]) == ')' && lst.get(j).charAt(right[j]) == '(') {\n                    left[i]++;\n                    right[j]++;\n                }\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (left[i] != arr[i] || right[i] != arr[i]) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmputc22qfp.java:56)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < paren.length; i++) {\n            if (paren[i] == 1) {\n                count++;\n            } else if (paren[i] == -1) {\n                count--;\n            }\n        }\n        if (count == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9qockagt.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            for(int j = i + 1; j < parens.length; j++) {\n                if(parens[i] == 1 && parens[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxhva51yl.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmptzdaphjo.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp88iswb8f.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        String s = lst.get(0);\n        for (int i = 1; i < n; i++) {\n            if (s.charAt(0) != '(' && s.charAt(s.length() - 1) != ')') return \"No\";\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length() - 1) == ')') {\n                    s = s.substring(1, s.length() - 1);\n                } else {\n                    return \"No\";\n                }\n            } else {\n                if (s.charAt(s.length() - 1) == '(') {\n                    s = s.substring(0, s.length() - 1);\n                } else {\n                    return \"No\";\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp1swidi2d.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n            } else if(s.equals(\")\")) {\n                if(stack.isEmpty()) {\n                    return \"No\";\n                } else {\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjba06hg7.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < parens.length; j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] == -1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3vth7xof.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        for(int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for(int i = 0; i < n; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                p[i]++;\n            }\n            else {\n                p[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(p[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpu0kt16sr.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (paren[j] == 1) {\n                        paren[j] = 0;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpm84uuzl5.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        int count = 0;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            } else if (lst.get(j).equals(\")\")) {\n                count--;\n            }\n            i++;\n            j--;\n        }\n        return count == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8hlhzcgl.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] paren = new int[len];\n        for (int i = 0; i < len; i++) {\n            paren[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                paren[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                paren[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp55xcqwnr.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i] = 1;\n            } else {\n                p[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\")\")) {\n                c[i] = 1;\n            } else {\n                c[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0 && c[i] == 0) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0) {\n                for (int j = 0; j < n; j++) {\n                    if (c[j] == 1) {\n                        p[j] = 1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1 && c[i] == 0) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1) {\n                for (int j = 0; j < n; j++) {\n                    if (c[j] == 1) {\n                        p[j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0 && c[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4nrwg1l6.java:78)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for(int i = 0; i < paren.length; i++) {\n            if(paren[i] == 1) {\n                for(int j = i + 1; j < paren.length; j++) {\n                    if(paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < paren.length; i++) {\n            if(paren[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpka40b9ky.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if (lst.size() == 0) return \"Yes\";\n        int[] paren = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < lst.size(); j++) {\n                    if (paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpin5brya9.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = i + 1; j < lst.size(); j++) {\n                if(paren[i] == 1 && paren[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqb6fr_9c.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if (lst.size() == 0) return \"Yes\";\n        if (lst.size() == 1) return \"No\";\n        int n = lst.size();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) arr[i]++;\n            if (lst.get(i).equals(\")\")) arr[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (arr[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpg9_ea3bg.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = i + 1; j < lst.size(); j++) {\n                if(paren[i] == 1 && paren[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqb6fr_9c.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                sb.append(lst.get(i));\n            } else {\n                if (sb.length() == 0) return \"No\";\n                sb.append(lst.get(i));\n            }\n        }\n        if (sb.length() == 0) return \"Yes\";\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpb5qllb4y.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmperlhjg__.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        int[] cnt = new int[lst.size()];\n        for(int i = 0; i < arr.length; i++) {\n            arr[i] = 0;\n            cnt[i] = 0;\n        }\n        for(int i = 0; i < arr.length; i++) {\n            for(int j = 0; j < arr.length; j++) {\n                if(lst.get(i).charAt(arr[i]) == '(' && lst.get(j).charAt(cnt[j]) == ')') {\n                    arr[i]++;\n                    cnt[j]++;\n                }\n            }\n        }\n        for(int i = 0; i < arr.length; i++) {\n            if(arr[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplaubiapi.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmvms5rxm.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < lst.size(); j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpok7wfwsb.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp88iswb8f.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        int[] open = new int[lst.size()];\n        int[] close = new int[lst.size()];\n        int[] count = new int[lst.size()];\n        int[] max = new int[lst.size()];\n        int[] min = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            parens[i] = 0;\n            open[i] = 0;\n            close[i] = 0;\n            count[i] = 0;\n            max[i] = 0;\n            min[i] = 0;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                open[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                close[i]++;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (open[i] > close[i]) {\n                count[i] = open[i] - close[i];\n                max[i] = open[i];\n                min[i] = close[i];\n            } else if (open[i] < close[i]) {\n                count[i] = close[i] - open[i];\n                max[i] = close[i];\n                min[i] = open[i];\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (count[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp57axs0h6.java:63)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmperlhjg__.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"No\";\n        int[] parens = new int[len];\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if(lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for(int i = 0; i < len; i++) {\n            if(parens[i] == 1) {\n                for(int j = i+1; j < len; j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(parens[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9zm7d67d.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < parens.length; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpeuatkfrm.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> stack = new Stack<>();\n        for(String s: lst) {\n            for(int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if(c == '(') {\n                    stack.push(c);\n                } else {\n                    if(stack.isEmpty()) {\n                        return \"No\";\n                    }\n                    char top = stack.pop();\n                    if(top != '(') {\n                        return \"No\";\n                    }\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0j8l19wp.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] stack = new int[lst.size()];\n        int top = 0;\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                stack[top++] = i;\n            } else if(lst.get(i).equals(\")\")) {\n                if(top == 0) {\n                    return \"No\";\n                }\n                int j = stack[--top];\n                if(lst.get(j).equals(\"(\")) {\n                    stack[top++] = j;\n                } else {\n                    stack[top++] = j;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfqc76ztf.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i] = 1;\n            } else {\n                p[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\")\")) {\n                c[i] = 1;\n            } else {\n                c[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1 && c[i] == 0) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0 && c[i] == 1) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1 && c[i] == 1) {\n                return \"No\";\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 0 && c[i] == 0) {\n                return \"Yes\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0tk9u8ik.java:63)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[26];\n        for (String s : lst) {\n            for (int i = 0; i < s.length(); i++) {\n                count[s.charAt(i) - 'a']++;\n            }\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] % 2 != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index -57 out of bounds for length 26\n\tat Problem.matchParens(tmp0cp8us66.java:26)\n\tat Problem.main(tmp0cp8us66.java:37)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = i + 1; j < lst.size(); j++) {\n                if (parens[i] == 1 && parens[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3slx_k1f.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (p[j] == -1) {\n                        p[j] = 1;\n                        p[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == -1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp76ajxbm3.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n            }\n            else if(s.equals(\")\")) {\n                if(stack.isEmpty()) {\n                    return \"No\";\n                }\n                else {\n                    stack.pop();\n                }\n            }\n        }\n        if(stack.isEmpty()) {\n            return \"Yes\";\n        }\n        else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpendbvg2c.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                sb.append(s);\n            } else if(s.equals(\")\")) {\n                if(sb.length() == 0) return \"No\";\n                sb.deleteCharAt(sb.length()-1);\n            } else {\n                sb.append(s);\n            }\n        }\n        return sb.length() == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpj5kjb06n.java:37)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmph0bgn8gr.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < parens.length; j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcztupmpt.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(\"(\");\n            } else if (s.equals(\")\")) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(s);\n            }\n        }\n        if (sb.length() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpl3rzmuol.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] open = new int[len];\n        int[] close = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) open[i]++;\n            else if (lst.get(i).equals(\")\")) close[i]++;\n        }\n        for (int i = 0; i < len; i++) {\n            if (open[i] != close[i]) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsnjexlvg.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        int[] parens = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (parens[j] == -1) {\n                        sb.append(lst.get(i));\n                        sb.append(lst.get(j));\n                        for (int k = 0; k < n; k++) {\n                            if (k != i && k != j) {\n                                parens[k] = 0;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == -1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9kjod0jl.java:54)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < parens.length; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfrxtzraw.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else {\n                if (sb.length() > 0 && s.equals(\")\")) {\n                    sb.deleteCharAt(sb.length() - 1);\n                } else {\n                    return \"No\";\n                }\n            }\n        }\n        return sb.length() == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpg7b5mhrp.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            count[s.charAt(0) - '(']++;\n            count[s.charAt(s.length() - 1) - '(']--;\n        }\n        for(int i = 0; i < 2; i++) {\n            if(count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp95lnfw1q.java:35)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        int i = 0;\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                parens[i] = 1;\n            } else if(s.equals(\")\")) {\n                parens[i] = -1;\n            }\n            i++;\n        }\n        for(i = 0; i < parens.length; i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < parens.length; j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            } else if(parens[i] == -1) {\n                for(int j = i - 1; j >= 0; j--) {\n                    if(parens[j] == 1) {\n                        parens[j] = -1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(i = 0; i < parens.length; i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpdj9kmhl6.java:60)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> stack = new Stack<>();\n        for(String s : lst) {\n            for(char c : s.toCharArray()) {\n                if(c == '(') {\n                    stack.push('(');\n                } else if(c == ')') {\n                    if(stack.isEmpty()) {\n                        return \"No\";\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8heu17w9.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = dp[i-1];\n            }\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (lst.get(i).equals(\")\")) {\n                dp[i] = dp[i] + dp[i+1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == n) return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2\n\tat Problem.matchParens(tmpmqct9vh6.java:38)\n\tat Problem.main(tmpmqct9vh6.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] dp = new int[n];\n        for(int i = 0; i < n; i++) {\n            dp[i] = 0;\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(0) == '(' && lst.get(j).charAt(0) == '(') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(0) == ')' && lst.get(j).charAt(0) == '(') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(0) == '(' && lst.get(j).charAt(0) == ')') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(0) == ')' && lst.get(j).charAt(0) == ')') {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(lst.get(i).charAt(0) == '(' && lst.get(j).\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpp1_jor7e.java:58: error: <identifier> expected\n                if(lst.get(i).charAt(0) == '(' && lst.get(j).\n                                                             ^\n/tmp/tmpp1_jor7e.java:59: error: illegal start of statement\n    }\n    ^\n/tmp/tmpp1_jor7e.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            parens[i] = 0;\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i]++;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i]--;\n            }\n        }\n        for(int i = 0; i < parens.length; i++) {\n            if(parens[i] < 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc_powkrl.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmperlhjg__.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"No\";\n        int[] parens = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6s5ry5md.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if(lst.size() == 0) return \"Yes\";\n        if(lst.size() == 1) return \"No\";\n        int i = 0;\n        int j = lst.size() - 1;\n        while(i < j) {\n            if(lst.get(i).equals(\"(\")) {\n                if(lst.get(j).equals(\")\")) {\n                    lst.remove(i);\n                    lst.remove(j);\n                    i++;\n                    j--;\n                }\n                else {\n                    i++;\n                }\n            }\n            else {\n                if(lst.get(j).equals(\")\")) {\n                    lst.remove(j);\n                    j--;\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n        if(lst.get(i).equals(\"(\")) return \"No\";\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjdxfd1gl.java:54)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"No\";\n        int[] paren = new int[len];\n        for(int i = 0; i < len; i++) {\n            paren[i] = 0;\n        }\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i]++;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i]--;\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(paren[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkevkfkj_.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> stack = new Stack<>();\n        for (String s : lst) {\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (c == '(') {\n                    stack.push(c);\n                } else if (c == ')') {\n                    if (stack.isEmpty()) {\n                        return \"No\";\n                    } else {\n                        stack.pop();\n                    }\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplmqf0aq_.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        int[] parens_stack = new int[lst.size()];\n        int parens_count = 0;\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n                parens_count++;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n                parens_count--;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                parens_stack[parens_count] = i;\n                parens_count++;\n            }\n        }\n        for(int i = 0; i < parens_count; i++) {\n            if(parens_stack[i] == -1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwvanuz40.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < lst.size(); j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5i68uccc.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        if(len == 1) return \"No\";\n        int[] paren = new int[len];\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if(lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for(int i = 0; i < len; i++) {\n            if(paren[i] == 1) {\n                for(int j = i + 1; j < len; j++) {\n                    if(paren[j] == 1) {\n                        paren[i] = -1;\n                        paren[j] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(paren[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpb4nxbjp3.java:49)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i]++;\n            else if (lst.get(i).equals(\")\")) paren[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8bwit2_s.java:37)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int p = 0;\n        int q = 0;\n        int count = 0;\n        while (i < lst.size() && j < lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                p++;\n            }\n            if (lst.get(j).equals(\")\")) {\n                q++;\n            }\n            if (p == q) {\n                count++;\n            }\n            i++;\n            j++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfwg9fqbp.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"No\";\n        if (n == 1) return \"Yes\";\n        int[] parens = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if (lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (parens[j] == 1) {\n                        parens[j] = 0;\n                        parens[i] = 0;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5gq8jj_7.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"No\";\n        int[] paren = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzhg7e2_8.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else {\n                if (sb.length() > 0) {\n                    if (sb.charAt(sb.length() - 1) == '(') {\n                        sb.append(s);\n                    } else {\n                        return \"No\";\n                    }\n                } else {\n                    sb.append(s);\n                }\n            }\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxl5izv9h.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] parens = new int[n];\n        for(int i = 0; i < n; i++) {\n            if(lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if(lst.get(i).equals(\")\")) parens[i] = -1;\n        }\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(parens[i] == 1 && parens[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2vchcm45.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"No\";\n        int[] arr = new int[len];\n        for(int i = 0; i < len; i++) {\n            arr[i] = 0;\n        }\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) arr[i]++;\n            else arr[i]--;\n        }\n        for(int i = 0; i < len; i++) {\n            if(arr[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsc9tdn25.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            count[s.charAt(0) - '(']++;\n            count[s.charAt(s.length() - 1) - '(']--;\n        }\n        for(int i = 0; i < 2; i++) {\n            if(count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp95lnfw1q.java:35)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] p = new int[n];\n        int[] q = new int[n];\n        int[] r = new int[n];\n        int[] s = new int[n];\n        int[] t = new int[n];\n        int[] u = new int[n];\n        int[] v = new int[n];\n        int[] w = new int[n];\n        int[] x = new int[n];\n        int[] y = new int[n];\n        int[] z = new int[n];\n        int[] a = new int[n];\n        int[] b = new int[n];\n        int[] c = new int[n];\n        int[] d = new int[n];\n        int[] e = new int[n];\n        int[] f = new int[n];\n        int[] g = new int[n];\n        int[] h = new int[n];\n        int[] i = new int[n];\n        int[] j = new int[n];\n        int[] k = new int[n];\n        int[] l = new int[n];\n        int[] m = new int[n];\n        int[] n = new int[n];\n        int[] o = new int[n];\n        int[] p1 = new int[n];\n        int[] p2 = new int[n];\n        int[] p3 = new int[n];\n        int[] p4 = new int[n];\n        int[] p5 = new int[n];\n        int[] p6 = new int[n];\n        int[] p7 = new int[n];\n        int[] p8 = new int[n];\n        int[] p9 = new int[n];\n        int[] p10 = new int[n];\n        int[] p11 = new int[n];\n        int[] p12 = new int[n];\n        int[] p13 = new int[n];\n        int[] p14 = new int[n];\n        int[] p15 = new int[n];\n        int[] p16 = new int[n];\n        int[] p17 = new int[n];\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "/tmp/tmpcv4un5ka.java:49: error: variable n is already defined in method matchParens(ArrayList<String>)\n        int[] n = new int[n];\n              ^\n/tmp/tmpcv4un5ka.java:49: error: incompatible types: int[] cannot be converted to int\n        int[] n = new int[n];\n                          ^\n/tmp/tmpcv4un5ka.java:50: error: incompatible types: int[] cannot be converted to int\n        int[] o = new int[n];\n                          ^\n/tmp/tmpcv4un5ka.java:51: error: incompatible types: int[] cannot be converted to int\n        int[] p1 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:52: error: incompatible types: int[] cannot be converted to int\n        int[] p2 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:53: error: incompatible types: int[] cannot be converted to int\n        int[] p3 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:54: error: incompatible types: int[] cannot be converted to int\n        int[] p4 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:55: error: incompatible types: int[] cannot be converted to int\n        int[] p5 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:56: error: incompatible types: int[] cannot be converted to int\n        int[] p6 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:57: error: incompatible types: int[] cannot be converted to int\n        int[] p7 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:58: error: incompatible types: int[] cannot be converted to int\n        int[] p8 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:59: error: incompatible types: int[] cannot be converted to int\n        int[] p9 = new int[n];\n                           ^\n/tmp/tmpcv4un5ka.java:60: error: incompatible types: int[] cannot be converted to int\n        int[] p10 = new int[n];\n                            ^\n/tmp/tmpcv4un5ka.java:61: error: incompatible types: int[] cannot be converted to int\n        int[] p11 = new int[n];\n                            ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else if (s.equals(\")\")) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(s);\n            }\n        }\n        if (sb.length() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppopa1n48.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if (lst.size() == 0) return \"Yes\";\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.remove(i);\n                    lst.remove(j);\n                    i++;\n                    j--;\n                } else {\n                    i++;\n                }\n            } else {\n                if (lst.get(j).equals(\")\")) {\n                    lst.remove(j);\n                    j--;\n                } else {\n                    j--;\n                }\n            }\n        }\n        if (lst.size() == 0) return \"Yes\";\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpy60oft9y.java:49)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            parens[i] = 0;\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = 0; j < lst.size(); j++) {\n                if(lst.get(i).charAt(0) == '(' && lst.get(j).charAt(0) == '(') {\n                    parens[i]++;\n                    parens[j]++;\n                }\n                if(lst.get(i).charAt(0) == ')' && lst.get(j).charAt(0) == ')') {\n                    parens[i]--;\n                    parens[j]--;\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfo2fgvxp.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            parens[i] = 0;\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = 0; j < lst.size(); j++) {\n                if(lst.get(i).charAt(j) == '(') {\n                    parens[i]++;\n                }\n                if(lst.get(i).charAt(j) == ')') {\n                    parens[i]--;\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 1\n\tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\tat Problem.matchParens(tmpvlbqc0fk.java:29)\n\tat Problem.main(tmpvlbqc0fk.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        int j = 0;\n        int open = 0;\n        int close = 0;\n        while (i < lst.size() && j < lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                open++;\n            } else if (lst.get(j).equals(\")\")) {\n                close++;\n            }\n            i++;\n            j++;\n        }\n        if (open == close) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpd6ve2nzd.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpeif_b1o3.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i]++;\n            else if (lst.get(i).equals(\")\")) p[i]--;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpn5kkbzff.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                i++;\n            } else if (lst.get(j).equals(\")\")) {\n                j--;\n            } else {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8941q09e.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        int[] q = new int[n];\n        int[] r = new int[n];\n        int[] s = new int[n];\n        int[] t = new int[n];\n        int[] u = new int[n];\n        int[] v = new int[n];\n        int[] w = new int[n];\n        int[] x = new int[n];\n        int[] y = new int[n];\n        int[] z = new int[n];\n        int[] a = new int[n];\n        int[] b = new int[n];\n        int[] c = new int[n];\n        int[] d = new int[n];\n        int[] e = new int[n];\n        int[] f = new int[n];\n        int[] g = new int[n];\n        int[] h = new int[n];\n        int[] i = new int[n];\n        int[] j = new int[n];\n        int[] k = new int[n];\n        int[] l = new int[n];\n        int[] m = new int[n];\n        int[] n = new int[n];\n        int[] o = new int[n];\n        int[] p1 = new int[n];\n        int[] q1 = new int[n];\n        int[] r1 = new int[n];\n        int[] s1 = new int[n];\n        int[] t1 = new int[n];\n        int[] u1 = new int[n];\n        int[] v1 = new int[n];\n        int[] w1 = new int[n];\n        int[] x1 = new int[n];\n        int[] y1 = new int[n];\n        int[] z1 = new int[n];\n        int[] a1 = new int[n];\n        int[] b1 = new int[n];\n        int[] c1 = new int[n];\n        int[] d1 = new int[n];\n        int[] e1 = new int[n];\n        int[] f1 = new int[n];\n        int[] g1 = new int[n];\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "/tmp/tmpor2_ool9.java:48: error: variable n is already defined in method matchParens(ArrayList<String>)\n        int[] n = new int[n];\n              ^\n/tmp/tmpor2_ool9.java:48: error: incompatible types: int[] cannot be converted to int\n        int[] n = new int[n];\n                          ^\n/tmp/tmpor2_ool9.java:49: error: incompatible types: int[] cannot be converted to int\n        int[] o = new int[n];\n                          ^\n/tmp/tmpor2_ool9.java:50: error: incompatible types: int[] cannot be converted to int\n        int[] p1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:51: error: incompatible types: int[] cannot be converted to int\n        int[] q1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:52: error: incompatible types: int[] cannot be converted to int\n        int[] r1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:53: error: incompatible types: int[] cannot be converted to int\n        int[] s1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:54: error: incompatible types: int[] cannot be converted to int\n        int[] t1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:55: error: incompatible types: int[] cannot be converted to int\n        int[] u1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:56: error: incompatible types: int[] cannot be converted to int\n        int[] v1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:57: error: incompatible types: int[] cannot be converted to int\n        int[] w1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:58: error: incompatible types: int[] cannot be converted to int\n        int[] x1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:59: error: incompatible types: int[] cannot be converted to int\n        int[] y1 = new int[n];\n                           ^\n/tmp/tmpor2_ool9.java:60: error: incompatible types: int[] cannot be converted to int\n        int[] z1 = new int[n];\n                           ^\n/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if (lst.size() == 0) return \"Yes\";\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.remove(i);\n                    lst.remove(j);\n                    i++;\n                    j--;\n                } else {\n                    i++;\n                }\n            } else {\n                j--;\n            }\n        }\n        if (lst.size() == 0) return \"Yes\";\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv80ops2o.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < lst.size(); j++) {\n                    if(parens[j] == -1) {\n                        parens[j] = 1;\n                        parens[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5i68uccc.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        int[] parens = new int[len];\n        for(int i = 0; i < len; i++) {\n            parens[i] = 0;\n        }\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i]++;\n            } else if(lst.get(i).equals(\")\")) {\n                parens[i]--;\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(parens[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4ignt7tr.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        if(len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < len; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp03s6oi27.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        int i = 0;\n        while(i < paren.length) {\n            if(paren[i] == 1) {\n                i++;\n                while(i < paren.length && paren[i] == 1) {\n                    i++;\n                }\n                if(i == paren.length) {\n                    return \"Yes\";\n                }\n            } else if(paren[i] == -1) {\n                i++;\n                while(i < paren.length && paren[i] == -1) {\n                    i++;\n                }\n                if(i == paren.length) {\n                    return \"No\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292995,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] p = new int[n];\n        int[] q = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n            q[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                q[i] = 1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1 && q[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvm36amxl.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] open = new int[lst.size()];\n        int[] close = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                open[i] = 1;\n            } else {\n                open[i] = 0;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\")\")) {\n                close[i] = 1;\n            } else {\n                close[i] = 0;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (open[i] == 1 && close[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpk82tanya.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] paren = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] == 0) {\n                for (int j = i + 1; j < n; j++) {\n                    if (paren[j] == 1) {\n                        paren[i] = -1;\n                        paren[j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpe2u29wfn.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "/tmp/tmpfxl43bww.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] stack = new int[lst.size()];\n        int top = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                stack[top++] = i;\n            } else if (lst.get(i).equals(\")\")) {\n                if (top == 0) return \"No\";\n                int j = stack[--top];\n                if (lst.get(j).equals(\"(\")) return \"No\";\n                int k = stack[top];\n                if (lst.get(k).equals(\")\")) return \"No\";\n                lst.set(j, lst.get(j) + lst.get(k));\n                lst.set(k, \"\") ;\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfm24o6vd.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        int i = 0;\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                parens[i] = 1;\n            } else if(s.equals(\")\")) {\n                parens[i] = -1;\n            }\n            i++;\n        }\n        for(i = 0; i < parens.length; i++) {\n            if(parens[i] == 1) {\n                if(i == 0) {\n                    continue;\n                }\n                if(parens[i - 1] == -1) {\n                    continue;\n                }\n                if(parens[i - 1] == 1) {\n                    parens[i - 1] = 0;\n                    parens[i] = 0;\n                    continue;\n                }\n            } else if(parens[i] == -1) {\n                if(i == parens.length - 1) {\n                    continue;\n                }\n                if(parens[i + 1] == 1) {\n                    parens[i + 1] = 0;\n                    parens[i] = 0;\n                    continue;\n                }\n            }\n        }\n        for(i = 0; i < parens.length; i++) {\n            if(parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpthm84h0m.java:65)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = 0;\n        int len = lst.size();\n        int count = 0;\n        while (i < len) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            } else if (lst.get(i).equals(\")\")) {\n                count--;\n            }\n            i++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        }\n        i = 0;\n        while (i < len) {\n            if (lst.get(i).equals(\"(\")) {\n                count++;\n            } else if (lst.get(i).equals(\")\")) {\n                count--;\n            }\n            i++;\n        }\n        if (count == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt0ctovki.java:53)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                count[0]++;\n            } else if (s.equals(\")\")) {\n                count[1]++;\n            }\n        }\n        if (count[0] == count[1]) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprbb2f5zd.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        if (n == 2) return \"Yes\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (lst.get(i).equals(\")\")) {\n                dp[i] = dp[i] + dp[i + 1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == n) return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7nqtyy2l.java:49)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] open = new int[len];\n        int[] close = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                open[i] = 1;\n            } else {\n                open[i] = 0;\n            }\n            if (lst.get(i).equals(\")\")) {\n                close[i] = 1;\n            } else {\n                close[i] = 0;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (open[i] == 1 && close[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmsu6_mdk.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                sb.append(lst.get(i));\n                continue;\n            }\n            if (lst.get(i).equals(\")\")) {\n                if (sb.length() == 0) return \"No\";\n                sb.deleteCharAt(sb.length() - 1);\n                continue;\n            }\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprihljeub.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"No\";\n        if (len == 1) return \"Yes\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv_474d3y.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int l = lst.size();\n        if (l == 0) return \"Yes\";\n        if (l == 1) return \"No\";\n        int i = 0;\n        int j = 0;\n        while (i < l && j < l) {\n            if (lst.get(i).equals(\"(\")) {\n                j++;\n            } else if (lst.get(j).equals(\")\")) {\n                i++;\n            } else {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpb0t6x_dn.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (lst.get(i).equals(\")\")) {\n                dp[i] = dp[i] + dp[i + 1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2\n\tat Problem.matchParens(tmp2acn6wv4.java:36)\n\tat Problem.main(tmp2acn6wv4.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else if (lst.get(i).equals(\")\")) p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (p[j] == -1) {\n                        p[j] = 1;\n                        p[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] == 1) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpz5_miz6d.java:49)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int l = lst.size();\n        if(l == 0) return \"Yes\";\n        int[] dp = new int[l];\n        dp[0] = 1;\n        for(int i = 1; i < l; i++) {\n            if(lst.get(i).equals(\"(\")) dp[i] = dp[i-1] + 1;\n            else dp[i] = dp[i-1];\n        }\n        for(int i = l-1; i >= 0; i--) {\n            if(lst.get(i).equals(\")\")) {\n                if(dp[i] == 0) return \"No\";\n                dp[i]--;\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2u8d685i.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] arr = new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) arr[i]++;\n            else arr[i]--;\n        }\n        for (int i = 0; i < len; i++) {\n            if (arr[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppmags577.java:40)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] arr = new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) arr[i]++;\n            else if (lst.get(i).equals(\")\")) arr[i]--;\n        }\n        for (int i = 0; i < len; i++) {\n            if (arr[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpe9dsq8bq.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            count[s.charAt(0) - '(']++;\n            count[s.charAt(s.length() - 1) - '(']--;\n        }\n        for(int i = 0; i < 2; i++) {\n            if(count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp95lnfw1q.java:35)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.set(i, \"(\");\n                    lst.set(j, \")\");\n                } else {\n                    return \"No\";\n                }\n            } else {\n                if (lst.get(j).equals(\")\")) {\n                    lst.set(i, \")\");\n                    lst.set(j, \"(\");\n                } else {\n                    return \"No\";\n                }\n            }\n            i++;\n            j--;\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpof48g5w0.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        for(int i = 0; i < arr.length; i++) {\n            arr[i] = 0;\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                arr[i] = 1;\n            }\n            else {\n                arr[i] = 2;\n            }\n        }\n        for(int i = 0; i < arr.length; i++) {\n            if(arr[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpaoap78dq.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "/tmp/tmpfxl43bww.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                p[i]++;\n            } else {\n                p[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_oojejit.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else if (s.equals(\")\")) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                return \"No\";\n            }\n        }\n        return sb.length() == 0 ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvssib1eh.java:39)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] paren = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_w9vtm_w.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] paren = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (paren[j] == 1) {\n                        paren[j] = 0;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyp8oo19p.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp88iswb8f.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = dp[i-1];\n            }\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (lst.get(i).equals(\")\")) {\n                dp[i] = dp[i] + dp[i+1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2\n\tat Problem.matchParens(tmp2yggnu4j.java:36)\n\tat Problem.main(tmp2yggnu4j.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n            } else if(s.equals(\")\")) {\n                if(stack.isEmpty()) {\n                    return \"No\";\n                } else {\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjba06hg7.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.remove(i);\n                    lst.remove(j);\n                    i++;\n                    j--;\n                } else {\n                    i++;\n                }\n            } else {\n                if (lst.get(j).equals(\")\")) {\n                    lst.remove(j);\n                    j--;\n                } else {\n                    j--;\n                }\n            }\n        }\n        if (lst.size() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp26dq292p.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(lst.get(i));\n        }\n        return matchParens(sb.toString());\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmptzdaphjo.java:30: error: incompatible types: String cannot be converted to ArrayList<String>\n        return matchParens(sb.toString());\n                                      ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            count[s.charAt(0) - '(']++;\n            count[s.charAt(s.length() - 1) - '(']--;\n        }\n        for(int i = 0; i < count.length; i++) {\n            if(count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxklst0n1.java:35)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        if (len == 1) return \"No\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] < 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa6goxdyg.java:43)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        if(len == 1) return \"No\";\n        int[] parens = new int[len];\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) parens[i] = 1;\n            else if(lst.get(i).equals(\")\")) parens[i] = -1;\n            else return \"No\";\n        }\n        for(int i = 0; i < len; i++) {\n            if(parens[i] == 1) {\n                for(int j = i + 1; j < len; j++) {\n                    if(parens[j] == 1) {\n                        parens[j] = 0;\n                        parens[i] = 0;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(parens[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpok5mkhbo.java:48)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] paren = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                paren[i] = 1;\n            } else if(lst.get(i).equals(\")\")) {\n                paren[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = i + 1; j < lst.size(); j++) {\n                if(paren[i] == 1 && paren[j] == -1) {\n                    return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqb6fr_9c.java:41)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        for(int i = 0; i < arr.length; i++) {\n            arr[i] = lst.get(i).length();\n        }\n        return matchParens(arr);\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "/tmp/tmp00_3p9yd.java:27: error: incompatible types: int[] cannot be converted to ArrayList<String>\n        return matchParens(arr);\n                           ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < parens.length; i++) {\n            if (parens[i] == 1) {\n                count++;\n            } else if (parens[i] == -1) {\n                count--;\n            }\n            if (count < 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpid2mrndp.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] count = new int[len];\n        for (int i = 0; i < len; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count[i]++;\n            } else if (lst.get(i).equals(\")\")) {\n                count[i]--;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (count[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpalrp338o.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for(String s: lst) {\n            if(s.equals(\"(\")) {\n                sb.append(s);\n            } else if(s.equals(\")\")) {\n                if(sb.length() == 0) {\n                    return \"No\";\n                }\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(s);\n            }\n        }\n        if(sb.length() == 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8i8i60f8.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcdh22ye8.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if (len == 0) return \"Yes\";\n        int[] paren = new int[len];\n        for (int i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if (lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] == 1) {\n                for (int j = i + 1; j < len; j++) {\n                    if (paren[j] == 1) {\n                        paren[j] = 0;\n                        paren[i] = 0;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplrtf5nih.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for(int i = 1; i < n; i++) {\n            if(lst.get(i).equals(\"(\")) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = dp[i-1];\n            }\n        }\n        for(int i = n-1; i >= 0; i--) {\n            if(lst.get(i).equals(\")\")) {\n                dp[i] = dp[i] - 1;\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(dp[i] == 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyli4pku4.java:46)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        if (n == 1) return \"No\";\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (lst.get(i).equals(\"(\")) p[i] = 1;\n            else if (lst.get(i).equals(\")\")) p[i] = -1;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j && p[i] == 1 && p[j] == -1) {\n                    if (matchParens(lst, i, j)) return \"Yes\";\n                }\n            }\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "/tmp/tmpqi_ilyh_.java:34: error: method matchParens in class Problem cannot be applied to given types;\n                    if (matchParens(lst, i, j)) return \"Yes\";\n                        ^\n  required: ArrayList<String>\n  found:    ArrayList<String>,int,int\n  reason: actual and formal argument lists differ in length\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s: lst) {\n            if(s.equals(\"(\")) {\n                count[0]++;\n            } else if(s.equals(\")\")) {\n                count[1]++;\n            }\n        }\n        if(count[0] == count[1]) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpya3t1s73.java:38)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        if (lst.size() == 0) return \"Yes\";\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.set(i, \"(\");\n                    lst.set(j, \")\");\n                } else {\n                    return \"No\";\n                }\n            } else {\n                if (lst.get(j).equals(\")\")) {\n                    return \"No\";\n                }\n            }\n            i++;\n            j--;\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcuwykhtr.java:45)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] parens = new int[lst.size()];\n        for(int i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else {\n                parens[i] = -1;\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            for(int j = 0; j < lst.size(); j++) {\n                if(i != j && parens[i] == 1 && parens[j] == -1) {\n                    if(lst.get(i).equals(\")\") && lst.get(j).equals(\"(\")) {\n                        parens[i] = -1;\n                        parens[j] = 1;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < lst.size(); i++) {\n            if(parens[i] == 1) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyh_2n5rw.java:50)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] arr = new int[lst.size()];\n        int i = 0;\n        for(String s : lst) {\n            arr[i++] = s.length();\n        }\n        int[] dp = new int[arr.length];\n        Arrays.fill(dp, -1);\n        return matchParens(arr, dp, 0, lst.size() - 1);\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "/tmp/tmpdguhrt52.java:30: error: method matchParens in class Problem cannot be applied to given types;\n        return matchParens(arr, dp, 0, lst.size() - 1);\n               ^\n  required: ArrayList<String>\n  found:    int[],int[],int,int\n  reason: actual and formal argument lists differ in length\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        Stack<Character> s = new Stack<>();\n        for(String s1 : lst) {\n            for(int i = 0; i < s1.length(); i++) {\n                if(s1.charAt(i) == '(') {\n                    s.push('(');\n                } else if(s1.charAt(i) == ')') {\n                    if(s.isEmpty()) {\n                        return \"No\";\n                    }\n                    s.pop();\n                }\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcawoqx11.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n                sb.append(s);\n            } else if (s.equals(\")\")) {\n                if (sb.length() == 0) {\n                    return \"No\";\n                } else {\n                    sb.deleteCharAt(sb.length() - 1);\n                }\n            } else {\n                sb.append(s);\n            }\n        }\n        if (sb.length() == 0) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2u7cm00j.java:44)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int len = lst.size();\n        if(len == 0) return \"Yes\";\n        int[] paren = new int[len];\n        for(int i = 0; i < len; i++) {\n            if(lst.get(i).equals(\"(\")) paren[i] = 1;\n            else if(lst.get(i).equals(\")\")) paren[i] = -1;\n        }\n        for(int i = 0; i < len; i++) {\n            if(paren[i] == 1) {\n                for(int j = i + 1; j < len; j++) {\n                    if(paren[j] == -1) {\n                        paren[j] = 1;\n                        paren[i] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < len; i++) {\n            if(paren[i] != 0) return \"No\";\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp691vr4a1.java:47)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i = 0;\n        int j = lst.size() - 1;\n        while (i < j) {\n            if (lst.get(i).equals(\"(\")) {\n                if (lst.get(j).equals(\")\")) {\n                    lst.set(i, \")\");\n                    lst.set(j, \"(\");\n                    i++;\n                    j--;\n                } else {\n                    return \"No\";\n                }\n            } else {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmps196v3o_.java:42)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int[] count = new int[2];\n        for(String s : lst) {\n            if(s.equals(\"(\")) {\n                count[0]++;\n            } else if(s.equals(\")\")) {\n                count[1]++;\n            }\n        }\n        if(count[0] == count[1]) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmjrp9q3u.java:37)\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given an array array list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> match_parens(['()(', ')'])\n    // 'Yes'\n    // >>> match_parens([')', ')'])\n    // 'No'\n    public static String matchParens(ArrayList<String> lst) {\n        int i, j, k, len = lst.size();\n        int[] parens = new int[len];\n        for (i = 0; i < len; i++) {\n            if (lst.get(i).equals(\"(\")) {\n                parens[i] = 1;\n            } else if (lst.get(i).equals(\")\")) {\n                parens[i] = -1;\n            }\n        }\n        for (i = 0; i < len; i++) {\n            for (j = i + 1; j < len; j++) {\n                if (parens[i] == 1 && parens[j] == -1) {\n                    for (k = i + 1; k < j; k++) {\n                        if (parens[k] == 1) {\n                            parens[k] = 0;\n                        }\n                    }\n                }\n            }\n        }\n        for (i = 0; i < len; i++) {\n            if (parens[i] != 0) {\n                return \"No\";\n            }\n        }\n        return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\")\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwg9_u1lk.java:51)\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}