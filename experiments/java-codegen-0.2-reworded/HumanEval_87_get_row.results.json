{
  "name": "HumanEval_87_get_row",
  "language": "java",
  "prompt": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n",
  "tests": "    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                Collections.sort(lst.get(i), (a, b) -> b - a);\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    result.add(new Pair<>(i, lst.get(i).get(j)));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp222kud5k.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                                   ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp222kud5k.java:43: error: incompatible types: cannot infer type-variable(s) T\n                Collections.sort(lst.get(i), (a, b) -> b - a);\n                                ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmp222kud5k.java:45: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, lst.get(i).get(j)));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    res.add(new Pair<>(i, lst.get(i).get(j)));\n                }\n                Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpuxz3nex2.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, lst.get(i).get(j)));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpuxz3nex2.java:38: error: method getValue in class Tuple cannot be applied to given types;\n                Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                 ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpuxz3nex2.java:38: error: method getValue in class Tuple cannot be applied to given types;\n                Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                                ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp5jg28cw4.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<ArrayList<Long>> sorted = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            sorted.add(new ArrayList<>(lst.get(i)));\n        }\n        sorted.sort((a, b) -> a.size() - b.size());\n        for (int i = 0; i < sorted.size(); i++) {\n            for (int j = 0; j < sorted.get(i).size(); j++) {\n                if (sorted.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp4xr45iff.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp4xr45iff.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpst7arn3s.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpst7arn3s.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpst7arn3s.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpst7arn3s.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpst7arn3s.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (ArrayList<Long> list : lst) {\n            row.addAll(list);\n        }\n        Collections.sort(row, (a, b) -> a.compareTo(b));\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                result.add(new Pair<>(i, row.get(i)));\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp6tgjrwgj.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(i, row.get(i)));\n                                   ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpt8s4ind_.java:54: error: ')' expected\n            res.add(new Pair<>(3L\n                                 ^\n/tmp/tmpt8s4ind_.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            } else {\n                return res;\n            }\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n            } else {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpaofwzdtb.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpaofwzdtb.java:46: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpaofwzdtb.java:50: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) return result;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                result.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return result;\n        }\n        ArrayList<Pair<Long, Long>> sorted = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            sorted.addAll(getRow(lst.get(i), x));\n        }\n        sorted.sort((a, b) -> a.getKey().compareTo(b.getKey()));\n        for (int i = 0; i < sorted.size(); i++) {\n            result.add(sorted.get(i));\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp4mn214rd.java:35: error: incompatible types: ArrayList<Long> cannot be converted to ArrayList<ArrayList<Long>>\n            sorted.addAll(getRow(lst.get(i), x));\n                                        ^\n/tmp/tmp4mn214rd.java:37: error: cannot find symbol\n        sorted.sort((a, b) -> a.getKey().compareTo(b.getKey()));\n                               ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp4mn214rd.java:37: error: cannot find symbol\n        sorted.sort((a, b) -> a.getKey().compareTo(b.getKey()));\n                                                    ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                        return res;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp8t6wh0bs.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp8t6wh0bs.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() == 0) continue;\n            for (Long col_lst : row_lst) {\n                if (col_lst.equals(x)) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpig9gcnvn.java:33)\n\tat Problem.main(tmpig9gcnvn.java:44)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            Collections.sort(lst.get(i), (a, b) -> b.size() - a.size());\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmprf4man3s.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                                   ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmprf4man3s.java:42: error: cannot find symbol\n            Collections.sort(lst.get(i), (a, b) -> b.size() - a.size());\n                                                    ^\n  symbol:   method size()\n  location: variable b of type Long\n/tmp/tmprf4man3s.java:42: error: cannot find symbol\n            Collections.sort(lst.get(i), (a, b) -> b.size() - a.size());\n                                                               ^\n  symbol:   method size()\n  location: variable a of type Long\n/tmp/tmprf4man3s.java:45: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        Collections.sort(lst.get(0), (a, b) -> a.compareTo(b));\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp3_vngtko.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            row.add(lst.get(0).get(i));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            ArrayList<Long> curr_row = new ArrayList<>();\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                curr_row.add(lst.get(i).get(j));\n            }\n            Collections.sort(curr_row, Collections.reverseOrder());\n            for (int j = 0; j < curr_row.size(); j++) {\n                if (curr_row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    return res;\n                }\n            }\n            for (int j = 0; j < curr_row.size(); j++) {\n                row.add(curr_row.get(j));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpwi7orru5.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpwi7orru5.java:49: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        // Iterate through all rows.\n        for (ArrayList<Long> row : lst) {\n            // Iterate through all columns of the row.\n            for (int i = 0; i < row.size(); i++) {\n                // If the current coordinate is equal to the given x,\n                // then add it to the result.\n                if (row.get(i) == x) {\n                    result.add(new Pair<>(row.get(0), i));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpaevix8e7.java:40: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(row.get(0), i));\n                                       ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res2 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res3 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res4 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res5 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res6 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res7 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res8 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res9 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res10 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res11 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res12 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res13 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res14 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res15 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res16 = getRow(lst, x);\n        Array\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpzacuyyo_.java:53: error: not a statement\n        Array\n        ^\n/tmp/tmpzacuyyo_.java:53: error: ';' expected\n        Array\n             ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        if (lst.get(0).size() == 2) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            return ret;\n        }\n        if (lst.get(0).size() == 3) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            return ret;\n        }\n        if (lst.get(0).size() == 4) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            ret.add(new Pair<>(3L, lst.get(0).get(3)));\n            return ret;\n        }\n        if (lst.get(0).size() == 5) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            ret.add(new Pair<>(3L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpi5s8f7u1.java:54: error: ')' expected\n            ret.add(new Pair<>(3L, lst.get\n                                          ^\n/tmp/tmpi5s8f7u1.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpbv0su36i.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        ArrayList<Pair<Long, Long>> sorted = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            sorted.add(new Pair<>(i, lst.get(i).size() - 1));\n        }\n        Collections.sort(sorted, (a, b) -> a.getKey().compareTo(b.getKey()));\n        for (int i = 0; i < sorted.size(); i++) {\n            for (int j = 0; j < sorted.get(i).getValue(); j++) {\n                result.add(new Pair<>(sorted.get(i).getKey(), lst.get(sorted.get(i).getKey()).get(j)));\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpfrn8rg2u.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n            sorted.add(new Pair<>(i, lst.get(i).size() - 1));\n                               ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpfrn8rg2u.java:40: error: cannot find symbol\n        Collections.sort(sorted, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpfrn8rg2u.java:40: error: cannot find symbol\n        Collections.sort(sorted, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                                 ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpfrn8rg2u.java:42: error: method getValue in class Tuple cannot be applied to given types;\n            for (int j = 0; j < sorted.get(i).getValue(); j++) {\n                                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpfrn8rg2u.java:43: error: cannot find symbol\n                result.add(new Pair<>(sorted.get(i).getKey(), lst.get(sorted.get(i).getKey()).get(j)));\n                                                   ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpfrn8rg2u.java:43: error: cannot find symbol\n                result.add(new Pair<>(sorted.get(i).getKey(), lst.get(sorted.get(i).getKey()).get(j)));\n                                                                                   ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp461o82_2.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpcc6nz8h5.java:58: error: not a statement\n            result.add\n                  ^\n/tmp/tmpcc6nz8h5.java:58: error: ';' expected\n            result.add\n                      ^\n/tmp/tmpcc6nz8h5.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpg0_jmb9j.java:39: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpg0_jmb9j.java:39: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpg0_jmb9j.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpg0_jmb9j.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            if (row.size() == 0) continue;\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpnzjfkv2p.java:31: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpnzjfkv2p.java:34: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(0L, i));\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            row.add(lst.get(0).get(i));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            ArrayList<Long> temp = new ArrayList<>();\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                temp.add(lst.get(i).get(j));\n            }\n            Collections.sort(temp, Collections.reverseOrder());\n            for (int j = 0; j < temp.size(); j++) {\n                if (temp.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmprghbjg6s.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(0L, i));\n                                    ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmprghbjg6s.java:48: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            row.add(lst.get(0).get(i));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            row.add(lst.get(i).get(0));\n        }\n        Collections.sort(row, (a, b) -> b.compareTo(a));\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(0, i));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpxzfs1c4k.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpxzfs1c4k.java:46: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(0, i));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (x < 0 || x >= lst.size()) return result;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            result.add(new Pair<>(x, i));\n        }\n        Collections.sort(result, (p1, p2) -> p1.getKey().compareTo(p2.getKey()));\n        Collections.sort(result, (p1, p2) -> p1.getValue().compareTo(p2.getValue()));\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmp69uazo8f.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp69uazo8f.java:29: error: incompatible types: cannot infer type arguments for Pair<>\n            result.add(new Pair<>(x, i));\n                               ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmp69uazo8f.java:31: error: cannot find symbol\n        Collections.sort(result, (p1, p2) -> p1.getKey().compareTo(p2.getKey()));\n                                               ^\n  symbol:   method getKey()\n  location: variable p1 of type Pair<Long,Long>\n/tmp/tmp69uazo8f.java:31: error: cannot find symbol\n        Collections.sort(result, (p1, p2) -> p1.getKey().compareTo(p2.getKey()));\n                                                                     ^\n  symbol:   method getKey()\n  location: variable p2 of type Pair<Long,Long>\n/tmp/tmp69uazo8f.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (p1, p2) -> p1.getValue().compareTo(p2.getValue()));\n                                               ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp69uazo8f.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (p1, p2) -> p1.getValue().compareTo(p2.getValue()));\n                                                                       ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_val : row_lst) {\n                if (col_val == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpfdst3dww.java:32)\n\tat Problem.main(tmpfdst3dww.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(lst.get(0).size() - 1) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(lst.get(0).size() - 1)));\n            return res;\n        }\n        if (lst.get(0).get(0) < x && lst.get(0).get(lst.get(0).size() - 1) > x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(lst.get(0).size() - 1)));\n            return res;\n        }\n        if (lst.get(0).get(0) > x && lst.get(0).get(lst.get(0).size() - 1) < x) {\n            res.add(new Pair<>(0L, lst.get(0).get(lst.get(0).size() - 1)));\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) < x && lst.get(0).get(lst.get(0).size() - 1) < x) {\n            res.add(new Pair<>(0L, lst\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpkg_vtmfu.java:51: error: ')' expected\n            res.add(new Pair<>(0L, lst\n                                      ^\n/tmp/tmpkg_vtmfu.java:53: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0));\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpcbx63pdc.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcbx63pdc.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcbx63pdc.java:43: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            result.add(new Pair<>(4L, lst.get(0).\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpcaqqj_fu.java:59: error: <identifier> expected\n            result.add(new Pair<>(4L, lst.get(0).\n                                                 ^\n/tmp/tmpcaqqj_fu.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmp8_9wpzi8.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp8_9wpzi8.java:37: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp8_9wpzi8.java:37: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp8_9wpzi8.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp8_9wpzi8.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpxko1u6vn.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpxko1u6vn.java:37: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpxko1u6vn.java:37: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpxko1u6vn.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxko1u6vn.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst == null || row_lst.size() == 0) continue;\n            for (Long col_lst : row_lst) {\n                if (col_lst == null) continue;\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmp4_93sybe.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp4_93sybe.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp4_93sybe.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp4_93sybe.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmpg0_jmb9j.java:39: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpg0_jmb9j.java:39: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpg0_jmb9j.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpg0_jmb9j.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (x < 0 || x >= lst.size()) {\n            return result;\n        }\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            result.add(new Pair<>(x, i));\n        }\n        Collections.sort(result, (p1, p2) -> p1.getKey() - p2.getKey());\n        Collections.sort(result, (p1, p2) -> p1.getValue() - p2.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmp3fxz30oz.java:32: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp3fxz30oz.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n            result.add(new Pair<>(x, i));\n                               ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmp3fxz30oz.java:35: error: cannot find symbol\n        Collections.sort(result, (p1, p2) -> p1.getKey() - p2.getKey());\n                                               ^\n  symbol:   method getKey()\n  location: variable p1 of type Pair<Long,Long>\n/tmp/tmp3fxz30oz.java:35: error: cannot find symbol\n        Collections.sort(result, (p1, p2) -> p1.getKey() - p2.getKey());\n                                                             ^\n  symbol:   method getKey()\n  location: variable p2 of type Pair<Long,Long>\n/tmp/tmp3fxz30oz.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (p1, p2) -> p1.getValue() - p2.getValue());\n                                               ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp3fxz30oz.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (p1, p2) -> p1.getValue() - p2.getValue());\n                                                               ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpu2am5kgz.java:30: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpu2am5kgz.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmp4jmx8m08.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp4jmx8m08.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp4jmx8m08.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        // Iterate through the rows and find the coordinates.\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpuuo_xy_3.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(0L, lst.get(i).get(0)));\n                    return res;\n                }\n            }\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(lst.get(i).get(0), lst.get(i).get(1)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey().compareTo(b.getKey()));\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpd_25icwo.java:47: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpd_25icwo.java:47: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.isEmpty()) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpd1_psq7a.java:32: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpd1_psq7a.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpcc6nz8h5.java:58: error: not a statement\n            result.add\n                  ^\n/tmp/tmpcc6nz8h5.java:58: error: ';' expected\n            result.add\n                      ^\n/tmp/tmpcc6nz8h5.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res2 = getRow(lst, x);\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res2, (a, b) -> b.getKey() - a.getKey());\n        for (int i = 0; i < res1.size(); i++) {\n            res.add(res1.get(i));\n        }\n        for (int i = 0; i < res2.size(); i++) {\n            res.add(res2.get(i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpmpqapfyr.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpmpqapfyr.java:39: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpmpqapfyr.java:39: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpmpqapfyr.java:40: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> b.getKey() - a.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpmpqapfyr.java:40: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> b.getKey() - a.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpgntco2fs.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            res_row.add(new Pair<>(0L, i));\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                for (int j = 0; j < lst.get(i).get(0); j++) {\n                    res.add(new Pair<>(i, j));\n                }\n            } else {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                        return res;\n                    }\n                }\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) > x) {\n                        res_row.add(new Pair<>(i, j - 1));\n                        break;\n                    }\n                }\n            }\n        }\n        Collections.sort(res_row, (a, b) -> b.getValue() - a.getValue());\n        for (int i = 0; i < res_row.size(); i++) {\n            res.add(res_row.get(i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpsdpexhjt.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpsdpexhjt.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n            res_row.add(new Pair<>(0L, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpsdpexhjt.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpsdpexhjt.java:49: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpsdpexhjt.java:55: error: incompatible types: cannot infer type arguments for Pair<>\n                        res_row.add(new Pair<>(i, j - 1));\n                                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpsdpexhjt.java:61: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res_row, (a, b) -> b.getValue() - a.getValue());\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                    return res;\n                }\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0L));\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpbbb_ob45.java:45: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpbbb_ob45.java:51: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpbbb_ob45.java:55: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                        return res;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292964,
      "stdout": "",
      "stderr": "/tmp/tmp8t6wh0bs.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp8t6wh0bs.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmp69cfsz6p.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp69cfsz6p.java:37: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp69cfsz6p.java:37: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(lst.get(i).get(0), lst.get(i).get(0)));\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                res1.add(new Pair<>(lst.get(i).get(j), i));\n            }\n        }\n        Collections.sort(res1, (a, b) -> a.getValue() - b.getValue());\n        for (int i = 0; i < res1.size(); i++) {\n            if (res1.get(i).getValue() == x) {\n                for (int j = 0; j < lst.get(res1.get(i).getValue()).size(); j++) {\n                    res.add(new Pair<>(lst.get(res1.get(i).getValue()).get(j), res1.get(i).getValue()));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpxfjx00yl.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                res1.add(new Pair<>(lst.get(i).get(j), i));\n                                 ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpxfjx00yl.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res1, (a, b) -> a.getValue() - b.getValue());\n                                          ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxfjx00yl.java:40: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res1, (a, b) -> a.getValue() - b.getValue());\n                                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxfjx00yl.java:42: error: method getValue in class Tuple cannot be applied to given types;\n            if (res1.get(i).getValue() == x) {\n                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxfjx00yl.java:43: error: method getValue in class Tuple cannot be applied to given types;\n                for (int j = 0; j < lst.get(res1.get(i).getValue()).size(); j++) {\n                                                       ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxfjx00yl.java:44: error: method getValue in class Tuple cannot be applied to given types;\n                    res.add(new Pair<>(lst.get(res1.get(i).getValue()).get(j), res1.get(i).getValue()));\n                                                          ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpxfjx00yl.java:44: error: method getValue",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (x < 0 || x >= lst.size()) return res;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            res.add(new Pair<>(x, i));\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmp5g8wosf_.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp5g8wosf_.java:29: error: incompatible types: cannot infer type arguments for Pair<>\n            res.add(new Pair<>(x, i));\n                            ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmp5g8wosf_.java:31: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp5g8wosf_.java:31: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp5g8wosf_.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp5g8wosf_.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return ret;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return ret;\n        }\n        if (lst.get(0).get(0) == x) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return ret;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    ret.add(new Pair<>(i + 1, lst.get(i).get(j)));\n                }\n            }\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpzu7sgjs2.java:49: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i + 1, lst.get(i).get(j)));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_val : row_lst) {\n                if (col_val == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpfdst3dww.java:32)\n\tat Problem.main(tmpfdst3dww.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > 1) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                        return res;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmp7lr9xei1.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp7lr9xei1.java:40: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp7lr9xei1.java:49: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        if (row == 0) {\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (i == row) {\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (j == col) {\n                    continue;\n                }\n                res1.add(new Pair<>(i, lst.get(i).get(j)));\n            }\n        }\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n        Collections.sort(res1, (a, b) -> b.getValue() - a.getValue());\n        res.add(new Pair<>(row, col));\n        res.addAll(res1);\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpiu8m052p.java:65: error: incompatible types: cannot infer type arguments for Pair<>\n                res1.add(new Pair<>(i, lst.get(i).get(j)));\n                                 ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpiu8m052p.java:68: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpiu8m052p.java:68: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpiu8m052p.java:69: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res1, (a, b) -> b.getValue() - a.getValue());\n                                          ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpiu8m052p.java:69: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res1, (a, b) -> b.getValue() - a.getValue());\n                                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) return ret;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    ret.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpfgpp46a3.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpfgpp46a3.java:35: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpfgpp46a3.java:35: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpfgpp46a3.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpfgpp46a3.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_list : lst) {\n            for (Long col_list : row_list) {\n                if (col_list == x) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292968,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpr07ng00c.java:32)\n\tat Problem.main(tmpr07ng00c.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res2 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res3 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res4 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res5 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res6 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res7 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res8 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res9 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res10 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res11 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res12 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res13 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res14 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res15 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res16\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292966,
      "stdout": "",
      "stderr": "/tmp/tmpnyaadiw8.java:55: error: ';' expected\n        ArrayList<Pair<Long, Long>> res16\n                                         ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (x < 0 || x >= lst.size()) return ret;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            ret.add(new Pair<>(x, i));\n        }\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            ret.add(new Pair<>(x, i));\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292968,
      "stdout": "",
      "stderr": "/tmp/tmpahheix24.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmpahheix24.java:29: error: incompatible types: cannot infer type arguments for Pair<>\n            ret.add(new Pair<>(x, i));\n                            ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpahheix24.java:31: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpahheix24.java:31: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpahheix24.java:32: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmpahheix24.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n            ret.add(new Pair<>(x, i));\n                            ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292968,
      "stdout": "",
      "stderr": "/tmp/tmp5pj9ch5s.java:30: error: incompatible types: possible lossy conversion from long to int\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n                                                     ^\n/tmp/tmp5pj9ch5s.java:33: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp5pj9ch5s.java:33: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if(lst.size() == 0) return ret;\n        long row = 0;\n        long col = 0;\n        for(ArrayList<Long> row_lst : lst) {\n            for(Long col_lst : row_lst) {\n                if(col_lst == x) {\n                    ret.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmppx0utgfu.java:32)\n\tat Problem.main(tmppx0utgfu.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpcc6nz8h5.java:58: error: not a statement\n            result.add\n                  ^\n/tmp/tmpcc6nz8h5.java:58: error: ';' expected\n            result.add\n                      ^\n/tmp/tmpcc6nz8h5.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpgntco2fs.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        if (lst.get(0).size() == 2) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            return ret;\n        }\n        if (lst.get(0).size() == 3) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            return ret;\n        }\n        if (lst.get(0).size() == 4) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            ret.add(new Pair<>(0L, lst.get(0).get(3)));\n            return ret;\n        }\n        if (lst.get(0).size() == 5) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            ret.add(new Pair<>(0L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpgetpuyva.java:54: error: ')' expected\n            ret.add(new Pair<>(0L\n                                 ^\n/tmp/tmpgetpuyva.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n            }\n            else {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpgat9ag6t.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpgat9ag6t.java:47: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpuxrj5chw.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpuxrj5chw.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpuxrj5chw.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpuxrj5chw.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpwpswr6aq.java:32)\n\tat Problem.main(tmpwpswr6aq.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            // Sort coordinates of the row by columns in descending order.\n            lst.get(i).sort((a, b) -> b - a);\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpuquzoukd.java:33: error: incompatible types: bad return type in lambda expression\n            lst.get(i).sort((a, b) -> b - a);\n                                        ^\n    possible lossy conversion from long to int\n/tmp/tmpuquzoukd.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpdzn3cwws.java:32)\n\tat Problem.main(tmpdzn3cwws.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (x < 0 || x > lst.size()) return result;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            result.add(new Pair<>(x, lst.get(x).get(i)));\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpurtf04lg.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmpurtf04lg.java:29: error: incompatible types: possible lossy conversion from long to int\n            result.add(new Pair<>(x, lst.get(x).get(i)));\n                                             ^\n/tmp/tmpurtf04lg.java:31: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpurtf04lg.java:31: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpurtf04lg.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpurtf04lg.java:32: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            for (int j = 0; j < lst.size(); j++) {\n                if (lst.get(j).get(i) == x) {\n                    res.add(new Pair<>(j, i));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmp99bjyl4c.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp99bjyl4c.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp99bjyl4c.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp99bjyl4c.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp99bjyl4c.java:45: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(j, i));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp99bjyl4c.java:49: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp99bjyl4c.java:49: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst == null || row_lst.size() == 0) {\n                continue;\n            }\n            for (Long col_lst : row_lst) {\n                if (col_lst == null) {\n                    continue;\n                }\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> (a.getKey() > b.getKey()) ? 1 : -1);\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpz1tm4n9i.java:47: error: cannot find symbol\n        Collections.sort(res, (a, b) -> (a.getKey() > b.getKey()) ? 1 : -1);\n                                          ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpz1tm4n9i.java:47: error: cannot find symbol\n        Collections.sort(res, (a, b) -> (a.getKey() > b.getKey()) ? 1 : -1);\n                                                       ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() == 0) continue;\n            for (Long col_lst : row_lst) {\n                if (col_lst.equals(x)) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpv8kojy_a.java:33)\n\tat Problem.main(tmpv8kojy_a.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        ArrayList<Long> row = lst.get(0);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(0L, i));\n                return res;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpvec87r1m.java:30: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(0L, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpvec87r1m.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            } else {\n                return res;\n            }\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                    return res;\n                } else {\n                    return res;\n                }\n            }\n            if (lst.get(i).get(0) < x) {\n                row = i;\n                break;\n            }\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            if (lst.get(row).get(i) == x) {\n                res.add(new Pair<>(row, i));\n                return res;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (i == row) continue;\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpltqudfhi.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpltqudfhi.java:52: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmpltqudfhi.java:53: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(i) == x) {\n                        ^\n/tmp/tmpltqudfhi.java:54: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(row, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpltqudfhi.java:62: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> sorted = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            sorted.add(lst.get(0).get(i));\n        }\n        Collections.sort(sorted, (a, b) -> b - a);\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, sorted.indexOf(lst.get(i).get(0))));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpaf2viu0f.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpaf2viu0f.java:41: error: incompatible types: cannot infer type-variable(s) T\n        Collections.sort(sorted, (a, b) -> b - a);\n                        ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpaf2viu0f.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, sorted.indexOf(lst.get(i).get(0))));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpt8s4ind_.java:54: error: ')' expected\n            res.add(new Pair<>(3L\n                                 ^\n/tmp/tmpt8s4ind_.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpt8s4ind_.java:54: error: ')' expected\n            res.add(new Pair<>(3L\n                                 ^\n/tmp/tmpt8s4ind_.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(0L, 1L));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(0L, 1L));\n            result.add(new Pair<>(0L, 2L));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(0L, 1L));\n            result.add(new Pair<>(0L, 2L));\n            result.add(new Pair<>(0L, 3L));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(0L, 1L));\n            result.add(new Pair<>(0L, 2L));\n            result.add(new Pair<>(0L, 3L));\n            result.add(new Pair<>(0L, 4L));\n            return result;\n        }\n        if (lst.get(0).size() == 6) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(0L, 1L));\n            result.add(new Pair<>(0L, 2L));\n            result.add(new Pair<>(0L, 3L));\n\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292968,
      "stdout": "",
      "stderr": "/tmp/tmp6hcxayt6.java:69: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (lst.get(0).size() == 0) return result;\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) continue;\n            if (lst.get(i).get(0) == x) {\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    result.add(new Pair<>(i, lst.get(i).get(j)));\n                }\n                return result;\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpang81akz.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(i, lst.get(i).get(0)));\n                                   ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpang81akz.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, lst.get(i).get(j)));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) return ret;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return ret;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            if (row.size() == 0) continue;\n            long row_x = row.get(0);\n            if (row_x == x) {\n                for (int j = 0; j < row.size(); j++) {\n                    ret.add(new Pair<>(i, row.get(j)));\n                }\n            }\n        }\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpsleymowr.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, row.get(j)));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpsleymowr.java:43: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpsleymowr.java:43: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpsleymowr.java:44: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpsleymowr.java:44: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(ret, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(0L, lst.get(i).get(0)));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            row.add(lst.get(0).get(i));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                row.add(lst.get(i).get(j));\n            }\n        }\n        Collections.sort(row, (a, b) -> b - a);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(0L, row.get(i)));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp26aztbbz.java:46: error: incompatible types: cannot infer type-variable(s) T\n        Collections.sort(row, (a, b) -> b - a);\n                        ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n        ArrayList<Long> row = lst.get(0);\n        if (row == null || row.isEmpty()) {\n            return result;\n        }\n        Collections.sort(row, (a, b) -> a - b);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                result.add(new Pair<>(0L, i));\n                break;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            row = lst.get(i);\n            if (row == null || row.isEmpty()) {\n                continue;\n            }\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpaa5_ew5j.java:33: error: incompatible types: cannot infer type-variable(s) T\n        Collections.sort(row, (a, b) -> a - b);\n                        ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpaa5_ew5j.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(0L, i));\n                                   ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpaa5_ew5j.java:45: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpaa5_ew5j.java:48: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp7o1h84xi.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp7o1h84xi.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp7o1h84xi.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp7o1h84xi.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp7o1h84xi.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        long[] rows = new long[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            rows[i] = lst.get(i).size();\n        }\n        Arrays.sort(rows);\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows[i]; j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp00exss77.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        Collections.sort(lst, (a, b) -> b.get(0).compareTo(a.get(0)));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpznodp5u6.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpznodp5u6.java:47: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpl4p8hbru.java:32: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpl4p8hbru.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpgqidh6vi.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) return res;\n        if (lst.get(0).get(0) == x) return res;\n        if (lst.get(0).get(0) > x) return res;\n        if (lst.get(0).get(0) < x) return res;\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            if (lst.get(i).get(0) > x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            if (lst.get(i).get(0) < x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, lst.get(i).get(j)));\n                    continue;\n                }\n                if (lst.get(i).get(j) > x) {\n                    res.add(new Pair<>(i, lst.get(i).get(j)));\n                    continue;\n                }\n                if (lst.get(i).get(j) < x) {\n                    res.add(new Pair<>(i, lst.get(i\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "/tmp/tmpe1c22ohr.java:59: error: ')' expected\n                    res.add(new Pair<>(i, lst.get(i\n                                                   ^\n/tmp/tmpe1c22ohr.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.size() - b.size());\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b - a));\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp9l6kou88.java:32: error: incompatible types: bad return type in lambda expression\n        lst.forEach(row -> row.sort((a, b) -> b - a));\n                                                ^\n    possible lossy conversion from long to int\n/tmp/tmp9l6kou88.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            row = i;\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                col = lst.get(i).get(j);\n                if (col == x) {\n                    res.add(new Pair<>(row, j));\n                    break;\n                }\n            }\n        }\n        Collections.sort(res, new Comparator<Pair<Long, Long>>() {\n            @Override\n            public int compare(Pair<Long, Long> o1, Pair<Long, Long> o2) {\n                if (o1.getKey() == o2.getKey()) {\n                    return o1.getValue() - o2.getValue();\n                } else {\n                    return o1.getKey() - o2.getKey();\n                }\n            }\n        });\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpej7c323w.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(row, j));\n                                    ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpej7c323w.java:49: error: cannot find symbol\n                if (o1.getKey() == o2.getKey()) {\n                      ^\n  symbol:   method getKey()\n  location: variable o1 of type Pair<Long,Long>\n/tmp/tmpej7c323w.java:49: error: cannot find symbol\n                if (o1.getKey() == o2.getKey()) {\n                                     ^\n  symbol:   method getKey()\n  location: variable o2 of type Pair<Long,Long>\n/tmp/tmpej7c323w.java:50: error: method getValue in class Tuple cannot be applied to given types;\n                    return o1.getValue() - o2.getValue();\n                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpej7c323w.java:50: error: method getValue in class Tuple cannot be applied to given types;\n                    return o1.getValue() - o2.getValue();\n                                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpej7c323w.java:52: error: cannot find symbol\n                    return o1.getKey() - o2.getKey();\n                             ^\n  symbol:   method getKey()\n  location: variable o1 of type Pair<Long,Long>\n/tmp/tmpej7c323w.java:52: error: cannot find symbol\n                    return o1.getKey() - o2.getKey();\n                                           ^\n  symbol:   method getKey()\n  location: variable o2 of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n7 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).get(0) == x) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        ArrayList<Pair<Long, Long>> row = getRow(lst, x);\n        if (row.size() == 0) {\n            return result;\n        }\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n        for (int i = 0; i < row.size(); i++) {\n            result.add(new Pair<>(row.get(i).getKey() + 1, row.get(i).getValue() + 1));\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmps0113par.java:40: error: cannot find symbol\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmps0113par.java:40: error: cannot find symbol\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmps0113par.java:42: error: cannot find symbol\n            result.add(new Pair<>(row.get(i).getKey() + 1, row.get(i).getValue() + 1));\n                                            ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmps0113par.java:42: error: method getValue in class Tuple cannot be applied to given types;\n            result.add(new Pair<>(row.get(i).getKey() + 1, row.get(i).getValue() + 1));\n                                                                     ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp0smsbr9y.java:54: error: ')' expected\n            res.add(new Pair<>(0L, lst.get\n                                          ^\n/tmp/tmp0smsbr9y.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) continue;\n            if (lst.get(i).get(0) == x) {\n                ret.add(new Pair<>(i, lst.get(i).get(0)));\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    ret.add(new Pair<>(i, lst.get(i).get(j)));\n                }\n                return ret;\n            }\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmptq9yjlim.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                ret.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmptq9yjlim.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, lst.get(i).get(j)));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpukmiqtq9.java:32: error: incompatible types: possible lossy conversion from long to int\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n                                                     ^\n/tmp/tmpukmiqtq9.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpukmiqtq9.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_list : lst) {\n            for (Long col_list : row_list) {\n                if (col_list == x) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292968,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpr07ng00c.java:32)\n\tat Problem.main(tmpr07ng00c.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp629v5yjq.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp629v5yjq.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp629v5yjq.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                    return res;\n                }\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0L));\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpcbakb4v5.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcbakb4v5.java:47: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcbakb4v5.java:51: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            } else {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp34z4w780.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp34z4w780.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp34z4w780.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp0smsbr9y.java:54: error: ')' expected\n            res.add(new Pair<>(0L, lst.get\n                                          ^\n/tmp/tmp0smsbr9y.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_list : lst) {\n            if (row_list == null || row_list.isEmpty()) {\n                continue;\n            }\n            for (Long col_list : row_list) {\n                if (col_list == null) {\n                    continue;\n                }\n                if (col_list == x) {\n                    result.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(result, new Comparator<Pair<Long, Long>>() {\n            @Override\n            public int compare(Pair<Long, Long> o1, Pair<Long, Long> o2) {\n                return o2.getKey().compareTo(o1.getKey());\n            }\n        });\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp11uraete.java:50: error: cannot find symbol\n                return o2.getKey().compareTo(o1.getKey());\n                         ^\n  symbol:   method getKey()\n  location: variable o2 of type Pair<Long,Long>\n/tmp/tmp11uraete.java:50: error: cannot find symbol\n                return o2.getKey().compareTo(o1.getKey());\n                                               ^\n  symbol:   method getKey()\n  location: variable o1 of type Pair<Long,Long>\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            col = 0;\n            row++;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpvz71m7rq.java:32)\n\tat Problem.main(tmpvz71m7rq.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpm33xjted.java:54: error: ')' expected\n            res.add(new Pair<>(3L, lst.get\n                                          ^\n/tmp/tmpm33xjted.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (lst.get(0).size() == 0) return result;\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpkfme74ub.java:54: error: ')' expected\n            result.add(new Pair<>(3L\n                                    ^\n/tmp/tmpkfme74ub.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        long maxRow = lst.size();\n        long maxCol = lst.get(0).size();\n        long row = 0;\n        long col = 0;\n        long rowMax = 0;\n        long colMax = 0;\n        long rowMin = 0;\n        long colMin = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        if (row == 0 && col == 0) {\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (i == row) {\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (j == col) {\n                    continue;\n                }\n                if (lst.get(i).get(j) > x) {\n                    rowMax = i;\n                    colMax = j;\n                    break;\n                }\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (i == row) {\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (j == col) {\n                    continue;\n                }\n                if (lst.get(i).get(j) < x) {\n                    rowMin = i;\n                    colMin = j;\n                    break;\n                }\n            }\n        }\n        if (rowMax == 0 && colMax == 0) {\n            return res;\n        }\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp9ge2wq8a.java:85: error: missing return statement\n    }\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp_dp6gzl1.java:30: error: incompatible types: possible lossy conversion from long to int\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n                                                     ^\n/tmp/tmp_dp6gzl1.java:33: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp_dp6gzl1.java:33: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, 0L));\n            return ret;\n        }\n        if (lst.get(0).size() == 2) {\n            ret.add(new Pair<>(0L, 0L));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            return ret;\n        }\n        if (lst.get(0).size() == 3) {\n            ret.add(new Pair<>(0L, 0L));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            return ret;\n        }\n        if (lst.get(0).size() == 4) {\n            ret.add(new Pair<>(0L, 0L));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            ret.add(new Pair<>(3L, lst.get(0).get(3)));\n            return ret;\n        }\n        if (lst.get(0).size() == 5) {\n            ret.add(new Pair<>(0L, 0L));\n            ret.add(new Pair<>(1L, lst.get(0).get(1)));\n            ret.add(new Pair<>(2L, lst.get(0).get(2)));\n            ret.add(new Pair<>(3L, lst.get(0).get(3)));\n            ret.add(new Pair<>(4L, lst.get(0).get(4)));\n            return ret;\n        \n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpeup48ad9.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > col) {\n                row = i;\n                col = lst.get(i).size() - 1;\n            }\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            if (lst.get(row).get(i) == x) {\n                res.add(new Pair<>(row, i));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp5ss4_bto.java:36: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmp5ss4_bto.java:37: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(i) == x) {\n                        ^\n/tmp/tmp5ss4_bto.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(row, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return ret;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return ret;\n        }\n        if (lst.get(0).size() == 2) {\n            for (int i = 0; i < lst.size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(i).get(0)));\n                ret.add(new Pair<>(0L, lst.get(i).get(1)));\n            }\n            return ret;\n        }\n        if (lst.get(0).size() == 3) {\n            for (int i = 0; i < lst.size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(i).get(0)));\n                ret.add(new Pair<>(0L, lst.get(i).get(1)));\n                ret.add(new Pair<>(0L, lst.get(i).get(2)));\n            }\n            return ret;\n        }\n        if (lst.get(0).size() == 4) {\n            for (int i = 0; i < lst.size(); i++) {\n                ret.add(new Pair<>(0L, lst.get(i).get(0)));\n                ret.add(new Pair<>(0L, lst.get(i).get(1)));\n                ret.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpsorcoif1.java:59: error: not a statement\n                ret.add\n                   ^\n/tmp/tmpsorcoif1.java:59: error: ';' expected\n                ret.add\n                       ^\n/tmp/tmpsorcoif1.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        long max_row = lst.get(0).size();\n        long min_row = lst.get(0).size();\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > max_row) {\n                max_row = lst.get(i).size();\n            }\n            if (lst.get(i).size() < min_row) {\n                min_row = lst.get(i).size();\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(result, (a, b) -> {\n            if (a.getKey() < b.getKey()) {\n                return -1;\n            }\n            if (a.getKey() > b.getKey()) {\n                return 1;\n            }\n            if (a.getValue() < b.getValue()) {\n                return -1;\n            }\n            if (a.getValue() > b.getValue()) {\n                return 1;\n            }\n            return 0;\n        });\n        for (int i = 0; i < result.size(); i++) {\n            result.set(i, new Pair<>(result.get(i).getKey(), result.get(i).getValue() - min_row));\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpbql2wn88.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpbql2wn88.java:47: error: cannot find symbol\n            if (a.getKey() < b.getKey()) {\n                 ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpbql2wn88.java:47: error: cannot find symbol\n            if (a.getKey() < b.getKey()) {\n                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpbql2wn88.java:50: error: cannot find symbol\n            if (a.getKey() > b.getKey()) {\n                 ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpbql2wn88.java:50: error: cannot find symbol\n            if (a.getKey() > b.getKey()) {\n                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpbql2wn88.java:53: error: method getValue in class Tuple cannot be applied to given types;\n            if (a.getValue() < b.getValue()) {\n                 ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpbql2wn88.java:53: error: method getValue in class Tuple cannot be applied to given types;\n            if (a.getValue() < b.getValue()) {\n                                ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpbql2wn88.java:56: error: method getValue in class Tuple cannot be applied to given types;\n            if (a.getValue() > b.getValue()) {\n                 ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpbql2wn88.java:56: error: method getValue in class Tuple cannot be applied",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpcc6nz8h5.java:58: error: not a statement\n            result.add\n                  ^\n/tmp/tmpcc6nz8h5.java:58: error: ';' expected\n            result.add\n                      ^\n/tmp/tmpcc6nz8h5.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpdzn3cwws.java:32)\n\tat Problem.main(tmpdzn3cwws.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = getRow(lst, x);\n        for (int i = 0; i < res_row.size(); i++) {\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpwhrbalas.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpwhrbalas.java:39: error: cannot find symbol\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n                                             ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpwpswr6aq.java:32)\n\tat Problem.main(tmpwpswr6aq.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        // Iterate through all rows and find the coordinates.\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpvxa45xu4.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292967,
      "stdout": "",
      "stderr": "/tmp/tmpu2am5kgz.java:30: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpu2am5kgz.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        long row = 0;\n        long column = 0;\n        for (ArrayList<Long> row_list : lst) {\n            for (Long column_list : row_list) {\n                if (column_list == x) {\n                    result.add(new Pair<>(row, column));\n                }\n                column++;\n            }\n            row++;\n            column = 0;\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmp9lkb5oyi.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp9lkb5oyi.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp9lkb5oyi.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp9lkb5oyi.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        Collections.sort(lst.get(0), (a, b) -> a.compareTo(b));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    ret.add(new Pair<>(i, lst.get(i).get(j)));\n                }\n            }\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpz6yybsa1.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, lst.get(i).get(j)));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, 1L));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, 2L));\n            result.add(new Pair<>(2L, 1L));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, 3L));\n            result.add(new Pair<>(2L, 2L));\n            result.add(new Pair<>(3L, 1L));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, 4L));\n            result.add(new Pair<>(2L, 3L));\n            result.add(new Pair<>(3L, 2L));\n            result.add(new Pair<>(4L, 1L));\n            return result;\n        }\n        if (lst.get(0).size() == 6) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, 5L));\n            result.add(new Pair<>(2L, 4L));\n            result.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfs7synmp.java:66: error: ')' expected\n            result.add(new Pair<>(3L\n                                    ^\n/tmp/tmpfs7synmp.java:68: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() > col) {\n                result.add(new Pair<>(row, col));\n                col = row_lst.size() - 1;\n            }\n            row++;\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmp9nzx_2z9.java:38: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp9nzx_2z9.java:38: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp9nzx_2z9.java:39: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp9nzx_2z9.java:39: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> sorted_lst = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            sorted_lst.addAll(lst.get(i));\n        }\n        sorted_lst.sort((a, b) -> b - a);\n        for (int i = 0; i < sorted_lst.size(); i++) {\n            if (sorted_lst.get(i) == x) {\n                res.add(new Pair<>(i, 0));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmph3m4w6je.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmph3m4w6je.java:41: error: incompatible types: bad return type in lambda expression\n        sorted_lst.sort((a, b) -> b - a);\n                                    ^\n    possible lossy conversion from long to int\n/tmp/tmph3m4w6je.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp629v5yjq.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp629v5yjq.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp629v5yjq.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0L));\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpnhmfjmx3.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpnhmfjmx3.java:46: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpnhmfjmx3.java:50: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) return res;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            row.add(lst.get(i).get(x));\n        }\n        Collections.sort(row);\n        for (int i = 0; i < row.size(); i++) {\n            res.add(new Pair<>(i, row.get(i)));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmp63jigft9.java:35: error: incompatible types: possible lossy conversion from long to int\n            row.add(lst.get(i).get(x));\n                                   ^\n/tmp/tmp63jigft9.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n            res.add(new Pair<>(i, row.get(i)));\n                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                result.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpi2l4uh7j.java:32: error: incompatible types: possible lossy conversion from long to int\n                result.add(new Pair<>(i, lst.get(i).get(x)));\n                                                        ^\n/tmp/tmpi2l4uh7j.java:35: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpi2l4uh7j.java:35: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            row.add(lst.get(0).get(i));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            ArrayList<Long> newRow = new ArrayList<>();\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                newRow.add(lst.get(i).get(j));\n            }\n            for (int j = 0; j < row.size(); j++) {\n                if (newRow.get(j) > row.get(j)) {\n                    row.set(j, newRow.get(j));\n                }\n            }\n        }\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(0, i));\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmppp8nz60e.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmppp8nz60e.java:53: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(0, i));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        int n = lst.size();\n        long[] row = new long[n];\n        for (int i = 0; i < n; i++) {\n            row[i] = lst.get(i).get(x);\n        }\n        Arrays.sort(row);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (row[i] == lst.get(j).get(x)) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp8c2dlvjh.java:32: error: incompatible types: possible lossy conversion from long to int\n            row[i] = lst.get(i).get(x);\n                                    ^\n/tmp/tmp8c2dlvjh.java:37: error: incompatible types: possible lossy conversion from long to int\n                if (row[i] == lst.get(j).get(x)) {\n                                             ^\n/tmp/tmp8c2dlvjh.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                result.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpi2l4uh7j.java:32: error: incompatible types: possible lossy conversion from long to int\n                result.add(new Pair<>(i, lst.get(i).get(x)));\n                                                        ^\n/tmp/tmpi2l4uh7j.java:35: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpi2l4uh7j.java:35: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long[] rows = new long[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            rows[i] = lst.get(i).size();\n        }\n        Arrays.sort(rows);\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows[i]; j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpg5cr1h38.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        int row = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            int col = 0;\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp23vonpz6.java:34: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(row, col));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (x < 0 || x >= lst.size()) return res;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            res.add(new Pair<>(x, i));\n        }\n        Collections.sort(res, new Comparator<Pair<Long, Long>>() {\n            @Override\n            public int compare(Pair<Long, Long> o1, Pair<Long, Long> o2) {\n                return o1.getValue1() - o2.getValue1();\n            }\n        });\n        Collections.sort(lst.get(x), new Comparator<Long>() {\n            @Override\n            public int compare(Long o1, Long o2) {\n                return o2 - o1;\n            }\n        });\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            res.add(new Pair<>(lst.get(x).get(i), i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpc2kr120d.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmpc2kr120d.java:29: error: incompatible types: cannot infer type arguments for Pair<>\n            res.add(new Pair<>(x, i));\n                            ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpc2kr120d.java:34: error: incompatible types: possible lossy conversion from long to int\n                return o1.getValue1() - o2.getValue1();\n                                      ^\n/tmp/tmpc2kr120d.java:40: error: incompatible types: possible lossy conversion from long to int\n                return o2 - o1;\n                          ^\n/tmp/tmpc2kr120d.java:37: error: incompatible types: possible lossy conversion from long to int\n        Collections.sort(lst.get(x), new Comparator<Long>() {\n                                 ^\n/tmp/tmpc2kr120d.java:43: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmpc2kr120d.java:44: error: incompatible types: possible lossy conversion from long to int\n            res.add(new Pair<>(lst.get(x).get(i), i));\n                                       ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n7 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            if (row.size() == 0) continue;\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp9t5qfq5k.java:31: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmp9t5qfq5k.java:34: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    result.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpmjr207i3.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpmjr207i3.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpmjr207i3.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpmjr207i3.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add(new Pair<>(0L, lst.get(i).get(2)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add(new Pair<>(0L, lst.get(i).get(2)));\n                res.add(new Pair<>(0L, lst.get(i).get(3)));\n            }\n            return res;\n        }\n        if (\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmprf3v7ixz.java:63: error: illegal start of expression\n    }\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        for (int i = 0; i < res1.size(); i++) {\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue()));\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < res.size(); i++) {\n            res.set(i, new Pair<>(res.get(i).getKey(), res.get(i).getValue() + 1));\n        }\n        Collections.sort(res, (a, b) -> b.getKey() - a.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpoewl3p6f.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpoewl3p6f.java:39: error: cannot find symbol\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue()));\n                                          ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpoewl3p6f.java:39: error: method getValue in class Tuple cannot be applied to given types;\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue()));\n                                                                ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpoewl3p6f.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpoewl3p6f.java:41: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpoewl3p6f.java:43: error: method getValue in class Tuple cannot be applied to given types;\n            res.set(i, new Pair<>(res.get(i).getKey(), res.get(i).getValue() + 1));\n                                                                 ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpoewl3p6f.java:43: error: cannot find symbol\n            res.set(i, new Pair<>(res.get(i).getKey(), res.get(i).getValue() + 1));\n                                            ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpoewl3p6f.ja",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.size() == 1) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add(new Pair<>(0L, lst.get(i).get(2)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpc2le29t0.java:59: error: not a statement\n                res.add\n                   ^\n/tmp/tmpc2le29t0.java:59: error: ';' expected\n                res.add\n                       ^\n/tmp/tmpc2le29t0.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, 0L));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            result.add(new Pair<>(4L, lst.get(0).\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpcaqqj_fu.java:59: error: <identifier> expected\n            result.add(new Pair<>(4L, lst.get(0).\n                                                 ^\n/tmp/tmpcaqqj_fu.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpx6yqblu7.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpx6yqblu7.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpx6yqblu7.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpx6yqblu7.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpx6yqblu7.java:36: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) {\n            return ret;\n        }\n        if (lst.get(0).size() == 0) {\n            return ret;\n        }\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        if (lst.get(0).size() == 2) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            return ret;\n        }\n        if (lst.get(0).size() == 3) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            return ret;\n        }\n        if (lst.get(0).size() == 4) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            ret.add(new Pair<>(0L, lst.get(0).get(3)));\n            return ret;\n        }\n        if (lst.get(0).size() == 5) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            ret.add(new Pair<>(0L, lst.get(0).get(1)));\n            ret.add(new Pair<>(0L, lst.get(0).get(2)));\n            ret.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmp8fzjilhq.java:58: error: not a statement\n            ret.add\n               ^\n/tmp/tmp8fzjilhq.java:58: error: ';' expected\n            ret.add\n                   ^\n/tmp/tmp8fzjilhq.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = getRow(lst, x);\n        for (int i = 0; i < res_row.size(); i++) {\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp9b8b317u.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp9b8b317u.java:38: error: cannot find symbol\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n                                             ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        for (int i = 0; i < res1.size(); i++) {\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue() + 1));\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpqmctld1o.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpqmctld1o.java:39: error: method getValue in class Tuple cannot be applied to given types;\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue() + 1));\n                                                                ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpqmctld1o.java:39: error: cannot find symbol\n            res.add(new Pair<>(res1.get(i).getKey(), res1.get(i).getValue() + 1));\n                                          ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpqmctld1o.java:43: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(0L, lst.get(i).get(0)));\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res2 = getRow(lst, x);\n        Collections.sort(res1, (a, b) -> a.getKey().compareTo(b.getKey()));\n        Collections.sort(res2, (a, b) -> b.getKey().compareTo(a.getKey()));\n        for (int i = 0; i < res1.size(); i++) {\n            for (int j = 0; j < res2.size(); j++) {\n                if (res1.get(i).getKey() == res2.get(j).getKey()) {\n                    res.add(new Pair<>(res1.get(i).getKey(), res2.get(j).getKey()));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpnt56gj03.java:42: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                          ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpnt56gj03.java:42: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                               ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpnt56gj03.java:43: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> b.getKey().compareTo(a.getKey()));\n                                          ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpnt56gj03.java:43: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> b.getKey().compareTo(a.getKey()));\n                                                               ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpnt56gj03.java:46: error: cannot find symbol\n                if (res1.get(i).getKey() == res2.get(j).getKey()) {\n                               ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpnt56gj03.java:46: error: cannot find symbol\n                if (res1.get(i).getKey() == res2.get(j).getKey()) {\n                                                       ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpnt56gj03.java:47: error: cannot find symbol\n                    res.add(new Pair<>(res1.get(i).getKey(), res2.get(j).getKey()));\n                                                  ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmpnt56gj03.java:47: error: cannot find symbol\n                    res.add(new Pair<>(res1.get(i).getKey(), res2.get(j).getKey()));\n                                                                        ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n8 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, 0L));\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > col) {\n                row = i;\n                col = lst.get(i).size() - 1;\n            }\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            if (lst.get(row).get(i) == x) {\n                res.add(new Pair<>(row, i));\n                break;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpg70lp2lz.java:40: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmpg70lp2lz.java:41: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(i) == x) {\n                        ^\n/tmp/tmpg70lp2lz.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(row, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        // Iterate over the rows and find the coordinates.\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            // Iterate over the columns and find the coordinates.\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmptdtqyiak.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpgntco2fs.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            if (lst.get(0).get(1) == x) {\n                res.add(new Pair<>(0L, 1L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            if (lst.get(0).get(1) == x) {\n                res.add(new Pair<>(0L, 1L));\n                return res;\n            }\n            if (lst.get(0).get(2) == x) {\n                res.add(new Pair<>(0L, 2L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            if (lst.get(0).get(1) == x) {\n                res.add(new Pair<>(0L, 1L));\n                return res;\n            }\n            if (lst\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpkh1o5izo.java:74: error: ')' expected\n            if (lst\n                   ^\n/tmp/tmpkh1o5izo.java:75: error: illegal start of statement\n    }\n    ^\n/tmp/tmpkh1o5izo.java:76: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpx6jg7ytk.java:34)\n\tat Problem.main(tmpx6jg7ytk.java:44)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpm33xjted.java:54: error: ')' expected\n            res.add(new Pair<>(3L, lst.get\n                                          ^\n/tmp/tmpm33xjted.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) continue;\n            if (lst.get(i).size() == 1) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            row = i;\n            col = lst.get(i).size() - 1;\n            break;\n        }\n        if (row == 0 && col == 0) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (row == 0) {\n            for (int i = 0; i < lst.get(0).size(); i++) {\n                res.add(new Pair<>(0L, lst.get(0).get(i)));\n            }\n            return res;\n        }\n        if (col == 0) {\n            for (int i = 0; i < lst.get(row).size(); i++) {\n                res.add(new Pair<>(row, lst.get(row).get(i)));\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            res.add(new Pair<>(row, lst.get(row).get(i)));\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            res.add(new Pair<>(row, lst.get(row).get(i)));\n        }\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp13ltr8qa.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp13ltr8qa.java:55: error: incompatible types: possible lossy conversion from long to int\n            for (int i = 0; i < lst.get(row).size(); i++) {\n                                        ^\n/tmp/tmp13ltr8qa.java:56: error: incompatible types: possible lossy conversion from long to int\n                res.add(new Pair<>(row, lst.get(row).get(i)));\n                                                ^\n/tmp/tmp13ltr8qa.java:60: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmp13ltr8qa.java:61: error: incompatible types: possible lossy conversion from long to int\n            res.add(new Pair<>(row, lst.get(row).get(i)));\n                                            ^\n/tmp/tmp13ltr8qa.java:63: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmp13ltr8qa.java:64: error: incompatible types: possible lossy conversion from long to int\n            res.add(new Pair<>(row, lst.get(row).get(i)));\n                                            ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n7 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return ret;\n        if (x < 0 || x >= lst.size()) return ret;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            ret.add(new Pair<>(lst.get(x).get(i), i));\n        }\n        Collections.sort(ret, (a, b) -> a.getKey().compareTo(b.getKey()));\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            ret.add(new Pair<>(lst.get(x).get(i), i));\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp7n9nreqa.java:28: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp7n9nreqa.java:29: error: incompatible types: possible lossy conversion from long to int\n            ret.add(new Pair<>(lst.get(x).get(i), i));\n                                       ^\n/tmp/tmp7n9nreqa.java:31: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp7n9nreqa.java:31: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp7n9nreqa.java:32: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp7n9nreqa.java:33: error: incompatible types: possible lossy conversion from long to int\n            ret.add(new Pair<>(lst.get(x).get(i), i));\n                                       ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n6 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpq9r2nfi7.java:58: error: not a statement\n            res.add\n               ^\n/tmp/tmpq9r2nfi7.java:58: error: ';' expected\n            res.add\n                   ^\n/tmp/tmpq9r2nfi7.java:60: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        ArrayList<Long> row = lst.get(0);\n        if (row.size() == 0) return res;\n        Collections.sort(row);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(0L, i));\n                break;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            row = lst.get(i);\n            if (row.size() == 0) continue;\n            Collections.sort(row, Collections.reverseOrder());\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpqvnlfl_n.java:32: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(0L, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpqvnlfl_n.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        long row = 0, col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst == null || row_lst.size() == 0) continue;\n            for (Long col_lst : row_lst) {\n                if (col_lst == null) continue;\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpe1odgi92.java:40: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpe1odgi92.java:40: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpe1odgi92.java:41: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpe1odgi92.java:41: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(lst.get(i).get(0), i));\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(lst.get(i).get(0), i));\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) > x) return res;\n        if (lst.get(0).get(0) < x) return res;\n        for (int i = 1; i < lst.get(0).size(); i++) {\n            if (lst.get(0).get(i) == x) {\n                for (int j = 0; j < lst.size(); j++) {\n                    res.add(new Pair<>(lst.get(j).get(i), j));\n                }\n                return res;\n            }\n            if (lst.get(0).get(i) > x) return res;\n            if (lst.get(0).get(i) < x) return res;\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    for (int k = 0; k < lst.size(); k++) {\n                        res.add(new Pair<>(lst.get(k).get(j), k));\n                    }\n                    return res;\n                }\n                if (lst.get(i).get(j) >\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpef5y5y7_.java:61: error: illegal start of expression\n    }\n    ^\n/tmp/tmpef5y5y7_.java:62: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (lst.get(0).size() == 0) return result;\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        ArrayList<Pair<Long, Long>> row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            row.add(new Pair<>(i, lst.get(i).get(0)));\n        }\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n        Collections.sort(row, (a, b) -> b.getKey().compareTo(a.getKey()));\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i).getKey() == x) {\n                result.add(new Pair<>(row.get(i).getKey(), row.get(i).getValue()));\n                break;\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp183d9c9w.java:34: error: incompatible types: cannot infer type arguments for Pair<>\n            row.add(new Pair<>(i, lst.get(i).get(0)));\n                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp183d9c9w.java:36: error: cannot find symbol\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp183d9c9w.java:36: error: cannot find symbol\n        Collections.sort(row, (a, b) -> a.getKey().compareTo(b.getKey()));\n                                                              ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp183d9c9w.java:37: error: cannot find symbol\n        Collections.sort(row, (a, b) -> b.getKey().compareTo(a.getKey()));\n                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp183d9c9w.java:37: error: cannot find symbol\n        Collections.sort(row, (a, b) -> b.getKey().compareTo(a.getKey()));\n                                                              ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp183d9c9w.java:39: error: cannot find symbol\n            if (row.get(i).getKey() == x) {\n                          ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmp183d9c9w.java:40: error: cannot find symbol\n                result.add(new Pair<>(row.get(i).getKey(), row.get(i).getValue()));\n                                                ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmp183d9c9w.java:40: error: method getValue in class Tuple cannot be applied to given types;\n                result.add(new Pair<>(row.get(i).getKey(), row.get(i).getValue()));\n                                         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > x) {\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpgc1j4n3u.java:32: error: incompatible types: possible lossy conversion from long to int\n                res.add(new Pair<>(i, lst.get(i).get(x)));\n                                                     ^\n/tmp/tmpgc1j4n3u.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpgc1j4n3u.java:35: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long maxRow = lst.size();\n        long maxCol = lst.get(0).size();\n        long row = 0;\n        long col = 0;\n        while (row < maxRow && col < maxCol) {\n            if (lst.get(row).get(col) == x) {\n                res.add(new Pair<>(row, col));\n                row++;\n                col++;\n            } else if (lst.get(row).get(col) < x) {\n                row++;\n            } else {\n                col++;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmptnnutjyt.java:32: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(col) == x) {\n                        ^\n/tmp/tmptnnutjyt.java:36: error: incompatible types: possible lossy conversion from long to int\n            } else if (lst.get(row).get(col) < x) {\n                               ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long[] rows = new long[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            rows[i] = lst.get(i).size();\n        }\n        Arrays.sort(rows);\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows[i]; j++) {\n                res.add(new Pair<>(i, lst.get(i).get(j)));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getValue0() - b.getValue0());\n        Collections.sort(res, (a, b) -> b.getValue1() - a.getValue1());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp3r593bfe.java:34: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(j)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp3r593bfe.java:37: error: incompatible types: cannot infer type-variable(s) T\n        Collections.sort(res, (a, b) -> a.getValue0() - b.getValue0());\n                        ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmp3r593bfe.java:38: error: incompatible types: cannot infer type-variable(s) T\n        Collections.sort(res, (a, b) -> b.getValue1() - a.getValue1());\n                        ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        long row = 0, col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() > col) {\n                res.add(new Pair<>(row, col));\n                row = row_lst.get(col);\n                col = 0;\n            }\n            col++;\n        }\n        res.add(new Pair<>(row, col));\n        Collections.sort(res, (p1, p2) -> p1.getKey() - p2.getKey());\n        Collections.sort(res, (p1, p2) -> p1.getValue() - p2.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpln0y8262.java:31: error: incompatible types: possible lossy conversion from long to int\n                row = row_lst.get(col);\n                                  ^\n/tmp/tmpln0y8262.java:37: error: cannot find symbol\n        Collections.sort(res, (p1, p2) -> p1.getKey() - p2.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable p1 of type Pair<Long,Long>\n/tmp/tmpln0y8262.java:37: error: cannot find symbol\n        Collections.sort(res, (p1, p2) -> p1.getKey() - p2.getKey());\n                                                          ^\n  symbol:   method getKey()\n  location: variable p2 of type Pair<Long,Long>\n/tmp/tmpln0y8262.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (p1, p2) -> p1.getValue() - p2.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpln0y8262.java:38: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (p1, p2) -> p1.getValue() - p2.getValue());\n                                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long[] rows = new long[lst.size()];\n        for (int i = 0; i < lst.size(); i++) {\n            rows[i] = lst.get(i).size();\n        }\n        Arrays.sort(rows);\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows[i]; j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpg5cr1h38.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> b.compareTo(a)));\n        // Iterate through the array list, and find the coordinates of x.\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmp5x3uw98o.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        if (lst.get(0).size() == 0) {\n            return res;\n        }\n        long max_row = lst.size() - 1;\n        long max_col = lst.get(0).size() - 1;\n        long row = 0;\n        long col = 0;\n        while (row <= max_row && col <= max_col) {\n            if (lst.get(row).get(col) == x) {\n                res.add(new Pair<>(row, col));\n                col++;\n            } else if (lst.get(row).get(col) < x) {\n                col++;\n            } else {\n                row++;\n            }\n        }\n        Collections.sort(res, new Comparator<Pair<Long, Long>>() {\n            @Override\n            public int compare(Pair<Long, Long> o1, Pair<Long, Long> o2) {\n                if (o1.getKey() < o2.getKey()) {\n                    return -1;\n                } else if (o1.getKey() > o2.getKey()) {\n                    return 1;\n                } else {\n                    return o1.getValue() - o2.getValue();\n                }\n            }\n        });\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpb3dwje9_.java:37: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(col) == x) {\n                        ^\n/tmp/tmpb3dwje9_.java:40: error: incompatible types: possible lossy conversion from long to int\n            } else if (lst.get(row).get(col) < x) {\n                               ^\n/tmp/tmpb3dwje9_.java:49: error: cannot find symbol\n                if (o1.getKey() < o2.getKey()) {\n                      ^\n  symbol:   method getKey()\n  location: variable o1 of type Pair<Long,Long>\n/tmp/tmpb3dwje9_.java:49: error: cannot find symbol\n                if (o1.getKey() < o2.getKey()) {\n                                    ^\n  symbol:   method getKey()\n  location: variable o2 of type Pair<Long,Long>\n/tmp/tmpb3dwje9_.java:51: error: cannot find symbol\n                } else if (o1.getKey() > o2.getKey()) {\n                             ^\n  symbol:   method getKey()\n  location: variable o1 of type Pair<Long,Long>\n/tmp/tmpb3dwje9_.java:51: error: cannot find symbol\n                } else if (o1.getKey() > o2.getKey()) {\n                                           ^\n  symbol:   method getKey()\n  location: variable o2 of type Pair<Long,Long>\n/tmp/tmpb3dwje9_.java:54: error: method getValue in class Tuple cannot be applied to given types;\n                    return o1.getValue() - o2.getValue();\n                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpb3dwje9_.java:54: error: method getValue in class Tuple cannot be applied to given types;\n                    return o1.getValue() - o2.getValue();\n                                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n8 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmp46f080wj.java:35: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmp46f080wj.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n            } else {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292976,
      "stdout": "",
      "stderr": "/tmp/tmpvy1vj9d9.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpvy1vj9d9.java:45: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpvy1vj9d9.java:49: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpxf3o2j9m.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpxf3o2j9m.java:40: error: incompatible types: cannot infer type arguments for Pair<>\n                        res.add(new Pair<>(i, j));\n                                        ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).get(0) == x) {\n            result.add(new Pair<>(0L, 0L));\n            return result;\n        }\n        if (lst.get(0).get(0) < x) {\n            return result;\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                result.add(new Pair<>(i, 0L));\n                return result;\n            }\n            if (lst.get(i).get(0) < x) {\n                return result;\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpdkie3f8o.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(i, 0L));\n                                   ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, 0L));\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0L));\n                }\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, 0L));\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292973,
      "stdout": "",
      "stderr": "/tmp/tmpnhmfjmx3.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0L));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpnhmfjmx3.java:46: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpnhmfjmx3.java:50: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) continue;\n            Collections.sort(lst.get(i), (a, b) -> b - a);\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpgkunxfoh.java:30: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(lst.get(i), (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpgkunxfoh.java:33: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.size() == 0) {\n            return result;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpl4p8hbru.java:32: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpl4p8hbru.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = new ArrayList<>();\n        for (int i = 0; i < lst.get(0).size(); i++) {\n            if (lst.get(0).get(i) == x) {\n                res_row.add(new Pair<>(0, i));\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            ArrayList<Pair<Long, Long>> res_row_i = new ArrayList<>();\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res_row_i.add(new Pair<>(i, j));\n                }\n            }\n            res_row = merge(res_row, res_row_i);\n        }\n        return res_row;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpzm9nte2w.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpzm9nte2w.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                res_row.add(new Pair<>(0, i));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpzm9nte2w.java:46: error: incompatible types: cannot infer type arguments for Pair<>\n                    res_row_i.add(new Pair<>(i, j));\n                                          ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpzm9nte2w.java:49: error: cannot find symbol\n            res_row = merge(res_row, res_row_i);\n                      ^\n  symbol:   method merge(ArrayList<Pair<Long,Long>>,ArrayList<Pair<Long,Long>>)\n  location: class Problem\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpgntco2fs.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return result;\n        if (lst.get(0).size() == 0) return result;\n        if (x < 0 || x > lst.size()) return result;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            result.add(new Pair<>(lst.get(x).get(i), i));\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            result.get(i).setKey(result.get(i).getKey() + i);\n        }\n        Collections.sort(result, (a, b) -> b.getKey() - a.getKey());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmp9xctxu9h.java:29: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp9xctxu9h.java:30: error: incompatible types: possible lossy conversion from long to int\n            result.add(new Pair<>(lst.get(x).get(i), i));\n                                          ^\n/tmp/tmp9xctxu9h.java:32: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp9xctxu9h.java:32: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp9xctxu9h.java:33: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp9xctxu9h.java:34: error: cannot find symbol\n            result.get(i).setKey(result.get(i).getKey() + i);\n                                              ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\n/tmp/tmp9xctxu9h.java:36: error: cannot find symbol\n        Collections.sort(result, (a, b) -> b.getKey() - a.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp9xctxu9h.java:36: error: cannot find symbol\n        Collections.sort(result, (a, b) -> b.getKey() - a.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n8 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) return ret;\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    ret.add(new Pair<>(i, j));\n                }\n            }\n        }\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpp5cyyqq4.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpp5cyyqq4.java:35: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpp5cyyqq4.java:35: error: cannot find symbol\n        Collections.sort(ret, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            } else {\n                return res;\n            }\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            row.add(lst.get(i).get(0));\n        }\n        Collections.sort(row);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(i, 0L));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmphxy60bw1.java:43: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) > x) return res;\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1 && lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                return res;\n            }\n            if (lst.get(i).get(0) > x) return res;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpx4ffl57u.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_val : row_lst) {\n                if (col_val == x) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpfpyrdw6g.java:32)\n\tat Problem.main(tmpfpyrdw6g.java:43)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 0) {\n            return result;\n        }\n        if (lst.get(0).size() == 1) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            return result;\n        }\n        if (lst.get(0).size() == 2) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            return result;\n        }\n        if (lst.get(0).size() == 3) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            return result;\n        }\n        if (lst.get(0).size() == 4) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n            result.add(new Pair<>(3L, lst.get(0).get(3)));\n            return result;\n        }\n        if (lst.get(0).size() == 5) {\n            result.add(new Pair<>(0L, lst.get(0).get(0)));\n            result.add(new Pair<>(1L, lst.get(0).get(1)));\n            result.add(new Pair<>(2L, lst.get(0).get(2)));\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292965,
      "stdout": "",
      "stderr": "/tmp/tmpgntco2fs.java:59: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        Collections.sort(lst, (a, b) -> a.size() - b.size());\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            Collections.sort(row, (a, b) -> b - a);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "/tmp/tmpsomq__cz.java:32: error: incompatible types: cannot infer type-variable(s) T\n            Collections.sort(row, (a, b) -> b - a);\n                            ^\n    (argument mismatch; bad return type in lambda expression\n      possible lossy conversion from long to int)\n  where T is a type-variable:\n    T extends Object declared in method <T>sort(List<T>,Comparator<? super T>)\n/tmp/tmpsomq__cz.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) {\n            return ret;\n        }\n        if (lst.get(0).size() == 0) {\n            return ret;\n        }\n        if (lst.get(0).get(0) == x) {\n            ret.add(new Pair<>(0L, 0L));\n            return ret;\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                ret.add(new Pair<>(i, 0L));\n                break;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                ret.add(new Pair<>(i, lst.get(i).size() - 1));\n                break;\n            }\n        }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    ret.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpv6p02wzj.java:41: error: incompatible types: cannot infer type arguments for Pair<>\n                ret.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpv6p02wzj.java:50: error: incompatible types: cannot infer type arguments for Pair<>\n                ret.add(new Pair<>(i, lst.get(i).size() - 1));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpv6p02wzj.java:60: error: incompatible types: cannot infer type arguments for Pair<>\n                    ret.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (x < 0 || x >= lst.size()) return res;\n        if (lst.get(x).size() == 0) return res;\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            res.add(new Pair<>(x, i));\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < lst.get(x).size(); i++) {\n            Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmp118b2trx.java:28: error: incompatible types: possible lossy conversion from long to int\n        if (lst.get(x).size() == 0) return res;\n                    ^\n/tmp/tmp118b2trx.java:29: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp118b2trx.java:30: error: incompatible types: cannot infer type arguments for Pair<>\n            res.add(new Pair<>(x, i));\n                            ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmp118b2trx.java:32: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp118b2trx.java:32: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp118b2trx.java:33: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(x).size(); i++) {\n                                    ^\n/tmp/tmp118b2trx.java:34: error: method getValue in class Tuple cannot be applied to given types;\n            Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp118b2trx.java:34: error: method getValue in class Tuple cannot be applied to given types;\n            Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).get(0) > x) return res;\n        if (lst.get(0).get(0) < x) return res;\n        if (lst.get(0).get(0) == x) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                return res;\n            }\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                return res;\n            }\n            if (lst.get(i).get(0) > x) return res;\n            if (lst.get(i).get(0) < x) return res;\n            if (lst.get(i).get(0) == x) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpbtz7l6lb.java:44: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpbtz7l6lb.java:48: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpbtz7l6lb.java:54: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst.isEmpty()) {\n            return result;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    result.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpovsciqhs.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                            ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpovsciqhs.java:41: error: cannot find symbol\n        Collections.sort(result, (a, b) -> a.getKey() - b.getKey());\n                                                         ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpovsciqhs.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpovsciqhs.java:42: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(result, (a, b) -> a.getValue() - b.getValue());\n                                                           ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).get(0) == x) {\n                res_row.add(new Pair<>(i, 0));\n            }\n        }\n        Collections.sort(res_row, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < res_row.size(); i++) {\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmp1epw5q_a.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp1epw5q_a.java:40: error: incompatible types: cannot infer type arguments for Pair<>\n                res_row.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp1epw5q_a.java:43: error: cannot find symbol\n        Collections.sort(res_row, (a, b) -> a.getKey() - b.getKey());\n                                             ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmp1epw5q_a.java:43: error: cannot find symbol\n        Collections.sort(res_row, (a, b) -> a.getKey() - b.getKey());\n                                                          ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmp1epw5q_a.java:45: error: cannot find symbol\n            res.add(new Pair<>(res_row.get(i).getKey(), i));\n                                             ^\n  symbol:   method getKey()\n  location: class Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        ArrayList<Long> row = lst.get(0);\n        if (row == null || row.size() == 0) {\n            return result;\n        }\n        Collections.sort(row);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                result.add(new Pair<>(0L, i));\n                break;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            row = lst.get(i);\n            if (row == null || row.size() == 0) {\n                continue;\n            }\n            Collections.sort(row, Collections.reverseOrder());\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpc54104tr.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                result.add(new Pair<>(0L, i));\n                                   ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpc54104tr.java:48: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                continue;\n            }\n            if (lst.get(i).get(0) == x) {\n                row = i;\n                col = 0;\n                break;\n            }\n            for (int j = 1; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        if (row == 0) return res;\n        ArrayList<Pair<Long, Long>> res1 = new ArrayList<>();\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            if (i == col) continue;\n            res1.add(new Pair<>(row, lst.get(row).get(i)));\n        }\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n        res.addAll(res1);\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpcuaxm9t_.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, lst.get(i).get(0)));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcuaxm9t_.java:54: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmpcuaxm9t_.java:56: error: incompatible types: possible lossy conversion from long to int\n            res1.add(new Pair<>(row, lst.get(row).get(i)));\n                                             ^\n/tmp/tmpcuaxm9t_.java:58: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpcuaxm9t_.java:58: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> b.getKey() - a.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.isEmpty()) return res;\n        long max_row = lst.size();\n        long max_col = lst.get(0).size();\n        long row = 0, col = 0;\n        for (row = 0; row < max_row; row++) {\n            for (col = 0; col < max_col; col++) {\n                if (lst.get(row).get(col) == x) {\n                    res.add(new Pair<>(row, col));\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpmry3n5qf.java:32: error: incompatible types: possible lossy conversion from long to int\n                if (lst.get(row).get(col) == x) {\n                            ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            for (Long col_lst : row_lst) {\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292969,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpdzn3cwws.java:32)\n\tat Problem.main(tmpdzn3cwws.java:42)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n        // Iterate through the list and find the coordinates.\n        for (int i = 0; i < lst.size(); i++) {\n            ArrayList<Long> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpuzt9n8v5.java:32: error: cannot find symbol\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n                                               ^\n  symbol:   method get(int)\n  location: variable a of type Long\n/tmp/tmpuzt9n8v5.java:32: error: cannot find symbol\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n                                                                  ^\n  symbol:   method get(int)\n  location: variable b of type Long\n/tmp/tmpuzt9n8v5.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res_row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                res_row.add(new Pair<>(i, 0));\n            } else {\n                for (int j = 0; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) {\n                        res_row.add(new Pair<>(i, j));\n                    }\n                }\n            }\n        }\n        Collections.sort(res_row, (a, b) -> a.getValue() > b.getValue() ? -1 : 1);\n        for (int i = 0; i < res_row.size(); i++) {\n            res.add(res_row.get(i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmp_27_f0s7.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp_27_f0s7.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                res_row.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp_27_f0s7.java:43: error: incompatible types: cannot infer type arguments for Pair<>\n                        res_row.add(new Pair<>(i, j));\n                                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmp_27_f0s7.java:48: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res_row, (a, b) -> a.getValue() > b.getValue() ? -1 : 1);\n                                             ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmp_27_f0s7.java:48: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res_row, (a, b) -> a.getValue() > b.getValue() ? -1 : 1);\n                                                            ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(1L, lst.get(0).get(1)));\n            res.add(new Pair<>(2L, lst.get(0).get(2)));\n            res.add(new Pair<>(3L\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292962,
      "stdout": "",
      "stderr": "/tmp/tmpt8s4ind_.java:54: error: ')' expected\n            res.add(new Pair<>(3L\n                                 ^\n/tmp/tmpt8s4ind_.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> result = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return result;\n        }\n        // Sort coordinates by rows in ascending order.\n        lst.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() == 0) {\n                continue;\n            }\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpjeqgb0ux.java:32: error: cannot find symbol\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n                                               ^\n  symbol:   method get(int)\n  location: variable a of type Long\n/tmp/tmpjeqgb0ux.java:32: error: cannot find symbol\n        lst.forEach(row -> row.sort((a, b) -> a.get(1).compareTo(b.get(1))));\n                                                                  ^\n  symbol:   method get(int)\n  location: variable b of type Long\n/tmp/tmpjeqgb0ux.java:39: error: incompatible types: cannot infer type arguments for Pair<>\n                    result.add(new Pair<>(i, j));\n                                       ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i).get(0) == x) {\n                    res.add(new Pair<>(i, 0));\n                    return res;\n                }\n            }\n            return res;\n        }\n        ArrayList<Pair<Long, Long>> res1 = getRow(lst, x);\n        ArrayList<Pair<Long, Long>> res2 = getRow(lst, x);\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res2, (a, b) -> a.getKey() - b.getKey());\n        for (int i = 0; i < res1.size(); i++) {\n            res.add(res1.get(i));\n        }\n        for (int i = 0; i < res2.size(); i++) {\n            res.add(res2.get(i));\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpcv20mf1v.java:31: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, 0));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpcv20mf1v.java:39: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpcv20mf1v.java:39: error: cannot find symbol\n        Collections.sort(res1, (a, b) -> a.getKey() - b.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpcv20mf1v.java:40: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> a.getKey() - b.getKey());\n                                          ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpcv20mf1v.java:40: error: cannot find symbol\n        Collections.sort(res2, (a, b) -> a.getKey() - b.getKey());\n                                                       ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) return res;\n            else return res;\n        }\n        if (lst.get(0).get(0) == x) res.add(new Pair<>(0L, 0L));\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).size() == 1) {\n                if (lst.get(i).get(0) == x) res.add(new Pair<>(i, 0L));\n                else res.add(new Pair<>(i, 1L));\n            } else {\n                if (lst.get(i).get(0) == x) res.add(new Pair<>(i, 0L));\n                for (int j = 1; j < lst.get(i).size(); j++) {\n                    if (lst.get(i).get(j) == x) res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpepx3dkie.java:35: error: incompatible types: cannot infer type arguments for Pair<>\n                if (lst.get(i).get(0) == x) res.add(new Pair<>(i, 0L));\n                                                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpepx3dkie.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                else res.add(new Pair<>(i, 1L));\n                                     ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpepx3dkie.java:38: error: incompatible types: cannot infer type arguments for Pair<>\n                if (lst.get(i).get(0) == x) res.add(new Pair<>(i, 0L));\n                                                            ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\n/tmp/tmpepx3dkie.java:40: error: incompatible types: cannot infer type arguments for Pair<>\n                    if (lst.get(i).get(j) == x) res.add(new Pair<>(i, j));\n                                                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n4 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add(new Pair<>(0L, lst.get(i).get(2)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            for (int i = 0; i < lst.size(); i++) {\n                res.add(new Pair<>(0L, lst.get(i).get(0)));\n                res.add(new Pair<>(0L, lst.get(i).get(1)));\n                res.add(new Pair<>(0L, lst.get(i).get(2)));\n                res.add(new Pair<>(0L, lst.get(i).get(3)));\n            }\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            for (\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "/tmp/tmpdqig7jzh.java:60: error: illegal start of expression\n    }\n    ^\n/tmp/tmpdqig7jzh.java:61: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        // Sort coordinates by rows in ascending order.\n        Collections.sort(lst, (a, b) -> a.get(0).compareTo(b.get(0)));\n        // Sort coordinates of the row by columns in descending order.\n        Collections.sort(lst, (a, b) -> b.get(1).compareTo(a.get(1)));\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    res.add(new Pair<>(i, j));\n                }\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmp1q48wz2g.java:36: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(i, j));\n                                    ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst == null || row_lst.size() == 0) continue;\n            for (Long col_lst : row_lst) {\n                if (col_lst == null) continue;\n                if (col_lst == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpd19xmxg8.java:34)\n\tat Problem.main(tmpd19xmxg8.java:44)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() > col) {\n                row = row_lst.get(col);\n                col++;\n            }\n        }\n        for (ArrayList<Long> row_lst : lst) {\n            if (row_lst.size() > col) {\n                row = row_lst.get(col);\n                col++;\n            }\n            for (int i = 0; i < row_lst.size(); i++) {\n                if (row_lst.get(i) == x) {\n                    res.add(new Pair<>(row, i));\n                }\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> b.getValue() - a.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpccrhgmae.java:31: error: incompatible types: possible lossy conversion from long to int\n                row = row_lst.get(col);\n                                  ^\n/tmp/tmpccrhgmae.java:37: error: incompatible types: possible lossy conversion from long to int\n                row = row_lst.get(col);\n                                  ^\n/tmp/tmpccrhgmae.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                    res.add(new Pair<>(row, i));\n                                    ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpccrhgmae.java:46: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpccrhgmae.java:46: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpccrhgmae.java:47: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> b.getValue() - a.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpccrhgmae.java:47: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> b.getValue() - a.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n7 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i).size() > col) {\n                row = i;\n                col = lst.get(i).size() - 1;\n            }\n        }\n        for (int i = 0; i < lst.get(row).size(); i++) {\n            if (lst.get(row).get(i) == x) {\n                res.add(new Pair<>(row, i));\n            }\n        }\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpmgh25074.java:35: error: incompatible types: possible lossy conversion from long to int\n        for (int i = 0; i < lst.get(row).size(); i++) {\n                                    ^\n/tmp/tmpmgh25074.java:36: error: incompatible types: possible lossy conversion from long to int\n            if (lst.get(row).get(i) == x) {\n                        ^\n/tmp/tmpmgh25074.java:37: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(row, i));\n                                ^\n    reason: inference variable B has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where B is a type-variable:\n    B extends Object declared in class Pair\n/tmp/tmpmgh25074.java:40: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                         ^\n  symbol:   method getKey()\n  location: variable a of type Pair<Long,Long>\n/tmp/tmpmgh25074.java:40: error: cannot find symbol\n        Collections.sort(res, (a, b) -> a.getKey() - b.getKey());\n                                                      ^\n  symbol:   method getKey()\n  location: variable b of type Pair<Long,Long>\n/tmp/tmpmgh25074.java:41: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                         ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\n/tmp/tmpmgh25074.java:41: error: method getValue in class Tuple cannot be applied to given types;\n        Collections.sort(res, (a, b) -> a.getValue() - b.getValue());\n                                                        ^\n  required: int\n  found:    no arguments\n  reason: actual and formal argument lists differ in length\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n7 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> ret = new ArrayList<>();\n        if (lst.size() == 0) return ret;\n        if (lst.get(0).size() == 0) return ret;\n        if (lst.get(0).size() == 1) {\n            ret.add(new Pair<>(0L, lst.get(0).get(0)));\n            return ret;\n        }\n        long row = 0;\n        long col = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            row = i;\n            col = 0;\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    ret.add(new Pair<>(row, col));\n                    return ret;\n                }\n                col++;\n            }\n        }\n        return ret;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmpf3ebb7li.java:39)\n\tat Problem.main(tmpf3ebb7li.java:48)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            if (lst.get(0).get(0) == x) {\n                res.add(new Pair<>(0L, 0L));\n                return res;\n            }\n            return res;\n        }\n        ArrayList<Long> row = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            row.add(lst.get(i).get(0));\n        }\n        Collections.sort(row);\n        for (int i = 0; i < row.size(); i++) {\n            if (row.get(i) == x) {\n                res.add(new Pair<>(i, 0L));\n                return res;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "/tmp/tmpnsvya1id.java:42: error: incompatible types: cannot infer type arguments for Pair<>\n                res.add(new Pair<>(i, 0L));\n                                ^\n    reason: inference variable A has incompatible bounds\n      equality constraints: Long\n      lower bounds: Integer\n  where A is a type-variable:\n    A extends Object declared in class Pair\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst == null || lst.size() == 0) {\n            return res;\n        }\n        long row = 0;\n        long col = 0;\n        for (ArrayList<Long> row_list : lst) {\n            for (Long col_list : row_list) {\n                if (col_list == x) {\n                    res.add(new Pair<>(row, col));\n                }\n                col++;\n            }\n            row++;\n            col = 0;\n        }\n        return res;\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292979,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.NoClassDefFoundError: org/javatuples/Pair\n\tat Problem.getRow(tmp19qhmosa.java:34)\n\tat Problem.main(tmp19qhmosa.java:44)\nCaused by: java.lang.ClassNotFoundException: org.javatuples.Pair\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\t... 2 more\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // You are given a 2 dimensional data, as a nested array lists,\n    // which is similar to matrix, however, unlike matrices,\n    // each row may contain a different number of columns.\n    // Given lst, and integer x, find integers x in the array list,\n    // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that\n    // each pair is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates initially by rows in ascending order.\n    // Also, sort coordinates of the row by columns in descending order.\n    // Examples:\n    // >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    // [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    // >>> get_row([], 1)\n    // []\n    // >>> get_row([[], [1], [1, 2, 3]], 3)\n    // [(2, 2)]\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> res = new ArrayList<>();\n        if (lst.size() == 0) return res;\n        if (lst.get(0).size() == 0) return res;\n        if (lst.get(0).size() == 1) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            return res;\n        }\n        if (lst.get(0).size() == 2) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            return res;\n        }\n        if (lst.get(0).size() == 3) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            return res;\n        }\n        if (lst.get(0).size() == 4) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get(0).get(3)));\n            return res;\n        }\n        if (lst.get(0).size() == 5) {\n            res.add(new Pair<>(0L, lst.get(0).get(0)));\n            res.add(new Pair<>(0L, lst.get(0).get(1)));\n            res.add(new Pair<>(0L, lst.get(0).get(2)));\n            res.add(new Pair<>(0L, lst.get\n    }\n    public static void main(String[] args) {\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 1l), (Pair<Long, Long>)Pair.with(1l, 1l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(3l, 1l), (Pair<Long, Long>)Pair.with(4l, 1l), (Pair<Long, Long>)Pair.with(5l, 1l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)1l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 1l), (Pair<Long, Long>)Pair.with(2l, 0l), (Pair<Long, Long>)Pair.with(3l, 2l), (Pair<Long, Long>)Pair.with(3l, 0l), (Pair<Long, Long>)Pair.with(4l, 3l), (Pair<Long, Long>)Pair.with(4l, 0l), (Pair<Long, Long>)Pair.with(5l, 4l), (Pair<Long, Long>)Pair.with(5l, 0l), (Pair<Long, Long>)Pair.with(6l, 5l), (Pair<Long, Long>)Pair.with(6l, 0l))))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l))))), (2l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList()))));\n    assert(getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l)).equals((new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))));\n    }\n\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp0smsbr9y.java:54: error: ')' expected\n            res.add(new Pair<>(0L, lst.get\n                                          ^\n/tmp/tmp0smsbr9y.java:56: error: illegal start of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}