name: HumanEval_88_sort_array
language: rs
results:
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptdk_66ee.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbgtg9_1i.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 1 && array[j] % 2 == 0 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 0 {\n                j -= 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n        if array[i] %\
    \ 2 == 0 {\n            array[i..].sort();\n            array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array[..i].sort();\n          \
    \  array[i..].sort_by(|a, b| b.cmp(a));\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp4bo7i5uo.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut array = array;\n    let mut i = 0;\n    let mut j = array.len() -\
    \ 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j] % 2 == 1 {\n\
    \            array.swap(i, j);\n            i += 1;\n            j -= 1;\n   \
    \     } else if array[i] % 2 == 1 {\n            i += 1;\n        } else if array[j]\
    \ % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if array.len() % 2 ==\
    \ 0 {\n        array[i..].sort();\n        array[..i].sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array[i..].sort_by(|a, b| b.cmp(a));\n        array[..i].sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 1, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8o7nbdck.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjskiqxb3.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < left.len()\
    \ && j < right.len() {\n            if left[i] < right[j] {\n                array[i\
    \ + j] = left[i];\n                i += 1;\n            } else {\n           \
    \     array[i + j] = right[j];\n                j += 1;\n            }\n     \
    \   }\n        while i < left.len() {\n            array[i + j] = left[i];\n \
    \           i += 1;\n        }\n        while j < right.len() {\n            array[i\
    \ + j] = right[j];\n            j += 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpfmory0mo.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpfmory0mo.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpfmory0mo.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpfmory0mo.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpfmory0mo.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9hx4t567.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdecxgdt5.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, i + 1);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpf4qn9_qr.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu2k81nm6.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         while array[left] < first {\n                left += 1;\n          \
    \  }\n            while array[right] > last {\n                right -= 1;\n \
    \           }\n            if left < right {\n                array.swap(left,\
    \ right);\n            }\n        }\n        array.swap(0, right);\n        array.swap(array.len()\
    \ - 1, right + 1);\n        if (first + last) % 2 == 0 {\n            array.reverse();\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpzi6u88ya.rs:32:20\n   |\n32 |         array.swap(array.len()\
    \ - 1, right + 1);\n   |         -----------^^^^^^^^^^^----------------\n   |\
    \         |     |    |\n   |         |     |    immutable borrow occurs here\n\
    \   |         |     mutable borrow later used by call\n   |         mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpzi6u88ya.rs:32:20\n   |\n32 |         array.swap(array.len() - 1, right\
    \ + 1);\n   |                    ^^^^^^^^^^^\nhelp: ...and then using that local\
    \ as the argument to this call\n  --> /tmp/tmpzi6u88ya.rs:32:9\n   |\n32 |   \
    \      array.swap(array.len() - 1, right + 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpn9rjud1m.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let sum\
    \ = first + last;\n        if sum % 2 == 0 {\n            array.sort_by(|a, b|\
    \ b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyr5nemuy.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwwcc32gf.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfdcmwxmw.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (left, right) = array.split_at_mut(array.len() / 2);\n        let left\
    \ = sort_array(left.to_vec());\n        let right = sort_array(right.to_vec());\n\
    \        array = merge(left, right);\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmp4t057v2t.rs:21:17\n\
    \   |\n21 |         array = merge(left, right);\n   |                 ^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpchhqv_5m.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpchhqv_5m.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpchhqv_5m.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpchhqv_5m.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpchhqv_5m.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpqcinf147.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmper8v0hz7.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpoqrtzmd_.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut index = 0;\n    let\
    \ mut index_end = array.len() - 1;\n    let mut is_odd = false;\n    if array.len()\
    \ > 1 {\n        if array[0] + array[index_end] % 2 == 1 {\n            is_odd\
    \ = true;\n        }\n        while index < index_end {\n            if is_odd\
    \ {\n                if array[index] > array[index_end] {\n                  \
    \  array.swap(index, index_end);\n                }\n            } else {\n  \
    \              if array[index] < array[index_end] {\n                    array.swap(index,\
    \ index_end);\n                }\n            }\n            index += 1;\n   \
    \         index_end -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbzgb5rtc.rs:18:25\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi_8a8xso.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \      array.sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp36zm01xr.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfznyxjea.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyskfh5e8.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplpmirxms.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6fd65brh.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5zvxw79q.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n            j\
    \ -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n        }\
    \ else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if len\
    \ % 2 == 0 {\n        array[..i].sort();\n        array[i..].sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array[..i].sort_by(|a, b| b.cmp(a));\n        array[i..].sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 5, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmps2ow57o5.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut left = 0;\n        let mut right = array.len() - 1;\n        while\
    \ left < right {\n            if (array[left] + array[right]) % 2 == 0 {\n   \
    \             array.swap(left, right);\n            }\n            left += 1;\n\
    \            right -= 1;\n        }\n        array.sort();\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpncg6tw1q.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpmdk7jvh9.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut left = 0;\n    let mut right = len - 1;\n    while\
    \ left < right {\n        if (array[left] + array[right]) % 2 == 0 {\n       \
    \     array.swap(left, right);\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    array.sort();\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpekasz7vo.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n     \
    \   array[i..].sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfzmtnywg.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt1mi3x2z.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp25eoe9g0.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpvxcb3wke.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (1, array.len() - 2);\n        while left <= right {\n  \
    \          while left <= right && array[left] < first {\n                left\
    \ += 1;\n            }\n            while left <= right && array[right] > last\
    \ {\n                right -= 1;\n            }\n            if left <= right\
    \ {\n                array.swap(left, right);\n                left += 1;\n  \
    \              right -= 1;\n            }\n        }\n        array.swap(0, right);\n\
    \        array.swap(array.len() - 1, left);\n        if (first + last) % 2 ==\
    \ 0 {\n            array[0..right + 1].sort();\n            array[left..array.len()].sort();\n\
    \        } else {\n            array[0..right + 1].sort_by(|a, b| b.cmp(a));\n\
    \            array[left..array.len()].sort_by(|a, b| b.cmp(a));\n        }\n \
    \   }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpcyotrugo.rs:34:20\n   |\n34 |         array.swap(array.len()\
    \ - 1, left);\n   |         -----------^^^^^^^^^^^-----------\n   |         |\
    \     |    |\n   |         |     |    immutable borrow occurs here\n   |     \
    \    |     mutable borrow later used by call\n   |         mutable borrow occurs\
    \ here\n   |\nhelp: try adding a local storing this argument...\n  --> /tmp/tmpcyotrugo.rs:34:20\n\
    \   |\n34 |         array.swap(array.len() - 1, left);\n   |                 \
    \   ^^^^^^^^^^^\nhelp: ...and then using that local as the argument to this call\n\
    \  --> /tmp/tmpcyotrugo.rs:34:9\n   |\n34 |         array.swap(array.len() - 1,\
    \ left);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot\
    \ borrow `array` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpcyotrugo.rs:37:25\n\
    \   |\n37 |             array[left..array.len()].sort();\n   |             ------------^^^^^^^^^^^-\n\
    \   |             |           |\n   |             |           immutable borrow\
    \ occurs here\n   |             mutable borrow occurs here\n   |             mutable\
    \ borrow later used here\n   |\nhelp: try adding a local storing this...\n  -->\
    \ /tmp/tmpcyotrugo.rs:37:25\n   |\n37 |             array[left..array.len()].sort();\n\
    \   |                         ^^^^^^^^^^^\nhelp: ...and then using that local\
    \ here\n  --> /tmp/tmpcyotrugo.rs:37:13\n   |\n37 |             array[left..array.len()].sort();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpcyotrugo.rs:40:25\n\
    \   |\n40 |             array[left..array.len()].sort_by(|a, b| b.cmp(a));\n \
    \  |             ------------^^^^^^^^^^^-\n   |             |           |\n  \
    \ |             |           immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpcyotrugo.rs:40:25\n  \
    \ |\n40 |             array[left..array.len()].s"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, i + 1);\n   \
    \     }\n        if array[0] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort();\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp2wn6b1dj.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpq5_hz1x2.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpriu2er_h.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7ouvhufl.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 1 {\n        array[i..].sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array[i..].sort();\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplbtw35lm.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() < 2 {\n    \
    \    return array;\n    }\n    let (mut i, mut j) = (0, array.len() - 1);\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp_62x_q5w.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return vec![];\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if array[i] % 2 == 0 && array[j] % 2 == 1 {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        } else if array[i] %\
    \ 2 == 1 && array[j] % 2 == 1 {\n            i += 1;\n        } else if array[i]\
    \ % 2 == 0 && array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n   \
    \         i += 1;\n            j -= 1;\n        }\n    }\n    let mut i = 0;\n\
    \    let mut j = len - 1;\n    if (array[i] + array[j]) % 2 == 0 {\n        while\
    \ i < j {\n            if array[i] > array[j] {\n                array.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \  } else {\n        while i < j {\n            if array[i] < array[j] {\n   \
    \             array.swap(i, j);\n            }\n            i += 1;\n        \
    \    j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpb7df_2o3.rs:66:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 0 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0un1_u79.rs:20:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8h_zl4ke.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let sum = array[0] + array[array.len() - 1];\n        if sum % 2 == 0 {\n\
    \            array.sort_by(|a, b| b.cmp(a));\n        } else {\n            array.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpt0myaq92.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] < array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3qm5qohr.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    if array.len() % 2 == 0 {\n        array.reverse();\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp81ll6vck.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpzpsjm4so.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpp26k16eu.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let sum\
    \ = first + last;\n        if sum % 2 == 0 {\n            array.sort_by(|a, b|\
    \ b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let (mut i, mut j) = (0, 0);\n        while i < left.len() && j < right.len()\
    \ {\n            if left[i] > right[j] {\n                array.push(left[i]);\n\
    \                i += 1;\n            } else {\n                array.push(right[j]);\n\
    \                j += 1;\n            }\n        }\n        while i < left.len()\
    \ {\n            array.push(left[i]);\n            i += 1;\n        }\n      \
    \  while j < right.len() {\n            array.push(right[j]);\n            j +=\
    \ 1;\n        }\n    }\n    if array.len() > 1 && array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpbvsxkiiz.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpbvsxkiiz.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpbvsxkiiz.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpbvsxkiiz.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n22 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpbvsxkiiz.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n21 |         let\
    \ (mut i, mut j) = (0, 0)"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    if array.len() % 2 == 0 {\n\
    \        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi4ymntkz.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpr22y8pkg.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpe6ap4vr8.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpnho9_6mf.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkq_a32_3.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpycpl3h48.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..i + 1].sort();\n            array[i + 1..].sort_by(|a, b|\
    \ b.cmp(a));\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp7mms1tlk.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..i].sort();\n            array[..i].reverse();\n        }\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_afconv8.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphphhfnq1.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n            j\
    \ -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n        }\
    \ else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if len\
    \ % 2 == 0 {\n        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n   \
    \     array[i..].sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpy470xlwd.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmmmrkpv2.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdv2rtim2.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp03jhkttm.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        let (first, last) = (result[0], result[result.len() - 1]);\n  \
    \      if (first + last) % 2 == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            result.sort_by(|a, b| a.cmp(b));\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp7sz3ryur.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmp7sz3ryur.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp7sz3ryur.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp7sz3ryur.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp7sz3ryur.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array.sort_by(|a, b| {\n       \
    \ if is_odd {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp64cgnvpt.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array.sort_by(|a, b| {\n       \
    \ if is_odd {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkr_81qs3.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpr2ac2e2r.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpr2ac2e2r.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpr2ac2e2r.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpr2ac2e2r.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpr2ac2e2r.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjswnq5_3.rs:20:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpj4i0tbdi.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpykte8d25.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, 0);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpph9znckh.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if array[i] % 2 == 0 && array[j] % 2 == 1 {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        } else if array[i] %\
    \ 2 == 1 && array[j] % 2 == 1 {\n            i += 1;\n        } else if array[i]\
    \ % 2 == 0 && array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n   \
    \         if (i + j) % 2 == 0 {\n                if array[i] > array[j] {\n  \
    \                  array.swap(i, j);\n                }\n            } else {\n\
    \                if array[i] < array[j] {\n                    array.swap(i, j);\n\
    \                }\n            }\n            i += 1;\n            j -= 1;\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp5z3hs2eo.rs:56:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj2e9re83.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ i, mut j) = (0, array.len() - 1);\n        while i < j {\n            if (first\
    \ + last) % 2 == 0 {\n                if array[i] > array[j] {\n             \
    \       array.swap(i, j);\n                }\n                j -= 1;\n      \
    \      } else {\n                if array[i] < array[j] {\n                  \
    \  array.swap(i, j);\n                }\n                i += 1;\n           \
    \ }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpuve_v5nf.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp72lz5wlq.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpytmftv23.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpiazx0ft1.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 1 {\n        array[i..].sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array[i..].sort();\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpniepf6q8.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi0t8fjjj.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i, j);\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpjd70dcrh.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < left.len()\
    \ && j < right.len() {\n            if left[i] < right[j] {\n                array[i\
    \ + j] = left[i];\n                i += 1;\n            } else {\n           \
    \     array[i + j] = right[j];\n                j += 1;\n            }\n     \
    \   }\n        while i < left.len() {\n            array[i + j] = left[i];\n \
    \           i += 1;\n        }\n        while j < right.len() {\n            array[i\
    \ + j] = right[j];\n            j += 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp55oxr5el.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmp55oxr5el.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp55oxr5el.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp55oxr5el.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp55oxr5el.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp382hkn9d.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..i + 1].sort();\n            array[i + 1..].sort();\n    \
    \        array[i + 1..].reverse();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpw7p1idol.rs:49:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] > array[j] {\n        \
    \    array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpnorhqxkp.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return vec![];\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if array[i] % 2 == 0 && array[j] % 2 == 1 {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        } else if array[i] %\
    \ 2 == 1 && array[j] % 2 == 1 {\n            i += 1;\n        } else if array[i]\
    \ % 2 == 0 && array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n   \
    \         i += 1;\n            j -= 1;\n        }\n    }\n    if len % 2 == 0\
    \ {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp6gidkhji.rs:52:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let first = array[0];\n        let last = array[array.len() - 1];\n     \
    \   if (first + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mid = array.len() / 2;\n        let (left, right) = array.split_at_mut(mid);\n\
    \        let left = sort_array(left.to_vec());\n        let right = sort_array(right.to_vec());\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 4, 3, 2, 5, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmphqasa8vx.rs:56:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqrm8b1ba.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjt0c4rpx.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut array = array;\n    let (mut i, mut j) = (0, array.len() - 1);\n \
    \   while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpqgcd2v_0.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp77ozhh1a.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < left.len()\
    \ && j < right.len() {\n            if (left[i] + right[j]) % 2 == 0 {\n     \
    \           array[i + j] = left[i];\n                i += 1;\n            } else\
    \ {\n                array[i + j] = right[j];\n                j += 1;\n     \
    \       }\n        }\n        while i < left.len() {\n            array[i + j]\
    \ = left[i];\n            i += 1;\n        }\n        while j < right.len() {\n\
    \            array[i + j] = right[j];\n            j += 1;\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpix3_ehoc.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpix3_ehoc.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpix3_ehoc.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpix3_ehoc.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpix3_ehoc.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            array.swap(i, j);\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptsxhamln.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut tmp;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            tmp = array[i];\n            array[i] =\
    \ array[j];\n            array[j] = tmp;\n        }\n        i += 1;\n       \
    \ j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd82geet7.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let sum = array[0] + array[array.len() - 1];\n        if sum % 2 == 0 {\n\
    \            array.sort_by(|a, b| b.cmp(a));\n        } else {\n            array.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                j -= 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n        if array[i] %\
    \ 2 == 0 {\n            array[i..].sort();\n        } else {\n            array[..i].sort();\n\
    \            array[..i].reverse();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3vamja74.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array.sort_by(|a, b| {\n       \
    \ if is_odd {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpf5k58h_p.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..=i].sort();\n            array[..=i].reverse();\n       \
    \ }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpayvrbiwq.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpeu7ysuhi.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpsrwwxfu1.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpovupl_5t.rs:20:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut array = array;\n    let (mut i, mut j) = (0, array.len() - 1);\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpfb2q54ky.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmph_8yghme.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp80l9ddui.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmp80l9ddui.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp80l9ddui.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp80l9ddui.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp80l9ddui.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut index = 0;\n    let\
    \ mut last_index = array.len() - 1;\n    while index < last_index {\n        if\
    \ array[index] % 2 == 0 && array[last_index] % 2 == 0 {\n            index +=\
    \ 1;\n        } else if array[index] % 2 == 1 && array[last_index] % 2 == 1 {\n\
    \            last_index -= 1;\n        } else if array[index] % 2 == 0 && array[last_index]\
    \ % 2 == 1 {\n            array.swap(index, last_index);\n            index +=\
    \ 1;\n            last_index -= 1;\n        } else {\n            if index + last_index\
    \ % 2 == 0 {\n                array.swap(index, last_index);\n            }\n\
    \            index += 1;\n            last_index -= 1;\n        }\n    }\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_h8yw7kh.rs:18:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    if (array[0] + array[len - 1]) % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfj35kzq5.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjhoqy93l.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8e6kiulw.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9fqpzuep.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpr94h0yxu.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpa5zok1qz.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3o4zyd2x.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpgq_b80wq.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcom65x4n.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxomii_0s.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp2bjr2zph.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp2z12qmq5.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7f_rp0_q.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if array[i]\
    \ % 2 == 1 && array[j] % 2 == 0 {\n            array.swap(i, j);\n           \
    \ i += 1;\n            j -= 1;\n        } else if array[i] % 2 == 0 {\n      \
    \      j -= 1;\n        } else if array[j] % 2 == 1 {\n            i += 1;\n \
    \       } else {\n            i += 1;\n            j -= 1;\n        }\n    }\n\
    \    if len % 2 == 1 {\n        array[i..].sort();\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array[i..].sort_by(|a, b| b.cmp(a));\n\
    \        array[..i].sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpr29jgkrr.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmppn4lrcae.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpa9w9gw28.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpa9w9gw28.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpa9w9gw28.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpa9w9gw28.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpa9w9gw28.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        let mut i = 0;\n        let mut j = result.len() - 1;\n       \
    \ while i < j {\n            if result[i] % 2 == 0 && result[j] % 2 == 1 {\n \
    \               result.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            } else if result[i] % 2 == 1 && result[j] % 2 == 0 {\n  \
    \              i += 1;\n                j -= 1;\n            } else if result[i]\
    \ % 2 == 1 && result[j] % 2 == 1 {\n                i += 1;\n            } else\
    \ {\n                j -= 1;\n            }\n        }\n        if result.len()\
    \ % 2 == 1 {\n            result[i..].sort();\n        } else {\n            result[i..].sort_by(|a,\
    \ b| b.cmp(a));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmph5wmygzh.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp88ll5tyx.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \      array.sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpx51n4thr.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n            j\
    \ -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n        }\
    \ else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if len\
    \ % 2 == 0 {\n        array[..i].sort();\n        array[i..].sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array[..i].sort_by(|a, b| b.cmp(a));\n        array[i..].sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 5, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_xz0i0my.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array.sort_by(|a, b| {\n       \
    \ if is_odd {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprlfsk2j0.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut start, mut end) = (0, array.len() - 1);\n        while start < end\
    \ {\n            while start < end && (start + end) % 2 == 1 {\n             \
    \   start += 1;\n            }\n            while start < end && (start + end)\
    \ % 2 == 0 {\n                end -= 1;\n            }\n            array.swap(start,\
    \ end);\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpvb9bpqim.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3kzsibqb.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkvotnned.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4yhyhmyg.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp2t9aze7k.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu2g318vq.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpl42st45e.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmph2wt73ck.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (1, array.len() - 2);\n        while left <= right {\n  \
    \          if (first + last) % 2 == 0 {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] < array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmps_h14u1a.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg6mqk_ps.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if array.len() > 1\
    \ {\n        if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            result.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            result.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptvh8hu51.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0dpbx82d.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..=i].sort();\n            array[..=i].reverse();\n       \
    \ }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_lj9y8bt.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, i + 1);\n   \
    \     }\n        let mut i = 0;\n        let mut j = array.len() - 1;\n      \
    \  while i < j {\n            if array[i] % 2 == 1 && array[j] % 2 == 0 {\n  \
    \              array.swap(i, j);\n                i += 1;\n                j -=\
    \ 1;\n            } else if array[i] % 2 == 0 {\n                i += 1;\n   \
    \         } else if array[j] % 2 == 1 {\n                j -= 1;\n           \
    \ } else {\n                i += 1;\n                j -= 1;\n            }\n\
    \        }\n        if i == j && array[i] % 2 == 1 {\n            array.swap(i,\
    \ i + 1);\n        }\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 1 && array[j] %\
    \ 2 == 1 {\n                if array[i] > array[j] {\n                    array.swap(i,\
    \ j);\n                }\n                i += 1;\n                j -= 1;\n \
    \           } else if array[i] % 2 == 0 {\n                i += 1;\n         \
    \   } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else\
    \ {\n                i += 1;\n                j -= 1;\n            }\n       \
    \ }\n        if i == j && array[\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprfnum9th.rs:86:3\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                                     - unclosed delimiter\n16 |     let mut array\
    \ = array;\n17 |     if array.len() > 1 {\n   |                        - this\
    \ delimiter might not be properly closed...\n...\n75 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n86 | }\n   |   ^\n\nerror: expected\
    \ expression, found `]`\n  --> /tmp/tmprfnum9th.rs:75:1\n   |\n75 | }\n   | ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmprfnum9th.rs:74:27\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                                     - closing delimiter possibly meant for this\n\
    ...\n74 |         if i == j && array[\n   |                           ^ unclosed\
    \ delimiter\n75 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprfnum9th.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4jdbo_hg.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut temp = Vec::with_capacity(array.len());\n        let (mut i,\
    \ mut j) = (0, 0);\n        while i < left.len() && j < right.len() {\n      \
    \      if left[i] < right[j] {\n                temp.push(left[i]);\n        \
    \        i += 1;\n            } else {\n                temp.push(right[j]);\n\
    \                j += 1;\n            }\n        }\n        if i < left.len()\
    \ {\n            temp.extend_from_slice(&left[i..]);\n        }\n        if j\
    \ < right.len() {\n            temp.extend_from_slice(&right[j..]);\n        }\n\
    \        array = temp;\n    }\n    if array.len() > 1 && (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp7wmfewyc.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmp7wmfewyc.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp7wmfewyc.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp7wmfewyc.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp7wmfewyc.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let is_odd = (array[0] + array[len\
    \ - 1]) % 2 == 1;\n    if is_odd {\n        array.sort();\n    } else {\n    \
    \    array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3ov9jbrp.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpvl1aq_dz.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd1lo7c01.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpi8rfgtb7.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpi8rfgtb7.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpi8rfgtb7.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpi8rfgtb7.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpi8rfgtb7.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut array = array;\n    let (mut i, mut j) = (0, array.len() - 1);\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmphjit2f0d.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 0 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3pj55u26.rs:20:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt0vk9obr.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpqyxsrrq_.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut start = 0;\n    let\
    \ mut end = array.len() - 1;\n    while start < end {\n        if array[start]\
    \ % 2 == 0 && array[end] % 2 == 1 {\n            array.swap(start, end);\n   \
    \         start += 1;\n            end -= 1;\n        } else if array[start] %\
    \ 2 == 1 {\n            start += 1;\n        } else if array[end] % 2 == 0 {\n\
    \            end -= 1;\n        } else {\n            start += 1;\n          \
    \  end -= 1;\n        }\n    }\n    if array.len() % 2 == 0 {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphp09qyva.rs:18:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array.sort_by(|a, b| {\n       \
    \ if is_odd {\n            a.cmp(b)\n        } else {\n            b.cmp(a)\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyclcqmp9.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp1ktzyx2d.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpna1rtl0s.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpmwyn783m.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpmwyn783m.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpmwyn783m.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpmwyn783m.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpmwyn783m.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmps36dj8aq.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpc5ukrjee.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpuv8ytz6j.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbngondf0.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  let mut i = 0;\n    let mut j = len - 1;\n    let mut sorted = false;\n   \
    \ while !sorted {\n        sorted = true;\n        while i < j {\n           \
    \ if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n      \
    \          sorted = false;\n            }\n            i += 1;\n        }\n  \
    \      j -= 1;\n        while i > j {\n            if array[i] < array[i - 1]\
    \ {\n                array.swap(i, i - 1);\n                sorted = false;\n\
    \            }\n            i -= 1;\n        }\n        j += 1;\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppkt0rf2v.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpgiqhb8ny.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        i = 0;\n        while\
    \ i < j {\n            if array[j - 1] > array[j] {\n                array.swap(j\
    \ - 1, j);\n                sorted = false;\n            }\n            j -= 1;\n\
    \        }\n        j = array.len() - 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmt9qo599.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpho1v7oyg.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, i + 1);\n   \
    \     }\n        if array[0] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort();\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp7w5tvy10.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < left.len()\
    \ && j < right.len() {\n            if left[i] < right[j] {\n                array[i\
    \ + j] = left[i];\n                i += 1;\n            } else {\n           \
    \     array[i + j] = right[j];\n                j += 1;\n            }\n     \
    \   }\n        while i < left.len() {\n            array[i + j] = left[i];\n \
    \           i += 1;\n        }\n        while j < right.len() {\n            array[i\
    \ + j] = right[j];\n            j += 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmplcw3u7oy.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmplcw3u7oy.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmplcw3u7oy.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmplcw3u7oy.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmplcw3u7oy.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array[i..].sort();\n        } else {\n\
    \            array[..=i].sort();\n            array[..=i].reverse();\n       \
    \ }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp67xjkt89.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpy66_h7v3.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpg0posqs4.rs:17:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj5brafus.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] > array[j] {\n        \
    \    array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpmj7qmno0.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwions9tt.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ i == j && array[i] % 2 == 0 {\n        array.swap(i, j);\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyrrekx_j.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() < 2 {\n    \
    \    return array;\n    }\n    let (mut i, mut j) = (0, array.len() - 1);\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpry0y3gkr.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbxy4pxci.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if\
    \ array.len() % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwoaczav6.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut odd_index = 0;\n  \
    \  let mut even_index = array.len() - 1;\n    let mut odd_array = Vec::new();\n\
    \    let mut even_array = Vec::new();\n    for i in 0..array.len() {\n       \
    \ if i % 2 == 0 {\n            odd_array.push(array[i]);\n        } else {\n \
    \           even_array.push(array[i]);\n        }\n    }\n    odd_array.sort();\n\
    \    even_array.sort();\n    even_array.reverse();\n    for i in 0..array.len()\
    \ {\n        if i % 2 == 0 {\n            array[i] = odd_array[odd_index];\n \
    \           odd_index += 1;\n        } else {\n            array[i] = even_array[even_index];\n\
    \            even_index -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpuy2fbykq.rs:18:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpol3m_n_m.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpp2_d4c8_.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpp2_d4c8_.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpp2_d4c8_.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpp2_d4c8_.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpp2_d4c8_.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len <= 1 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n            j\
    \ -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n        }\
    \ else if array[j] % 2 == 0 {\n            j -= 1;\n        }\n    }\n    if len\
    \ % 2 == 0 {\n        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n   \
    \     array[i..].sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp0xarzpzp.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_73f8eb0.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwmurtgzo.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 1 {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0pla4rku.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
