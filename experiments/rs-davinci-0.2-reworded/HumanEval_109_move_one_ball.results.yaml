name: HumanEval_109_move_one_ball
language: rs
results:
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbtm_66jk.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i - 1] > arr[i] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = tmp;\n           \
    \ i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplmhygyxu.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkuaoa0_w.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    if arr.len()\
    \ == 0 {\n        return true;\n    }\n    let mut i = 0;\n    let mut j = arr.len()\
    \ - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n            return false;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp72w8c8rw.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpalexpxa1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmtajbkp2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptdgjjed4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp31aw9hna.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min {\n    \
    \        return false;\n        }\n        min = arr[i];\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpslec3gix.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1p5dnuvk.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx6v66z6i.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp26ga6p2r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc8l0c3r2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() - 1 && arr[j] > arr[j + 1] {\n                j +=\
    \ 1;\n            }\n            i = j;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ezgrj1v.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    let mut count = 0;\n    for i in 0..arr.len() {\n   \
    \     if arr[i] != sorted[i] {\n            count += 1;\n        }\n    }\n  \
    \  if count > 1 {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5s4nzcly.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i] < arr[i - 1] {\n            break;\n   \
    \     }\n        i -= 1;\n    }\n    if i == 0 {\n        return true;\n    }\n\
    \    let mut j = i - 1;\n    while j > 0 {\n        if arr[j] > arr[j - 1] {\n\
    \            break;\n        }\n        j -= 1;\n    }\n    if j == 0 {\n    \
    \    return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8v4r1u3y.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n   \
    \ while k < arr.len() {\n        if arr[i] > arr[j] && arr[j] > arr[k] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            i = j;\n            j = k;\n            k += 1;\n\
    \        } else {\n            i = j;\n            j = k;\n            k += 1;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpguf7f03l.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdl_0hc3l.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprpc_f28f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphsozxd_s.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi29o03zk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqaq_0pue.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7qt7l9zu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplqt_qau2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt90td3yg.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut n = arr.len();\n\
    \    while i < n - 1 {\n        if arr[i] > arr[i + 1] {\n            j = i +\
    \ 1;\n            while j < n && arr[j] < arr[i] {\n                j += 1;\n\
    \            }\n            if j == n {\n                return false;\n     \
    \       }\n            k = j;\n            while k > i {\n                arr.swap(k,\
    \ k - 1);\n                k -= 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyhkg7_cc.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprd1gzpmi.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    let mut min_index = 0;\n    for i in 1..arr.len() {\n   \
    \     if arr[i] < min {\n            min = arr[i];\n            min_index = i;\n\
    \        }\n    }\n    if min_index == 0 {\n        return true;\n    }\n    let\
    \ mut i = min_index;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          return false;\n        }\n        i -= 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcfxyhbi0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp97moxfux.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4bl3j8ek.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          break;\n        }\n        i -= 1;\n    }\n    if i == 0 {\n      \
    \  return true;\n    }\n    let mut j = i - 1;\n    while j > 0 {\n        if\
    \ arr[j] < arr[j - 1] {\n            return false;\n        }\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp39hzf7lt.rs:24:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6_6r7zq9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] == i as isize + 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count == arr.len() {\n        return true;\n\
    \    }\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] == i\
    \ as isize + 1 {\n            i += 1;\n        } else {\n            let temp\
    \ = arr[i];\n            arr[i] = arr[temp as usize - 1];\n            arr[temp\
    \ as usize - 1] = temp;\n        }\n    }\n    let mut count = 0;\n    for i in\
    \ 0..arr.len() {\n        if arr[i] == i as isize + 1 {\n            count +=\
    \ 1;\n        }\n    }\n    if count == arr.len() {\n        return true;\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 9', /tmp/tmpbe047yw5.rs:42:22\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplsq_zhig.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9jqc0zdd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut min_idx = 0;\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < arr[min_idx] {\n            min_idx = i;\n\
    \        }\n    }\n    let mut min_val = arr[min_idx];\n    for i in 0..arr.len()\
    \ {\n        if i == min_idx {\n            continue;\n        }\n        if arr[i]\
    \ < min_val {\n            return false;\n        }\n        min_val = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6xm51ovx.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() {\n        if arr[i] > arr[j]\
    \ {\n            count += 1;\n            if count > 1 {\n                flag\
    \ = true;\n                break;\n            }\n            if arr[j] > arr[k]\
    \ {\n                flag = true;\n                break;\n            }\n   \
    \     }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    if flag\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpcw1nszu4.rs:30:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7blfhhfe.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ let mut i = 1;\n    while i < arr.len() {\n        if arr[i] < min {\n     \
    \       min = arr[i];\n        }\n        i += 1;\n    }\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        if arr[i] == min {\n            break;\n \
    \       }\n        i += 1;\n    }\n    let mut j = i + 1;\n    while j < arr.len()\
    \ {\n        if arr[j] < arr[j - 1] {\n            return false;\n        }\n\
    \        j += 1;\n    }\n    let mut j = i - 1;\n    while j >= 0 {\n        if\
    \ arr[j] < arr[j + 1] {\n            return false;\n        }\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjsmmp3bv.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplfy3gk5r.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnn028xkw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] == i as isize + 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count == arr.len() {\n        return true;\n\
    \    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n        if arr[i]\
    \ > max {\n            max = arr[i];\n        }\n    }\n    if max == arr.len()\
    \ as isize {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwfo0b_5i.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy2amjdk5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    if min_index == 0 {\n        return true;\n    }\n    let\
    \ mut max = arr[0];\n    for i in 1..min_index {\n        if arr[i] > max {\n\
    \            max = arr[i];\n        }\n    }\n    if max > min {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzdb10_vr.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvyzwh67e.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppdl1r8ci.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    while count < arr.len() {\n        let mut i = arr.len() - 1;\n\
    \        while i > 0 {\n            if arr[i] < arr[i - 1] {\n               \
    \ arr.swap(i, i - 1);\n                count += 1;\n            }\n          \
    \  i -= 1;\n        }\n    }\n    arr == arr.iter().sorted().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp6c2osu57.rs:35:23\n   |\n35 |     arr ==\
    \ arr.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i += 1;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm7_88wrn.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpchr3et2x.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph7au5f4q.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5qnceq7k.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph4lkhuoa.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzgp26kkn.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppms249f0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq0n4qand.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptgjvjnj0.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ while k < arr.len() {\n        if arr[i] < arr[j] && arr[j] < arr[k] {\n   \
    \         i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] > arr[j] && arr[j] > arr[k] {\n            i += 1;\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] < arr[j] && arr[j] > arr[k]\
    \ {\n            arr.swap(j, k);\n            count += 1;\n            if count\
    \ > 1 {\n                return false;\n            }\n            i += 1;\n \
    \           j += 1;\n            k += 1;\n        } else if arr[i] > arr[j] &&\
    \ arr[j] < arr[k] {\n            arr.swap(j, k);\n            count += 1;\n  \
    \          if count > 1 {\n                return false;\n            }\n    \
    \        i += 1;\n            j += 1;\n            k += 1;\n        } else if\
    \ arr[i] == arr[j] && arr[j] < arr[k] {\n            i += 1;\n            j +=\
    \ 1;\n            k += 1;\n        } else if arr[i] == arr[j] && arr[j] > arr[k]\
    \ {\n            arr.swap(j, k);\n            count += 1;\n            if count\
    \ > 1 {\n                return false;\n            }\n            i += 1;\n \
    \           j += 1;\n            k += 1;\n        } else if arr[i] < arr[j] &&\
    \ arr[j] == arr[k] {\n            i += 1;\n            j += 1;\n            k\
    \ += 1;\n        } else if arr[i] > arr[j] && arr[j] == arr[k] {\n           \
    \ arr.swap(j, k);\n            count += 1;\n            if count > 1 {\n     \
    \           return false;\n            }\n            i += 1;\n            j +=\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplu4vi6pd.rs:89:3\n\
    \   |\n22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |                \
    \                           - unclosed delimiter\n...\n28 |     while k < arr.len()\
    \ {\n   |                         - unclosed delimiter\n...\n72 |         } else\
    \ if arr[i] > arr[j] && arr[j] == arr[k] {\n   |                             \
    \                          - this delimiter might not be properly closed...\n\
    ...\n80 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    89 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmplu4vi6pd.rs:80:1\n\
    \   |\n80 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplu4vi6pd.rs:28:5\n   |\n22 |   fn move_one_ball(arr: Vec<isize>)\
    \ -> bool {\n   |                                        ---- expected `bool`\
    \ because of return type\n...\n28 | /     while k < arr.len() {\n29 | |      \
    \   if arr[i] < arr[j] && arr[j] < arr[k] {\n30 | |             i += 1;\n31 |\
    \ |             j += 1;\n...  |\n88 | |     assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n89 | | }\n   | |__^ expected `bool`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp269t6o50.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4y66ctxq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min_val = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] < min_val {\n            min_val\
    \ = arr[i];\n        }\n        if arr[i] < arr[i - 1] {\n            return false;\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min_val {\n            min_index = i;\n            break;\n\
    \        }\n    }\n    if min_index == 0 {\n        return true;\n    }\n    for\
    \ i in 0..min_index {\n        if arr[i] < min_val {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi24biauo.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        if arr[i] > min {\n            min = arr[i];\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5lovd4d_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < max_val {\n            return false;\n        }\n   \
    \     max_val = max(max_val, arr[i]);\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpaqj4g3dc.rs:31:19\n\
    \   |\n31 |         max_val = max(max_val, arr[i]);\n   |                   ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbkzoqb1t.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi__uixjp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcf0sx1wq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps69m1nrn.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp46mh67i4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuf4za9yt.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzfps2nk1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpie8kfrml.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6jmml2eh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt8qryan6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnzqbyk7o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9gc4ko6n.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpryb8ynhu.rs:22:38\n   |\n\
    22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut max_val = arr[0];\n\
    \    let mut max_index = 0;\n    let mut min_val = arr[0];\n    let mut min_index\
    \ = 0;\n    for i in 1..arr.len() {\n        if arr[i] > max_val {\n         \
    \   max_val = arr[i];\n            max_index = i;\n        }\n        if arr[i]\
    \ < min_val {\n            min_val = arr[i];\n            min_index = i;\n   \
    \     }\n    }\n    if max_index == arr.len() - 1 {\n        return true;\n  \
    \  }\n    if max_index == 0 {\n        return false;\n    }\n    if min_index\
    \ == 0 {\n        return true;\n    }\n    if min_index == arr.len() - 1 {\n \
    \       return false;\n    }\n    if min_index < max_index {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5jm74air.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut n = arr.len();\n    while i < n {\n\
    \        if arr[i] == i as isize + 1 {\n            i += 1;\n        } else {\n\
    \            j = arr[i] as usize - 1;\n            if arr[j] == j as isize + 1\
    \ {\n                i += 1;\n            } else {\n                arr.swap(i,\
    \ j);\n            }\n        }\n    }\n    for i in 0..n {\n        if arr[i]\
    \ != i as isize + 1 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 9', /tmp/tmpwbso3bor.rs:32:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpclnr0ssg.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut n = arr.len();\n    while i < n {\n        if j == 0 ||\
    \ arr[i] >= arr[j - 1] {\n            arr[j] = arr[i];\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    j == n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqqki5do1.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi15svjlb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzfhrnley.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj3l0uztv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu9hgbgnj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgk48t2b8.rs:22:38\n   |\n\
    22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i] < arr[i - 1] {\n            break;\n   \
    \     }\n        i -= 1;\n    }\n    if i == 0 {\n        return true;\n    }\n\
    \    let mut j = i;\n    while j < arr.len() {\n        if arr[j] < arr[i - 1]\
    \ {\n            break;\n        }\n        j += 1;\n    }\n    if j == arr.len()\
    \ {\n        return false;\n    }\n    let mut k = j;\n    while k > i {\n   \
    \     arr.swap(k, k - 1);\n        k -= 1;\n    }\n    for i in 1..arr.len() {\n\
    \        if arr[i] < arr[i - 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgh7g94w8.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7yaotkhd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa7gtxbx2.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 0..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4t6hc5j.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9oy6z7x7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = std::isize::MAX;\n    for i in 0..arr.len() {\n        if arr[i] < min\
    \ {\n            min = arr[i];\n        }\n        if arr[i] > min {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuy12ze30.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8u8g0ke_.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i - 1] > arr[i] {\n            let temp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = temp;\n          \
    \  i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmwjatrkf.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6if39afr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprt_y0pm_.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkedd1ye2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdt9glivj.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcp9lnpc_.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz2jdkn3t.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i += 1;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if\
    \ arr[i] > arr[i + 1] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr2oyluse.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvu7ywzwn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpewgn6r0r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < min {\n            return false;\n     \
    \   }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8p7h91gk.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < min {\n            return false;\n     \
    \   }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcu7pex2v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i = arr.len() - 1;\n        } else {\n           \
    \ i -= 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo_lirsy9.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpguvrtxa7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgnkwemvf.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ <= arr[j] {\n            i += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwq4e7ayp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7krxtsfc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprxy996fy.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxyu1fuhb.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n   \
    \     if arr[i] > max {\n            max = arr[i];\n        }\n    }\n    let\
    \ mut max_index = 0;\n    for i in 0..arr.len() {\n        if arr[i] == max {\n\
    \            max_index = i;\n            break;\n        }\n    }\n    if min_index\
    \ == 0 && max_index == arr.len() - 1 {\n        return true;\n    }\n    if min_index\
    \ == 0 && max_index < arr.len() - 1 {\n        return false;\n    }\n    if min_index\
    \ > 0 && max_index == arr.len() - 1 {\n        return false;\n    }\n    if min_index\
    \ > 0 && max_index < arr.len() - 1 {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjih476oa.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps36j6se6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptrap3g5u.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < max_val {\n            return false;\n        }\n   \
    \     max_val = max(max_val, arr[i]);\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpx52qzz9x.rs:31:19\n\
    \   |\n31 |         max_val = max(max_val, arr[i]);\n   |                   ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo4kxu3au.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4uv49wkr.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl505ekz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy0f_lr19.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut min_idx = 0;\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < arr[min_idx] {\n            min_idx = i;\n\
    \        }\n    }\n    let mut min_val = arr[min_idx];\n    for i in 0..arr.len()\
    \ {\n        if i == min_idx {\n            continue;\n        }\n        if arr[i]\
    \ < min_val {\n            return false;\n        }\n        min_val = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi6x4l8f1.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp694_3stu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp276fgqc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() && arr[j] < arr[j - 1] {\n                j += 1;\n\
    \            }\n            if j == arr.len() {\n                return false;\n\
    \            }\n            let temp = arr[j];\n            for k in (i..j).rev()\
    \ {\n                arr[k + 1] = arr[k];\n            }\n            arr[i] =\
    \ temp;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpphvwn2xm.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkhn4o3v4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7do6z0jf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5cx49hpj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdzg_s1se.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i] < arr[i - 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = tmp;\n           \
    \ i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl_qeknzr.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgadwj246.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsl4p98gh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i] < arr[i - 1] {\n            break;\n   \
    \     }\n        i -= 1;\n    }\n    if i == 0 {\n        return true;\n    }\n\
    \    let mut j = i - 1;\n    while j > 0 {\n        if arr[j] > arr[j - 1] {\n\
    \            break;\n        }\n        j -= 1;\n    }\n    if j == 0 {\n    \
    \    return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwvt2qx2a.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpei4on785.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9mfhzg7r.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeo4z121r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut i = 0;\n    while !sorted {\n        sorted = true;\n\
    \        for j in 0..arr.len() - 1 {\n            if arr[j] > arr[j + 1] {\n \
    \               sorted = false;\n                let temp = arr[j];\n        \
    \        arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n          \
    \  }\n        }\n        i += 1;\n    }\n    i <= arr.len()\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfhvtam8v.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5g42_8s5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04cbqzqk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdwr3ygby.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpryyh1mjn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiq9b2sc5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < max {\n            return false;\n        }\n        max = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp951toqlu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i - 1] > arr[i] {\n            let temp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = temp;\n          \
    \  i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnwwnocxl.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    let mut min_index = 0;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x < min {\n            min = x;\n            min_index = i;\n\
    \        }\n    }\n    let mut max = arr[0];\n    let mut max_index = 0;\n   \
    \ for (i, &x) in arr.iter().enumerate() {\n        if x > max {\n            max\
    \ = x;\n            max_index = i;\n        }\n    }\n    if min_index == max_index\
    \ {\n        return true;\n    }\n    if min_index > max_index {\n        return\
    \ false;\n    }\n    let mut count = 0;\n    for i in min_index..max_index {\n\
    \        if arr[i] > arr[i + 1] {\n            count += 1;\n        }\n    }\n\
    \    if count > 1 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptw38rfku.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprlvthd19.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkesiglu7.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg83vgp64.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min {\n    \
    \        return false;\n        }\n        min = arr[i];\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsuduj4c7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn_4e84fl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt90kpaaf.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi1fdvib8.rs:26:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() - 1 && arr[j] > arr[j + 1] {\n                j +=\
    \ 1;\n            }\n            i = j;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi_t23diw.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n    for i in\
    \ 1..arr.len() {\n        if arr[i] < min {\n            return false;\n     \
    \   }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxantmhc7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5zkan357.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmperd13xn8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpepvgreod.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min_index = 0;\n  \
    \  let mut min_value = arr[0];\n    for i in 1..arr.len() {\n        if arr[i]\
    \ < min_value {\n            min_index = i;\n            min_value = arr[i];\n\
    \        }\n    }\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i]\
    \ > min_value {\n            break;\n        }\n        i += 1;\n    }\n    if\
    \ i == arr.len() {\n        return true;\n    }\n    let mut j = i;\n    while\
    \ j < arr.len() {\n        if arr[j] < min_value {\n            return false;\n\
    \        }\n        j += 1;\n    }\n    if j == arr.len() {\n        return true;\n\
    \    }\n    let mut k = j;\n    while k < arr.len() {\n        if arr[k] > min_value\
    \ {\n            return false;\n        }\n        k += 1;\n    }\n    if k ==\
    \ arr.len() {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnwzv7nki.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i - 1] > arr[i] {\n            let temp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = temp;\n          \
    \  i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu6inkaf4.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu_25kid8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ let mut min_index = 0;\n    for i in 1..arr.len() {\n        if arr[i] < min\
    \ {\n            min = arr[i];\n            min_index = i;\n        }\n    }\n\
    \    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] == min\
    \ {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return\
    \ false;\n    }\n    if min_index == 0 {\n        return true;\n    }\n    let\
    \ mut i = min_index - 1;\n    while i >= 0 {\n        if arr[i] > min {\n    \
    \        return false;\n        }\n        i -= 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyvultvs4.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i - 1] > arr[i] {\n            let temp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = temp;\n          \
    \  i = arr.len() - 1;\n        } else {\n            i -= 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptw7s6xjo.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7s8ll_34.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpelwq6vc4.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3xvaf42.rs:22:38\n   |\n\
    22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvpuikvws.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpikyx1r9g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph8dk570_.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_7ant1g0.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO: Implement the solution\
    \ here\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2d5rve2l.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprmv_dl5e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzaztvdqp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps87ogi6v.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsbrf7f4e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl5mfwvlp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[j] {\n      \
    \      return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd2inj92d.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    let mut max = arr[0];\n    let mut min_idx = 0;\n    let\
    \ mut max_idx = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x\
    \ < min {\n            min = x;\n            min_idx = i;\n        }\n       \
    \ if x > max {\n            max = x;\n            max_idx = i;\n        }\n  \
    \  }\n    if min_idx == max_idx {\n        return true;\n    }\n    let mut min_idx\
    \ = min_idx;\n    let mut max_idx = max_idx;\n    if min_idx > max_idx {\n   \
    \     std::mem::swap(&mut min_idx, &mut max_idx);\n    }\n    for i in 0..min_idx\
    \ {\n        if arr[i] > min {\n            return false;\n        }\n    }\n\
    \    for i in (min_idx + 1)..max_idx {\n        if arr[i] < max {\n          \
    \  return false;\n        }\n    }\n    for i in (max_idx + 1)..arr.len() {\n\
    \        if arr[i] > max {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5el0i2qi.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = min(min_val, arr[i]);\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpewyp0nii.rs:31:19\n\
    \   |\n31 |         min_val = min(min_val, arr[i]);\n   |                   ^^^\n\
    ...\n36 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n31 |        \
    \ min_val = main(min_val, arr[i]);\n   |                   ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiz0dk_iy.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_index = 0;\n    let mut min_value = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] < min_value {\n            min_index\
    \ = i;\n            min_value = arr[i];\n        }\n    }\n    if min_index ==\
    \ 0 {\n        return true;\n    }\n    let mut max_index = 0;\n    let mut max_value\
    \ = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] > max_value {\n  \
    \          max_index = i;\n            max_value = arr[i];\n        }\n    }\n\
    \    if max_index == 0 {\n        return true;\n    }\n    if max_index > min_index\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8p7b4c55.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp18z9i4a7.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjwwunn4b.rs:26:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            if count == 0 {\n                return true;\n         \
    \   } else {\n                return false;\n            }\n        }\n      \
    \  if arr[i] > arr[i + 1] {\n            count += 1;\n            if count > 1\
    \ {\n                return false;\n            }\n            let temp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n          \
    \  i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt5mvt24p.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw543dr7h.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n   \
    \ while i < arr.len() && j < arr.len() && k < arr.len() {\n        if arr[i] <\
    \ arr[j] && arr[j] < arr[k] {\n            i += 1;\n            j += 1;\n    \
    \        k += 1;\n        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n   \
    \         let temp = arr[j];\n            arr[j] = arr[k];\n            arr[k]\
    \ = temp;\n            count += 1;\n            if count > 1 {\n             \
    \   return false;\n            }\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n\
    \            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j]\
    \ = temp;\n            count += 1;\n            if count > 1 {\n             \
    \   return false;\n            }\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n\
    \            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j]\
    \ = temp;\n            count += 1;\n            if count > 1 {\n             \
    \   return false;\n            }\n            i += 1;\n            j += 1;\n \
    \           k += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeswcwk26.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpluc9526a.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgz79p6_7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpee4r4t7n.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvsn240f3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = isize::max_value();\n    let mut max = isize::min_value();\n    let mut\
    \ min_idx = 0;\n    let mut max_idx = 0;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x < min {\n            min = x;\n            min_idx = i;\n  \
    \      }\n        if x > max {\n            max = x;\n            max_idx = i;\n\
    \        }\n    }\n    if min_idx == 0 {\n        return true;\n    }\n    if\
    \ max_idx == arr.len() - 1 {\n        return true;\n    }\n    if min_idx < max_idx\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2g0fvh0v.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] != sorted_arr[i]\
    \ {\n            count += 1;\n        }\n    }\n    if count == 1 {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppp86l12f.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppv8o7rd1.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = arr.len() - 1;\n\
    \    while i > 0 {\n        if arr[i] < arr[i - 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i - 1];\n            arr[i - 1] = tmp;\n           \
    \ i += 1;\n        } else {\n            i -= 1;\n        }\n    }\n    for i\
    \ in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmp0xhiun7o.rs:29:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp059ureqt.rs:22:38\n   |\n\
    22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n    let mut lll =\
    \ 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n    let mut ooo = 0;\n\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qhn40dx.rs:22:38\n   |\n\
    22 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < max {\n            return false;\n        }\n        max = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp31woehl7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdktwhz9w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc6gypde8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgb9pmo4f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut count = 0;\n   \
    \ let mut flag = false;\n    while i < arr.len() - 2 {\n        if arr[i] < arr[j]\
    \ && arr[j] < arr[k] {\n            i += 1;\n            j += 1;\n           \
    \ k += 1;\n        } else if arr[i] < arr[j] && arr[j] > arr[k] {\n          \
    \  if arr[i] < arr[k] {\n                i += 1;\n                j += 1;\n  \
    \              k += 1;\n            } else {\n                i += 1;\n      \
    \          j += 1;\n                k += 1;\n                count += 1;\n   \
    \         }\n        } else if arr[i] > arr[j] && arr[j] < arr[k] {\n        \
    \    if arr[i] < arr[k] {\n                i += 1;\n                j += 1;\n\
    \                k += 1;\n            } else {\n                i += 1;\n    \
    \            j += 1;\n                k += 1;\n                count += 1;\n \
    \           }\n        } else if arr[i] > arr[j] && arr[j] > arr[k] {\n      \
    \      if arr[i] < arr[k] {\n                i += 1;\n                j += 1;\n\
    \                k += 1;\n            } else {\n                i += 1;\n    \
    \            j += 1;\n                k += 1;\n                count += 1;\n \
    \           }\n        }\n        if count > 1 {\n            flag = false;\n\
    \            break;\n        } else {\n            flag = true;\n        }\n \
    \   }\n    flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0zqss284.rs:80:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut j = 1;\n\
    \    let mut k = 2;\n    while k < arr.len() {\n        if arr[i] > arr[j] &&\
    \ arr[j] > arr[k] {\n            return false;\n        }\n        i += 1;\n \
    \       j += 1;\n        k += 1;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp5zgltr8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the vector will be randomly ordered. Your task is to determine\
    \ if\n/// it is possible to get a vector sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given vector:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the vector by one\n/// position in the right direction.\
    \ The last element of the vector will be moved to\n/// the starting position in\
    \ the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector\
    \ by performing the above operation\n/// then return true else return false.\n\
    /// If the given vector is empty then return true.\n/// Note: The given vector\
    \ is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3,\
    \ 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3,\
    \ 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// vector by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkzbq9861.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
