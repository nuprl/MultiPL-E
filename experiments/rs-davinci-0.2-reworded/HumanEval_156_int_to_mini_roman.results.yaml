name: HumanEval_156_int_to_mini_roman
language: rs
results:
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman_digit = String::new();\n        if digit == 9 {\n     \
    \       roman_digit.push_str(&ROMAN_DIGITS[i + 1]);\n            roman_digit.push_str(&ROMAN_DIGITS[i]);\n\
    \        } else if digit == 4 {\n            roman_digit.push_str(&ROMAN_DIGITS[i]);\n\
    \            roman_digit.push_str(&ROMAN_DIGITS[i + 1]);\n        } else {\n \
    \           if digit >= 5 {\n                roman_digit.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n                digit -= 5;\n            }\n            for _ in 0..digit\
    \ {\n                roman_digit.push_str(&ROMAN_DIGITS[i]);\n            }\n\
    \        }\n        result = roman_digit + &result;\n        i += 2;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:20:35\n\
    \   |\n20 |             roman_digit.push_str(&ROMAN_DIGITS[i + 1]);\n   |    \
    \                               ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:21:35\n\
    \   |\n21 |             roman_digit.push_str(&ROMAN_DIGITS[i]);\n   |        \
    \                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:23:35\n\
    \   |\n23 |             roman_digit.push_str(&ROMAN_DIGITS[i]);\n   |        \
    \                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:24:35\n\
    \   |\n24 |             roman_digit.push_str(&ROMAN_DIGITS[i + 1]);\n   |    \
    \                               ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:27:39\n\
    \   |\n27 |                 roman_digit.push_str(&ROMAN_DIGITS[i + 1]);\n   |\
    \                                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpkk4x03u2.rs:31:39\n\
    \   |\n31 |                 roman_digit.push_str(&ROMAN_DIGITS[i]);\n   |    \
    \                                   ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ digits = 0;\n    while number > 0 {\n        let digit = number % 10;\n    \
    \    number /= 10;\n        digits += 1;\n        result = mini_roman_digit(digit,\
    \ digits) + &result;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmplpbbwp7a.rs:19:18\n   |\n19 |         result = mini_roman_digit(digit,\
    \ digits) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpyslcn9sd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmph80f52au.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let symbols\
    \ = vec![\n        (1000, 'm'),\n        (900, 'c'),\n        (500, 'd'),\n  \
    \      (400, 'c'),\n        (100, 'c'),\n        (90, 'x'),\n        (50, 'l'),\n\
    \        (40, 'x'),\n        (10, 'x'),\n        (9, 'i'),\n        (5, 'v'),\n\
    \        (4, 'i'),\n        (1, 'i'),\n    ];\n    for (value, symbol) in symbols\
    \ {\n        while num >= value {\n            result.push(symbol);\n        \
    \    num -= value;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xi\"`,\n right: `\"xix\"`', /tmp/tmpvb7r6_tv.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman = String::new();\n        if digit == 9 {\n           \
    \ roman.push_str(&ROMAN_DIGITS[i + 1]);\n            roman.push_str(&ROMAN_DIGITS[i]);\n\
    \        } else if digit >= 5 {\n            roman.push_str(&ROMAN_DIGITS[i]);\n\
    \            for _ in 0..digit - 5 {\n                roman.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n            }\n        } else if digit == 4 {\n            roman.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n            roman.push_str(&ROMAN_DIGITS[i]);\n        } else {\n  \
    \          for _ in 0..digit {\n                roman.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n            }\n        }\n        result = roman + &result;\n      \
    \  i += 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:20:29\n\
    \   |\n20 |             roman.push_str(&ROMAN_DIGITS[i + 1]);\n   |          \
    \                   ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:21:29\n \
    \  |\n21 |             roman.push_str(&ROMAN_DIGITS[i]);\n   |               \
    \              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:23:29\n   |\n\
    23 |             roman.push_str(&ROMAN_DIGITS[i]);\n   |                     \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:25:33\n   |\n25 |  \
    \               roman.push_str(&ROMAN_DIGITS[i + 1]);\n   |                  \
    \               ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:28:29\n   |\n\
    28 |             roman.push_str(&ROMAN_DIGITS[i + 1]);\n   |                 \
    \            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:29:29\n   |\n\
    29 |             roman.push_str(&ROMAN_DIGITS[i]);\n   |                     \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp_zsrdw38.rs:32:33\n   |\n32 |  \
    \               roman.push_str(&ROMAN_DIGITS[i + 1]);\n   |                  \
    \               ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 7 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpg1uh_7dd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        if digit == 0 {\n            i += 1;\n            continue;\n       \
    \ }\n        let (ones, fives, tens) = match i {\n            0 => ('i', 'v',\
    \ 'x'),\n            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n\
    \            3 => ('m', 'v', 'x'),\n            _ => panic!(\"Number too large\"\
    ),\n        };\n        if digit == 9 {\n            result.push(ones);\n    \
    \        result.push(tens);\n        } else if digit == 4 {\n            result.push(ones);\n\
    \            result.push(fives);\n        } else if digit >= 5 {\n           \
    \ result.push(fives);\n            for _ in 0..(digit - 5) {\n               \
    \ result.push(ones);\n            }\n        } else {\n            for _ in 0..digit\
    \ {\n                result.push(ones);\n            }\n        }\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ixx\"`,\n right: `\"xix\"`', /tmp/tmp54r6usdq.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in roman_numerals {\n        while number >= *value\
    \ {\n            result.push_str(numeral);\n            number -= *value;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp3v6vor14.rs:30:25\n\
    \   |\n30 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp3v6vor14.rs:32:23\n\
    \   |\n32 |             number -= *value;\n   |                       ^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp5vsabgiq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpwhobcpd2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n   \
    \     (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n        (\"\
    xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n\
    \        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"\
    i\", 1),\n    ];\n    while number > 0 {\n        for (numeral, value) in roman_numerals.iter()\
    \ {\n            if number >= *value {\n                result.push_str(numeral);\n\
    \                number -= *value;\n                break;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        if digit == 0 {\n            i += 1;\n            continue;\n       \
    \ }\n        let mut roman = String::new();\n        match i {\n            0\
    \ => {\n                if digit <= 3 {\n                    for _ in 0..digit\
    \ {\n                        roman.push('i');\n                    }\n       \
    \         } else if digit == 4 {\n                    roman.push_str(\"iv\");\n\
    \                } else if digit <= 8 {\n                    roman.push('v');\n\
    \                    for _ in 0..digit - 5 {\n                        roman.push('i');\n\
    \                    }\n                } else {\n                    roman.push_str(\"\
    ix\");\n                }\n            }\n            1 => {\n               \
    \ if digit <= 3 {\n                    for _ in 0..digit {\n                 \
    \       roman.push('x');\n                    }\n                } else if digit\
    \ == 4 {\n                    roman.push_str(\"xl\");\n                } else\
    \ if digit <= 8 {\n                    roman.push('l');\n                    for\
    \ _ in 0..digit - 5 {\n                        roman.push('x');\n            \
    \        }\n                } else {\n                    roman.push_str(\"xc\"\
    );\n                }\n            }\n            2 => {\n                if digit\
    \ <= 3 {\n                    for _ in 0..digit {\n                        roman.push('c');\n\
    \                    }\n                } else if digit == 4 {\n             \
    \       roman.push_str(\"cd\");\n                } else if digit <= 8 {\n    \
    \                roman.push('d');\n                    for _ in 0..digit - 5 {\n\
    \                        roman.push('c');\n                    }\n           \
    \     } else {\n                    roman.push_str(\"cm\");\n                }\n\
    \            }\n            3 => {\n                for _ in 0..digit {\n    \
    \                roman.push('m');\n                }\n            }\n        \
    \    _ => {}\n        }\n        result = roman + &result;\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpggp0mhme.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman = String::new();\n        if digit == 4 {\n           \
    \ roman.push(ROMAN_DIGITS[i][0]);\n            roman.push(ROMAN_DIGITS[i][1]);\n\
    \        } else if digit == 9 {\n            roman.push(ROMAN_DIGITS[i][0]);\n\
    \            roman.push(ROMAN_DIGITS[i][2]);\n        } else {\n            if\
    \ digit >= 5 {\n                roman.push(ROMAN_DIGITS[i][1]);\n            \
    \    digit -= 5;\n            }\n            for _ in 0..digit {\n           \
    \     roman.push(ROMAN_DIGITS[i][0]);\n            }\n        }\n        result\
    \ = roman + &result;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp1ogd9iz_.rs:20:24\n\
    \   |\n20 |             roman.push(ROMAN_DIGITS[i][0]);\n   |                \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp1ogd9iz_.rs:21:24\n   |\n21 |  \
    \           roman.push(ROMAN_DIGITS[i][1]);\n   |                        ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS` in\
    \ this scope\n  --> /tmp/tmp1ogd9iz_.rs:23:24\n   |\n23 |             roman.push(ROMAN_DIGITS[i][0]);\n\
    \   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp1ogd9iz_.rs:24:24\n\
    \   |\n24 |             roman.push(ROMAN_DIGITS[i][2]);\n   |                \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp1ogd9iz_.rs:27:28\n   |\n27 |  \
    \               roman.push(ROMAN_DIGITS[i][1]);\n   |                        \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS`\
    \ in this scope\n  --> /tmp/tmp1ogd9iz_.rs:31:28\n   |\n31 |                 roman.push(ROMAN_DIGITS[i][0]);\n\
    \   |                            ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let mut digit = num % 10;\n        num /=\
    \ 10;\n        if digit == 9 {\n            result.push_str(&ROMAN_DIGITS[i +\
    \ 1]);\n            result.push_str(&ROMAN_DIGITS[i]);\n        } else if digit\
    \ >= 5 {\n            result.push_str(&ROMAN_DIGITS[i]);\n            digit -=\
    \ 5;\n            while digit > 0 {\n                result.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n                digit -= 1;\n            }\n        } else if digit\
    \ == 4 {\n            result.push_str(&ROMAN_DIGITS[i + 1]);\n            result.push_str(&ROMAN_DIGITS[i]);\n\
    \        } else {\n            while digit > 0 {\n                result.push_str(&ROMAN_DIGITS[i\
    \ + 1]);\n                digit -= 1;\n            }\n        }\n        i +=\
    \ 2;\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:19:30\n\
    \   |\n19 |             result.push_str(&ROMAN_DIGITS[i + 1]);\n   |         \
    \                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:20:30\n \
    \  |\n20 |             result.push_str(&ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:22:30\n \
    \  |\n22 |             result.push_str(&ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:25:34\n \
    \  |\n25 |                 result.push_str(&ROMAN_DIGITS[i + 1]);\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:29:30\n\
    \   |\n29 |             result.push_str(&ROMAN_DIGITS[i + 1]);\n   |         \
    \                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:30:30\n \
    \  |\n30 |             result.push_str(&ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp8fya7v6_.rs:33:34\n \
    \  |\n33 |                 result.push_str(&ROMAN_DIGITS[i + 1]);\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = roman_digit.to_string() + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp3n01laq2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpyeaf_q5z.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut n = number;\n    while n > 0\
    \ {\n        if n >= 1000 {\n            result.push('m');\n            n -= 1000;\n\
    \        } else if n >= 900 {\n            result.push_str(\"cm\");\n        \
    \    n -= 900;\n        } else if n >= 500 {\n            result.push('d');\n\
    \            n -= 500;\n        } else if n >= 400 {\n            result.push_str(\"\
    cd\");\n            n -= 400;\n        } else if n >= 100 {\n            result.push('c');\n\
    \            n -= 100;\n        } else if n >= 90 {\n            result.push_str(\"\
    xc\");\n            n -= 90;\n        } else if n >= 50 {\n            result.push('l');\n\
    \            n -= 50;\n        } else if n >= 40 {\n            result.push_str(\"\
    xl\");\n            n -= 40;\n        } else if n >= 10 {\n            result.push('x');\n\
    \            n -= 10;\n        } else if n >= 9 {\n            result.push_str(\"\
    ix\");\n            n -= 9;\n        } else if n >= 5 {\n            result.push('v');\n\
    \            n -= 5;\n        } else if n >= 4 {\n            result.push_str(\"\
    iv\");\n            n -= 4;\n        } else if n >= 1 {\n            result.push('i');\n\
    \            n -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = mini_roman_digit(digit, i) + &result;\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpr6s4mixw.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ numeral_map = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n      \
    \  (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90,\
    \ \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n\
    \        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1,\
    \ \"i\"),\n    ];\n    while number > 0 {\n        for (value, numeral) in numeral_map.iter()\
    \ {\n            if number >= *value {\n                result.push_str(numeral);\n\
    \                number -= *value;\n                break;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let (one, five, ten) = match i {\n            0 => ('i', 'v', 'x'),\n\
    \            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n      \
    \      3 => ('m', 'v', 'x'),\n            _ => ('i', 'v', 'x'),\n        };\n\
    \        match digit {\n            1 => result.insert(0, one),\n            2\
    \ => {\n                result.insert(0, one);\n                result.insert(0,\
    \ one);\n            }\n            3 => {\n                result.insert(0, one);\n\
    \                result.insert(0, one);\n                result.insert(0, one);\n\
    \            }\n            4 => {\n                result.insert(0, one);\n \
    \               result.insert(0, five);\n            }\n            5 => result.insert(0,\
    \ five),\n            6 => {\n                result.insert(0, one);\n       \
    \         result.insert(0, five);\n            }\n            7 => {\n       \
    \         result.insert(0, one);\n                result.insert(0, one);\n   \
    \             result.insert(0, five);\n            }\n            8 => {\n   \
    \             result.insert(0, one);\n                result.insert(0, one);\n\
    \                result.insert(0, one);\n                result.insert(0, five);\n\
    \            }\n            9 => {\n                result.insert(0, one);\n \
    \               result.insert(0, ten);\n            }\n            _ => (),\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xxi\"`,\n right: `\"xix\"`', /tmp/tmps7cku09j.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpahlwaopd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let numerals\
    \ = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in numerals.iter() {\n        while number >= *value\
    \ {\n            result.push_str(numeral);\n            number -= *value;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = mini_roman_digit(digit, i) + &result;\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpmcuxqov3.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpcktjo4y1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut num_digits\
    \ = num_digits(num);\n    while num_digits > 0 {\n        let digit = num / 10_isize.pow(num_digits\
    \ - 1);\n        num -= digit * 10_isize.pow(num_digits - 1);\n        num_digits\
    \ -= 1;\n        match digit {\n            1 => result.push_str(\"i\"),\n   \
    \         2 => result.push_str(\"ii\"),\n            3 => result.push_str(\"iii\"\
    ),\n            4 => result.push_str(\"iv\"),\n            5 => result.push_str(\"\
    v\"),\n            6 => result.push_str(\"vi\"),\n            7 => result.push_str(\"\
    vii\"),\n            8 => result.push_str(\"viii\"),\n            9 => result.push_str(\"\
    ix\"),\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_digits` in this scope\n  --> /tmp/tmp0tckt_dm.rs:14:26\n\
    \   |\n14 |     let mut num_digits = num_digits(num);\n   |                  \
    \        ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpr2oh1sv2.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpg_r_tbeh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpwl_qkz5p.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp7uimu7yb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman_digit = String::new();\n        match digit {\n       \
    \     1 => roman_digit.push('i'),\n            2 => roman_digit.push_str(\"ii\"\
    ),\n            3 => roman_digit.push_str(\"iii\"),\n            4 => roman_digit.push_str(\"\
    iv\"),\n            5 => roman_digit.push('v'),\n            6 => roman_digit.push_str(\"\
    vi\"),\n            7 => roman_digit.push_str(\"vii\"),\n            8 => roman_digit.push_str(\"\
    viii\"),\n            9 => roman_digit.push_str(\"ix\"),\n            _ => (),\n\
    \        }\n        match i {\n            0 => (),\n            1 => roman_digit\
    \ = roman_digit.replace(\"i\", \"x\"),\n            2 => roman_digit = roman_digit.replace(\"\
    i\", \"c\"),\n            3 => roman_digit = roman_digit.replace(\"i\", \"m\"\
    ),\n            _ => (),\n        }\n        result = roman_digit + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"cvii\"`,\n right: `\"clii\"`', /tmp/tmp6hr47xw0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in roman_numerals {\n        while number >= *value\
    \ {\n            result.push_str(numeral);\n            number -= *value;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpm4vn_rhh.rs:30:25\n\
    \   |\n30 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpm4vn_rhh.rs:32:23\n\
    \   |\n32 |             number -= *value;\n   |                       ^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n   \
    \     (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n        (\"\
    xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n\
    \        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"\
    i\", 1),\n    ];\n    while number > 0 {\n        for (numeral, value) in roman_numerals.iter()\
    \ {\n            if number >= *value {\n                result.push_str(numeral);\n\
    \                number -= *value;\n                break;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = mini_roman_digit(digit, i) + &result;\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpmmc3tnaj.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmph_8kxxlu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = match digit {\n            1 => format!(\"i{}\", result),\n\
    \            2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\"\
    , result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp2kzwar8l.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = mini_roman_digit(digit, i) + &result;\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpxy5_2kk6.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp03gcxsj3.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = match digit {\n            1 => format!(\"i{}\", result),\n\
    \            2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\"\
    , result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp39q0ixk0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut num_to_roman\
    \ = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"\
    ),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n   \
    \     (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"\
    ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n\
    \    while num > 0 {\n        for (i, roman) in num_to_roman.iter() {\n      \
    \      if num >= *i {\n                result.push_str(roman);\n             \
    \   num -= *i;\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpy4l9etuh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpb8f13u2j.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut n = number;\n    while n > 0\
    \ {\n        if n >= 1000 {\n            result.push('m');\n            n -= 1000;\n\
    \        } else if n >= 900 {\n            result.push_str(\"cm\");\n        \
    \    n -= 900;\n        } else if n >= 500 {\n            result.push('d');\n\
    \            n -= 500;\n        } else if n >= 400 {\n            result.push_str(\"\
    cd\");\n            n -= 400;\n        } else if n >= 100 {\n            result.push('c');\n\
    \            n -= 100;\n        } else if n >= 90 {\n            result.push_str(\"\
    xc\");\n            n -= 90;\n        } else if n >= 50 {\n            result.push('l');\n\
    \            n -= 50;\n        } else if n >= 40 {\n            result.push_str(\"\
    xl\");\n            n -= 40;\n        } else if n >= 10 {\n            result.push('x');\n\
    \            n -= 10;\n        } else if n >= 9 {\n            result.push_str(\"\
    ix\");\n            n -= 9;\n        } else if n >= 5 {\n            result.push('v');\n\
    \            n -= 5;\n        } else if n >= 4 {\n            result.push_str(\"\
    iv\");\n            n -= 4;\n        } else if n >= 1 {\n            result.push('i');\n\
    \            n -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut digit\
    \ = 0;\n    while num > 0 {\n        let current_digit = num % 10;\n        num\
    \ /= 10;\n        result = match digit {\n            0 => mini_roman_ones(current_digit)\
    \ + &result,\n            1 => mini_roman_tens(current_digit) + &result,\n   \
    \         2 => mini_roman_hundreds(current_digit) + &result,\n            3 =>\
    \ mini_roman_thousands(current_digit) + &result,\n            _ => panic!(\"Number\
    \ is too big\"),\n        };\n        digit += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_ones` in this scope\n  -->\
    \ /tmp/tmpmh3sy39f.rs:19:18\n   |\n19 |             0 => mini_roman_ones(current_digit)\
    \ + &result,\n   |                  ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `mini_roman_tens` in this scope\n  --> /tmp/tmpmh3sy39f.rs:20:18\n\
    \   |\n20 |             1 => mini_roman_tens(current_digit) + &result,\n   | \
    \                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `mini_roman_hundreds` in this scope\n  --> /tmp/tmpmh3sy39f.rs:21:18\n\
    \   |\n21 |             2 => mini_roman_hundreds(current_digit) + &result,\n \
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `mini_roman_thousands` in this scope\n  --> /tmp/tmpmh3sy39f.rs:22:18\n\
    \   |\n22 |             3 => mini_roman_thousands(current_digit) + &result,\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut roman = String::new();\n    while number\
    \ > 0 {\n        if number >= 1000 {\n            roman.push('m');\n         \
    \   number -= 1000;\n        } else if number >= 900 {\n            roman.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      roman.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            roman.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            roman.push('c');\n           \
    \ number -= 100;\n        } else if number >= 90 {\n            roman.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    roman.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            roman.push_str(\"xl\");\n            number -= 40;\n     \
    \   } else if number >= 10 {\n            roman.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            roman.push_str(\"ix\");\n\
    \            number -= 9;\n        } else if number >= 5 {\n            roman.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            roman.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  roman.push('i');\n            number -= 1;\n        }\n    }\n    roman\n}\n\
    \nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        let roman_digit\
    \ = match digit {\n            1 => \"i\",\n            2 => \"ii\",\n       \
    \     3 => \"iii\",\n            4 => \"iv\",\n            5 => \"v\",\n     \
    \       6 => \"vi\",\n            7 => \"vii\",\n            8 => \"viii\",\n\
    \            9 => \"ix\",\n            _ => \"\",\n        };\n        result\
    \ = format!(\"{}{}\", roman_digit, result);\n        num /= 10;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpzkcjika6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        result = mini_roman_digit(digit,\
    \ i) + &result;\n        num /= 10;\n        i += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmph5omu2p6.rs:17:18\n   |\n17 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpxw4suk_4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ symbols = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500,\
    \ \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"\
    ),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n      \
    \  (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"\
    ),\n    ];\n    while number > 0 {\n        let (value, symbol) = symbols.pop().unwrap();\n\
    \        while number >= value {\n            result.push_str(symbol);\n     \
    \       number -= value;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmpq1464qna.rs:41:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmphp575aj4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ index = 0;\n    while number > 0 {\n        let digit = number % 10;\n     \
    \   number /= 10;\n        result = mini_roman_digit(digit, index) + &result;\n\
    \        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpkqwgbkdk.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ index) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpuz8epscl.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpbe6mhlpl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpvjb41_2p.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ >= 1000 {\n        result.push_str(\"m\");\n        num -= 1000;\n    }\n  \
    \  if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n  \
    \  }\n    if num >= 500 {\n        result.push_str(\"d\");\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push_str(\"c\");\n     \
    \   num -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n\
    \        num -= 90;\n    }\n    if num >= 50 {\n        result.push_str(\"l\"\
    );\n        num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"\
    xl\");\n        num -= 40;\n    }\n    while num >= 10 {\n        result.push_str(\"\
    x\");\n        num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"\
    ix\");\n        num -= 9;\n    }\n    if num >= 5 {\n        result.push_str(\"\
    v\");\n        num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"\
    iv\");\n        num -= 4;\n    }\n    while num >= 1 {\n        result.push_str(\"\
    i\");\n        num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        let roman_digit\
    \ = match digit {\n            0 => String::from(\"\"),\n            1 => String::from(\"\
    i\"),\n            2 => String::from(\"ii\"),\n            3 => String::from(\"\
    iii\"),\n            4 => String::from(\"iv\"),\n            5 => String::from(\"\
    v\"),\n            6 => String::from(\"vi\"),\n            7 => String::from(\"\
    vii\"),\n            8 => String::from(\"viii\"),\n            9 => String::from(\"\
    ix\"),\n            _ => String::from(\"\"),\n        };\n        result = roman_digit\
    \ + &result;\n        num = num / 10;\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpr4nvhhkh.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ numeral_index = 0;\n    while number > 0 {\n        let numeral = ROMAN_NUMERALS[numeral_index];\n\
    \        let numeral_value = ROMAN_NUMERAL_VALUES[numeral_index];\n        if\
    \ number >= numeral_value {\n            result.push_str(numeral);\n         \
    \   number -= numeral_value;\n        } else {\n            numeral_index += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpuhbll1gx.rs:16:23\n\
    \   |\n16 |         let numeral = ROMAN_NUMERALS[numeral_index];\n   |       \
    \                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_NUMERAL_VALUES` in this scope\n  --> /tmp/tmpuhbll1gx.rs:17:29\n\
    \   |\n17 |         let numeral_value = ROMAN_NUMERAL_VALUES[numeral_index];\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        if\
    \ digit > 0 {\n            result.insert_str(0, &mini_roman_digit(digit, i));\n\
    \        }\n        number /= 10;\n        i += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpm_4fjg_3.rs:18:35\n   |\n18 |             result.insert_str(0, &mini_roman_digit(digit,\
    \ i));\n   |                                   ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = roman_digit.to_string() + &result;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpwdfd04d2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp4vs_8jzm.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = roman_digit.to_string() + &result;\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpa2a5l16s.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut remaining = number;\n    let\
    \ mut remainder = 0;\n    let mut digit = 0;\n    let mut roman_digit = String::new();\n\
    \n    while remaining > 0 {\n        remainder = remaining % 10;\n        remaining\
    \ = remaining / 10;\n        digit = digit + 1;\n\n        match digit {\n   \
    \         1 => roman_digit = match remainder {\n                1 => String::from(\"\
    i\"),\n                2 => String::from(\"ii\"),\n                3 => String::from(\"\
    iii\"),\n                4 => String::from(\"iv\"),\n                5 => String::from(\"\
    v\"),\n                6 => String::from(\"vi\"),\n                7 => String::from(\"\
    vii\"),\n                8 => String::from(\"viii\"),\n                9 => String::from(\"\
    ix\"),\n                _ => String::from(\"\"),\n            },\n           \
    \ 2 => roman_digit = match remainder {\n                1 => String::from(\"x\"\
    ),\n                2 => String::from(\"xx\"),\n                3 => String::from(\"\
    xxx\"),\n                4 => String::from(\"xl\"),\n                5 => String::from(\"\
    l\"),\n                6 => String::from(\"lx\"),\n                7 => String::from(\"\
    lxx\"),\n                8 => String::from(\"lxxx\"),\n                9 => String::from(\"\
    xc\"),\n                _ => String::from(\"\"),\n            },\n           \
    \ 3 => roman_digit = match remainder {\n                1 => String::from(\"c\"\
    ),\n                2 => String::from(\"cc\"),\n                3 => String::from(\"\
    ccc\"),\n                4 => String::from(\"cd\"),\n                5 => String::from(\"\
    d\"),\n                6 => String::from(\"dc\"),\n                7 => String::from(\"\
    dcc\"),\n                8 => String::from(\"dccc\"),\n                9 => String::from(\"\
    cm\"),\n                _ => String::from(\"\"),\n            },\n           \
    \ 4 => roman_digit = match remainder {\n                1 => String::from(\"m\"\
    ),\n                2 => String::from(\"mm\"),\n                3 => String::from(\"\
    mmm\"),\n                _ => String::from(\"\"),\n            },\n          \
    \  _ => roman_digit = String::from(\"\"),\n        }\n\n        result = roman\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcrfq72xn.rs:88:3\n\
    \   |\n11 | fn int_to_mini_roman(number: isize) -> String {\n   |            \
    \                                   - unclosed delimiter\n...\n18 |     while\
    \ remaining > 0 {\n   |                         - this delimiter might not be\
    \ properly closed...\n...\n70 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nerror[E0425]: cannot find value `roman`\
    \ in this scope\n  --> /tmp/tmpcrfq72xn.rs:69:18\n   |\n69 |         result =\
    \ roman\n   |                  ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcrfq72xn.rs:11:40\n   |\n11 | fn int_to_mini_roman(number:\
    \ isize) -> String {\n   |    -----------------                   ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut num_digits\
    \ = 0;\n    while num > 0 {\n        num_digits += 1;\n        num /= 10;\n  \
    \  }\n    num = number;\n    for _ in 0..num_digits {\n        let digit = num\
    \ % 10;\n        num /= 10;\n        match digit {\n            1 => result.push('i'),\n\
    \            2 => result.push_str(\"ii\"),\n            3 => result.push_str(\"\
    iii\"),\n            4 => result.push_str(\"iv\"),\n            5 => result.push('v'),\n\
    \            6 => result.push_str(\"vi\"),\n            7 => result.push_str(\"\
    vii\"),\n            8 => result.push_str(\"viii\"),\n            9 => result.push_str(\"\
    ix\"),\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ixi\"`,\n right: `\"xix\"`', /tmp/tmpov4nhacf.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let (ones, fives, tens) = match i {\n            0 => ('i', 'v', 'x'),\n\
    \            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n      \
    \      3 => ('m', 'v', 'x'),\n            _ => ('i', 'v', 'x'),\n        };\n\
    \        match digit {\n            1 => result.push(ones),\n            2 =>\
    \ result.push_str(&[ones, ones].iter().collect::<String>()),\n            3 =>\
    \ result.push_str(&[ones, ones, ones].iter().collect::<String>()),\n         \
    \   4 => result.push_str(&[ones, fives].iter().collect::<String>()),\n       \
    \     5 => result.push(fives),\n            6 => result.push_str(&[fives, ones].iter().collect::<String>()),\n\
    \            7 => result.push_str(&[fives, ones, ones].iter().collect::<String>()),\n\
    \            8 => result.push_str(&[fives, ones, ones, ones].iter().collect::<String>()),\n\
    \            9 => result.push_str(&[ones, tens].iter().collect::<String>()),\n\
    \            _ => (),\n        }\n        i += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ixx\"`,\n right: `\"xix\"`', /tmp/tmpfyydowxj.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmplr32vdsa.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpd2p3fxiz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in roman_numerals {\n        while number >= *value\
    \ {\n            result.push_str(numeral);\n            number -= *value;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpm1u0o1_2.rs:30:25\n\
    \   |\n30 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpm1u0o1_2.rs:32:23\n\
    \   |\n32 |             number -= *value;\n   |                       ^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpqi6ak9bl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        result\
    \ = mini_roman_digit(digit, i) + &result;\n        number /= 10;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpu31zup_a.rs:17:18\n   |\n17 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpnpp3nxu4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        let\
    \ roman_digit = match digit {\n            1 => \"i\",\n            2 => \"ii\"\
    ,\n            3 => \"iii\",\n            4 => \"iv\",\n            5 => \"v\"\
    ,\n            6 => \"vi\",\n            7 => \"vii\",\n            8 => \"viii\"\
    ,\n            9 => \"ix\",\n            _ => \"\",\n        };\n        result\
    \ = format!(\"{}{}\", roman_digit, result);\n        number /= 10;\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpu242hp63.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpw6hv8311.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut num_of_digits\
    \ = 0;\n    while num > 0 {\n        num_of_digits += 1;\n        num /= 10;\n\
    \    }\n    num = number;\n    let mut digit = 0;\n    while num > 0 {\n     \
    \   digit = num % 10;\n        num /= 10;\n        match num_of_digits {\n   \
    \         1 => {\n                result = mini_roman_ones(digit) + &result;\n\
    \            }\n            2 => {\n                result = mini_roman_tens(digit)\
    \ + &result;\n            }\n            3 => {\n                result = mini_roman_hundreds(digit)\
    \ + &result;\n            }\n            4 => {\n                result = mini_roman_thousands(digit)\
    \ + &result;\n            }\n            _ => (),\n        }\n        num_of_digits\
    \ -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_ones` in this scope\n  -->\
    \ /tmp/tmpsyy0gpq1.rs:26:26\n   |\n26 |                 result = mini_roman_ones(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_tens` in this scope\n\
    \  --> /tmp/tmpsyy0gpq1.rs:29:26\n   |\n29 |                 result = mini_roman_tens(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_hundreds` in this scope\n\
    \  --> /tmp/tmpsyy0gpq1.rs:32:26\n   |\n32 |                 result = mini_roman_hundreds(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_thousands` in this scope\n\
    \  --> /tmp/tmpsyy0gpq1.rs:35:26\n   |\n35 |                 result = mini_roman_thousands(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman = String::new();\n        match digit {\n            1\
    \ => roman.push('i'),\n            2 => roman.push_str(\"ii\"),\n            3\
    \ => roman.push_str(\"iii\"),\n            4 => roman.push_str(\"iv\"),\n    \
    \        5 => roman.push('v'),\n            6 => roman.push_str(\"vi\"),\n   \
    \         7 => roman.push_str(\"vii\"),\n            8 => roman.push_str(\"viii\"\
    ),\n            9 => roman.push_str(\"ix\"),\n            _ => (),\n        }\n\
    \        match i {\n            0 => (),\n            1 => roman = roman.replace(\"\
    i\", \"x\"),\n            2 => roman = roman.replace(\"i\", \"c\"),\n        \
    \    3 => roman = roman.replace(\"i\", \"m\"),\n            _ => (),\n       \
    \ }\n        result = roman + &result;\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"cvii\"`,\n right: `\"clii\"`', /tmp/tmpnsw4qnmf.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ digit = 0;\n    while number > 0 {\n        let digit_value = get_digit_value(number,\
    \ digit);\n        let roman_digit = get_roman_digit(digit_value, digit);\n  \
    \      result.push_str(&roman_digit);\n        number -= digit_value;\n      \
    \  digit += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_digit_value` in this scope\n  -->\
    \ /tmp/tmphwrvlzyx.rs:16:27\n   |\n16 |         let digit_value = get_digit_value(number,\
    \ digit);\n   |                           ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `get_roman_digit` in this scope\n  --> /tmp/tmphwrvlzyx.rs:17:27\n\
    \   |\n17 |         let roman_digit = get_roman_digit(digit_value, digit);\n \
    \  |                           ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let roman_numerals\
    \ = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (roman, arabic) in roman_numerals.iter() {\n        while number >= *arabic\
    \ {\n            result.push_str(roman);\n            number -= *arabic;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let (one, five, ten) = match i {\n            0 => ('i', 'v', 'x'),\n\
    \            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n      \
    \      3 => ('m', 'v', 'x'),\n            _ => panic!(\"Number is too large\"\
    ),\n        };\n        match digit {\n            1 | 2 | 3 => result.push_str(&one.to_string().repeat(digit\
    \ as usize)),\n            4 => result.push_str(&format!(\"{}{}\", one, five)),\n\
    \            5 | 6 | 7 | 8 => result.push_str(&format!(\"{}{}\", five, one.to_string().repeat((digit\
    \ - 5) as usize))),\n            9 => result.push_str(&format!(\"{}{}\", one,\
    \ ten)),\n            _ => (),\n        }\n        i += 1;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xxi\"`,\n right: `\"xix\"`', /tmp/tmp0o4btf1n.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut remaining = number;\n    let\
    \ mut current_digit = 0;\n    while remaining > 0 {\n        let digit = remaining\
    \ % 10;\n        remaining /= 10;\n        match current_digit {\n           \
    \ 0 => {\n                result.push_str(&int_to_mini_roman_ones(digit));\n \
    \           }\n            1 => {\n                result.push_str(&int_to_mini_roman_tens(digit));\n\
    \            }\n            2 => {\n                result.push_str(&int_to_mini_roman_hundreds(digit));\n\
    \            }\n            3 => {\n                result.push_str(&int_to_mini_roman_thousands(digit));\n\
    \            }\n            _ => panic!(\"Unhandled digit\"),\n        }\n   \
    \     current_digit += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `int_to_mini_roman_ones` in this scope\n\
    \  --> /tmp/tmpo6tsrpbh.rs:20:34\n   |\n20 |                 result.push_str(&int_to_mini_roman_ones(digit));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `int_to_mini_roman_tens` in this\
    \ scope\n  --> /tmp/tmpo6tsrpbh.rs:23:34\n   |\n23 |                 result.push_str(&int_to_mini_roman_tens(digit));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `int_to_mini_roman_hundreds` in\
    \ this scope\n  --> /tmp/tmpo6tsrpbh.rs:26:34\n   |\n26 |                 result.push_str(&int_to_mini_roman_hundreds(digit));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `int_to_mini_roman_thousands`\
    \ in this scope\n  --> /tmp/tmpo6tsrpbh.rs:29:34\n   |\n29 |                 result.push_str(&int_to_mini_roman_thousands(digit));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        result = mini_roman_digit(digit,\
    \ i) + &result;\n        num /= 10;\n        i += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpgl3vrrd9.rs:17:18\n   |\n17 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp2hc7zufq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmposed9uuk.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = match digit {\n            1 => format!(\"i{}\", result),\n\
    \            2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\"\
    , result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp76xrj098.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman_digit = String::new();\n        match i {\n           \
    \ 0 => {\n                if digit == 4 {\n                    roman_digit.push('i');\n\
    \                    roman_digit.push('v');\n                } else if digit ==\
    \ 9 {\n                    roman_digit.push('i');\n                    roman_digit.push('x');\n\
    \                } else {\n                    if digit >= 5 {\n             \
    \           roman_digit.push('v');\n                        digit -= 5;\n    \
    \                }\n                    for _ in 0..digit {\n                \
    \        roman_digit.push('i');\n                    }\n                }\n  \
    \          }\n            1 => {\n                if digit == 4 {\n          \
    \          roman_digit.push('x');\n                    roman_digit.push('l');\n\
    \                } else if digit == 9 {\n                    roman_digit.push('x');\n\
    \                    roman_digit.push('c');\n                } else {\n      \
    \              if digit >= 5 {\n                        roman_digit.push('l');\n\
    \                        digit -= 5;\n                    }\n                \
    \    for _ in 0..digit {\n                        roman_digit.push('x');\n   \
    \                 }\n                }\n            }\n            2 => {\n  \
    \              if digit == 4 {\n                    roman_digit.push('c');\n \
    \                   roman_digit.push('d');\n                } else if digit ==\
    \ 9 {\n                    roman_digit.push('c');\n                    roman_digit.push('m');\n\
    \                } else {\n                    if digit >= 5 {\n             \
    \           roman_digit.push('d');\n                        digit -= 5;\n    \
    \                }\n                    for _ in 0..digit {\n                \
    \        roman_digit.push('c');\n                    }\n                }\n  \
    \          }\n            3 => {\n                for _ in 0..digit {\n      \
    \              roman_digit.push('m');\n                }\n            }\n    \
    \        _ => {}\n        }\n        result = roman_digit + &result;\n       \
    \ i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `digit`\n  -->\
    \ /tmp/tmpifluk2d_.rs:30:25\n   |\n16 |         let digit = num % 10;\n   |  \
    \           -----\n   |             |\n   |             first assignment to `digit`\n\
    \   |             help: consider making this binding mutable: `mut digit`\n...\n\
    30 |                         digit -= 5;\n   |                         ^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `digit`\n  --> /tmp/tmpifluk2d_.rs:47:25\n   |\n16 | \
    \        let digit = num % 10;\n   |             -----\n   |             |\n \
    \  |             first assignment to `digit`\n   |             help: consider\
    \ making this binding mutable: `mut digit`\n...\n47 |                        \
    \ digit -= 5;\n   |                         ^^^^^^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `digit`\n  --> /tmp/tmpifluk2d_.rs:64:25\n   |\n16 |         let digit = num\
    \ % 10;\n   |             -----\n   |             |\n   |             first assignment\
    \ to `digit`\n   |             help: consider making this binding mutable: `mut\
    \ digit`\n...\n64 |                         digit -= 5;\n   |                \
    \         ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpxu04qhwo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        if digit ==\
    \ 9 {\n            result.push_str(&ROMAN_DIGITS[i + 1]);\n            result.push_str(&ROMAN_DIGITS[i]);\n\
    \        } else if digit == 4 {\n            result.push_str(&ROMAN_DIGITS[i]);\n\
    \            result.push_str(&ROMAN_DIGITS[i + 1]);\n        } else {\n      \
    \      if digit >= 5 {\n                result.push_str(&ROMAN_DIGITS[i + 1]);\n\
    \                digit -= 5;\n            }\n            for _ in 0..digit {\n\
    \                result.push_str(&ROMAN_DIGITS[i]);\n            }\n        }\n\
    \        num /= 10;\n        i += 2;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:18:30\n\
    \   |\n18 |             result.push_str(&ROMAN_DIGITS[i + 1]);\n   |         \
    \                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:19:30\n \
    \  |\n19 |             result.push_str(&ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:21:30\n \
    \  |\n21 |             result.push_str(&ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:22:30\n \
    \  |\n22 |             result.push_str(&ROMAN_DIGITS[i + 1]);\n   |          \
    \                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:25:34\n \
    \  |\n25 |                 result.push_str(&ROMAN_DIGITS[i + 1]);\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpwjk2ihk7.rs:29:34\n\
    \   |\n29 |                 result.push_str(&ROMAN_DIGITS[i]);\n   |         \
    \                         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let mut roman_digit = String::new();\n        match digit {\n       \
    \     1 => roman_digit.push('i'),\n            2 => roman_digit.push_str(\"ii\"\
    ),\n            3 => roman_digit.push_str(\"iii\"),\n            4 => roman_digit.push_str(\"\
    iv\"),\n            5 => roman_digit.push('v'),\n            6 => roman_digit.push_str(\"\
    vi\"),\n            7 => roman_digit.push_str(\"vii\"),\n            8 => roman_digit.push_str(\"\
    viii\"),\n            9 => roman_digit.push_str(\"ix\"),\n            _ => {}\n\
    \        }\n        match i {\n            0 => {\n                result.insert_str(0,\
    \ &roman_digit);\n            }\n            1 => {\n                result.insert_str(0,\
    \ &roman_digit.replace(\"i\", \"x\"));\n            }\n            2 => {\n  \
    \              result.insert_str(0, &roman_digit.replace(\"i\", \"c\"));\n   \
    \         }\n            3 => {\n                result.insert_str(0, &roman_digit.replace(\"\
    i\", \"m\"));\n            }\n            _ => {}\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"cvii\"`,\n right: `\"clii\"`', /tmp/tmp9_gli3n2.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmplez3n4jx.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ >= 1000 {\n        result.push_str(\"m\");\n        num -= 1000;\n    }\n  \
    \  while num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    while num >= 500 {\n        result.push_str(\"d\");\n        num -=\
    \ 500;\n    }\n    while num >= 400 {\n        result.push_str(\"cd\");\n    \
    \    num -= 400;\n    }\n    while num >= 100 {\n        result.push_str(\"c\"\
    );\n        num -= 100;\n    }\n    while num >= 90 {\n        result.push_str(\"\
    xc\");\n        num -= 90;\n    }\n    while num >= 50 {\n        result.push_str(\"\
    l\");\n        num -= 50;\n    }\n    while num >= 40 {\n        result.push_str(\"\
    xl\");\n        num -= 40;\n    }\n    while num >= 10 {\n        result.push_str(\"\
    x\");\n        num -= 10;\n    }\n    while num >= 9 {\n        result.push_str(\"\
    ix\");\n        num -= 9;\n    }\n    while num >= 5 {\n        result.push_str(\"\
    v\");\n        num -= 5;\n    }\n    while num >= 4 {\n        result.push_str(\"\
    iv\");\n        num -= 4;\n    }\n    while num >= 1 {\n        result.push_str(\"\
    i\");\n        num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ index = 0;\n    while number > 0 {\n        let digit = number % 10;\n     \
    \   number /= 10;\n        if digit == 0 {\n            index += 1;\n        \
    \    continue;\n        }\n        let roman_digit = match index {\n         \
    \   0 => match digit {\n                1 => \"i\",\n                2 => \"ii\"\
    ,\n                3 => \"iii\",\n                4 => \"iv\",\n             \
    \   5 => \"v\",\n                6 => \"vi\",\n                7 => \"vii\",\n\
    \                8 => \"viii\",\n                9 => \"ix\",\n              \
    \  _ => panic!(\"Invalid digit: {}\", digit),\n            },\n            1 =>\
    \ match digit {\n                1 => \"x\",\n                2 => \"xx\",\n \
    \               3 => \"xxx\",\n                4 => \"xl\",\n                5\
    \ => \"l\",\n                6 => \"lx\",\n                7 => \"lxx\",\n   \
    \             8 => \"lxxx\",\n                9 => \"xc\",\n                _\
    \ => panic!(\"Invalid digit: {}\", digit),\n            },\n            2 => match\
    \ digit {\n                1 => \"c\",\n                2 => \"cc\",\n       \
    \         3 => \"ccc\",\n                4 => \"cd\",\n                5 => \"\
    d\",\n                6 => \"dc\",\n                7 => \"dcc\",\n          \
    \      8 => \"dccc\",\n                9 => \"cm\",\n                _ => panic!(\"\
    Invalid digit: {}\", digit),\n            },\n            3 => match digit {\n\
    \                1 => \"m\",\n                2 => \"mm\",\n                3\
    \ => \"mmm\",\n                _ => panic!(\"Invalid digit: {}\", digit),\n  \
    \          },\n            _ => panic!(\"Invalid index: {}\", index),\n      \
    \  };\n        result.insert_str(0, roman_digit);\n        index += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        match i {\n            0 => {\n                result = mini_roman_ones(digit)\
    \ + &result;\n            }\n            1 => {\n                result = mini_roman_tens(digit)\
    \ + &result;\n            }\n            2 => {\n                result = mini_roman_hundreds(digit)\
    \ + &result;\n            }\n            3 => {\n                result = mini_roman_thousands(digit)\
    \ + &result;\n            }\n            _ => {\n                panic!(\"Number\
    \ is too large\");\n            }\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_ones` in this scope\n  -->\
    \ /tmp/tmp28luiypx.rs:20:26\n   |\n20 |                 result = mini_roman_ones(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_tens` in this scope\n\
    \  --> /tmp/tmp28luiypx.rs:23:26\n   |\n23 |                 result = mini_roman_tens(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_hundreds` in this scope\n\
    \  --> /tmp/tmp28luiypx.rs:26:26\n   |\n26 |                 result = mini_roman_hundreds(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_thousands` in this scope\n\
    \  --> /tmp/tmp28luiypx.rs:29:26\n   |\n29 |                 result = mini_roman_thousands(digit)\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (roman, arabic) in roman_numerals.iter() {\n        while number >= *arabic\
    \ {\n            result.push_str(roman);\n            number -= *arabic;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        let roman_digit\
    \ = match digit {\n            1 => \"i\",\n            2 => \"ii\",\n       \
    \     3 => \"iii\",\n            4 => \"iv\",\n            5 => \"v\",\n     \
    \       6 => \"vi\",\n            7 => \"vii\",\n            8 => \"viii\",\n\
    \            9 => \"ix\",\n            _ => \"\",\n        };\n        result\
    \ = format!(\"{}{}\", roman_digit, result);\n        num /= 10;\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpmfm26kty.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let mut roman_digit = String::new();\n        if digit == 9\
    \ {\n            roman_digit.push_str(ROMAN_DIGITS[i + 1]);\n            roman_digit.push_str(ROMAN_DIGITS[i\
    \ - 1]);\n        } else if digit == 4 {\n            roman_digit.push_str(ROMAN_DIGITS[i]);\n\
    \            roman_digit.push_str(ROMAN_DIGITS[i + 1]);\n        } else {\n  \
    \          if digit >= 5 {\n                roman_digit.push_str(ROMAN_DIGITS[i\
    \ + 1]);\n                digit -= 5;\n            }\n            for _ in 0..digit\
    \ {\n                roman_digit.push_str(ROMAN_DIGITS[i]);\n            }\n \
    \       }\n        result = roman_digit + &result;\n        i += 2;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:20:34\n\
    \   |\n20 |             roman_digit.push_str(ROMAN_DIGITS[i + 1]);\n   |     \
    \                             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:21:34\n\
    \   |\n21 |             roman_digit.push_str(ROMAN_DIGITS[i - 1]);\n   |     \
    \                             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:23:34\n\
    \   |\n23 |             roman_digit.push_str(ROMAN_DIGITS[i]);\n   |         \
    \                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:24:34\n\
    \   |\n24 |             roman_digit.push_str(ROMAN_DIGITS[i + 1]);\n   |     \
    \                             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:27:38\n\
    \   |\n27 |                 roman_digit.push_str(ROMAN_DIGITS[i + 1]);\n   | \
    \                                     ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp82hoklsz.rs:31:38\n\
    \   |\n31 |                 roman_digit.push_str(ROMAN_DIGITS[i]);\n   |     \
    \                                 ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp_5si28st.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in roman_numerals.iter() {\n        while number >=\
    \ *value {\n            result.push_str(numeral);\n            number -= *value;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let (one, five, ten) = match i {\n            0 => ('i', 'v',\
    \ 'x'),\n            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n\
    \            3 => ('m', 'v', 'x'),\n            _ => panic!(\"Number too large\"\
    ),\n        };\n        match digit {\n            1 | 2 | 3 => result.push_str(&one.to_string().repeat(digit\
    \ as usize)),\n            4 => result.push_str(&format!(\"{}{}\", one, five)),\n\
    \            5 | 6 | 7 | 8 => result.push_str(&format!(\"{}{}\", five, one.to_string().repeat((digit\
    \ - 5) as usize))),\n            9 => result.push_str(&format!(\"{}{}\", one,\
    \ ten)),\n            _ => (),\n        }\n        i += 1;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xxi\"`,\n right: `\"xix\"`', /tmp/tmp3m6ssic1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp2fwuvtys.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let roman_numerals\
    \ = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (roman, arabic) in roman_numerals {\n        while num >= arabic {\n\
    \            result.push_str(roman);\n            num -= arabic;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (numeral, value) in roman_numerals.iter() {\n        while number >=\
    \ *value {\n            result.push_str(numeral);\n            number -= *value;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = match digit {\n            1 => format!(\"i{}\", result),\n\
    \            2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\"\
    , result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmphmcecaao.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        result = mini_roman_digit(digit, i) + &result;\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp6fqvjm2c.rs:18:18\n   |\n18 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ >= 1000 {\n        result.push_str(\"m\");\n        num -= 1000;\n    }\n  \
    \  if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n  \
    \  }\n    if num >= 500 {\n        result.push_str(\"d\");\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push_str(\"c\");\n     \
    \   num -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n\
    \        num -= 90;\n    }\n    if num >= 50 {\n        result.push_str(\"l\"\
    );\n        num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"\
    xl\");\n        num -= 40;\n    }\n    while num >= 10 {\n        result.push_str(\"\
    x\");\n        num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"\
    ix\");\n        num -= 9;\n    }\n    if num >= 5 {\n        result.push_str(\"\
    v\");\n        num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"\
    iv\");\n        num -= 4;\n    }\n    while num >= 1 {\n        result.push_str(\"\
    i\");\n        num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpf_8qf2ql.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut num = number;\n    let mut result = String::new();\n    let roman_numerals\
    \ = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n        (\"d\", 500),\n\
    \        (\"cd\", 400),\n        (\"c\", 100),\n        (\"xc\", 90),\n      \
    \  (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n        (\"ix\"\
    , 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"i\", 1),\n    ];\n\
    \    for (roman, arabic) in roman_numerals {\n        while num >= arabic {\n\
    \            result.push_str(roman);\n            num -= arabic;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmphjay_dfe.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpi1j_oxhk.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ >= 1000 {\n        result.push_str(\"m\");\n        num -= 1000;\n    }\n  \
    \  if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n  \
    \  }\n    if num >= 500 {\n        result.push_str(\"d\");\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push_str(\"c\");\n     \
    \   num -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n\
    \        num -= 90;\n    }\n    if num >= 50 {\n        result.push_str(\"l\"\
    );\n        num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"\
    xl\");\n        num -= 40;\n    }\n    while num >= 10 {\n        result.push_str(\"\
    x\");\n        num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"\
    ix\");\n        num -= 9;\n    }\n    if num >= 5 {\n        result.push_str(\"\
    v\");\n        num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"\
    iv\");\n        num -= 4;\n    }\n    while num >= 1 {\n        result.push_str(\"\
    i\");\n        num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpoq4pmf2b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        let roman_digit = match digit {\n            1 => \"i\",\n \
    \           2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n\
    \            5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n\
    \            8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpnrx5_vd8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let digit_str = match digit {\n            1 => \"i\",\n            2\
    \ => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n          \
    \  5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n        \
    \    8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n      \
    \  };\n        result = digit_str.to_string() + &result;\n        i += 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n \
    \   assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp0_dj6gnc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut n = number;\n    while n >=\
    \ 1000 {\n        result.push('m');\n        n -= 1000;\n    }\n    if n >= 900\
    \ {\n        result.push_str(\"cm\");\n        n -= 900;\n    }\n    if n >= 500\
    \ {\n        result.push('d');\n        n -= 500;\n    }\n    if n >= 400 {\n\
    \        result.push_str(\"cd\");\n        n -= 400;\n    }\n    while n >= 100\
    \ {\n        result.push('c');\n        n -= 100;\n    }\n    if n >= 90 {\n \
    \       result.push_str(\"xc\");\n        n -= 90;\n    }\n    if n >= 50 {\n\
    \        result.push('l');\n        n -= 50;\n    }\n    if n >= 40 {\n      \
    \  result.push_str(\"xl\");\n        n -= 40;\n    }\n    while n >= 10 {\n  \
    \      result.push('x');\n        n -= 10;\n    }\n    if n >= 9 {\n        result.push_str(\"\
    ix\");\n        n -= 9;\n    }\n    if n >= 5 {\n        result.push('v');\n \
    \       n -= 5;\n    }\n    if n >= 4 {\n        result.push_str(\"iv\");\n  \
    \      n -= 4;\n    }\n    while n >= 1 {\n        result.push('i');\n       \
    \ n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ >= 1000 {\n        result.push_str(\"m\");\n        num -= 1000;\n    }\n  \
    \  if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n  \
    \  }\n    if num >= 500 {\n        result.push_str(\"d\");\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push_str(\"c\");\n     \
    \   num -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n\
    \        num -= 90;\n    }\n    if num >= 50 {\n        result.push_str(\"l\"\
    );\n        num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"\
    xl\");\n        num -= 40;\n    }\n    while num >= 10 {\n        result.push_str(\"\
    x\");\n        num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"\
    ix\");\n        num -= 9;\n    }\n    if num >= 5 {\n        result.push_str(\"\
    v\");\n        num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"\
    iv\");\n        num -= 4;\n    }\n    while num >= 1 {\n        result.push_str(\"\
    i\");\n        num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpo2qgpvmw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result.push('m');\n           \
    \ num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut n = number;\n    let mut result = String::new();\n    let mut i =\
    \ 0;\n    while n > 0 {\n        let digit = n % 10;\n        n /= 10;\n     \
    \   let roman_digit = match digit {\n            1 => \"i\",\n            2 =>\
    \ \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n            5\
    \ => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n           \
    \ 8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n        };\n\
    \        result = format!(\"{}{}\", roman_digit, result);\n        i += 1;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpmva5enwb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut number = number;\n    let mut result = String::new();\n    let mut\
    \ i = 0;\n    while number > 0 {\n        let digit = number % 10;\n        number\
    \ /= 10;\n        result = match digit {\n            1 => format!(\"i{}\", result),\n\
    \            2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\"\
    , result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n        i += 1;\n        if i == 2 {\n            result = format!(\"\
    x{}\", result);\n        } else if i == 3 {\n            result = format!(\"c{}\"\
    , result);\n        } else if i == 4 {\n            result = format!(\"m{}\",\
    \ result);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xiix\"`,\n right: `\"xix\"`', /tmp/tmp8bergf24.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>>\
    \ int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n\
    /// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = number;\n    let mut i\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        if digit == 0 {\n            i += 1;\n            continue;\n       \
    \ }\n        let (ones, fives, tens) = match i {\n            0 => (String::from(\"\
    i\"), String::from(\"v\"), String::from(\"x\")),\n            1 => (String::from(\"\
    x\"), String::from(\"l\"), String::from(\"c\")),\n            2 => (String::from(\"\
    c\"), String::from(\"d\"), String::from(\"m\")),\n            3 => (String::from(\"\
    m\"), String::from(\"v\"), String::from(\"x\")),\n            _ => panic!(\"Number\
    \ is too large\"),\n        };\n        if digit == 4 {\n            result.push_str(&format!(\"\
    {}{}\", ones, fives));\n        } else if digit == 9 {\n            result.push_str(&format!(\"\
    {}{}\", ones, tens));\n        } else if digit < 4 {\n            result.push_str(&ones.repeat(digit\
    \ as usize));\n        } else {\n            result.push_str(&fives);\n      \
    \      result.push_str(&ones.repeat((digit - 5) as usize));\n        }\n     \
    \   i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ixx\"`,\n right: `\"xix\"`', /tmp/tmpxqd0z7sm.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
