name: HumanEval_112_reverse_delete
language: rs
results:
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp1l5779a0.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp175fje2h.rs:79:3\n\
    \   |\n13 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n64 |     while let Some(c) = chars.next() {\n   |                       \
    \               - this delimiter might not be properly closed...\n65 |       \
    \  if !c.is_whitespace() && !c.is_alphanumeric\n66 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n79 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmp175fje2h.rs:66:1\n   |\n65 |         if !c.is_whitespace()\
    \ && !c.is_alphanumeric\n   |         -- this `if` expression has a condition,\
    \ but no block\n66 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp175fje2h.rs:13:44\n   |\n13 | fn reverse_delete(s: String, c: String)\
    \ -> (String, bool) {\n   |    --------------                          ^^^^^^^^^^^^^^\
    \ expected tuple, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note:  expected tuple `(String,\
    \ bool)`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps3kjgo73.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpd2is29as.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let mut rev = res.clone();\n\
    \    rev.chars().rev();\n    (res, res == rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_tnnl0lu.rs:20:9\n\
    \   |\n20 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmp_tnnl0lu.rs:22:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n22 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp7jh8zdjg.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if c.contains(&s[i]) {\n\
    \            s.remove(i);\n        } else {\n            i += 1;\n        }\n\
    \    }\n    let mut s = s.iter().collect::<String>();\n    let mut s_rev = s.clone();\n\
    \    s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdlc5_ug1.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpdlc5_ug1.rs:24:9\n\
    \   |\n24 |     let mut s = s.iter().collect::<String>();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpdlc5_ug1.rs:25:9\n   |\n25 |     let mut\
    \ s_rev = s.clone();\n   |         ----^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpdlc5_ug1.rs:27:9\n\
    \   |\n24 |     let mut s = s.iter().collect::<String>();\n   |         -----\
    \ move occurs because `s` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n27 |     (s, s == s_rev)\n   |      -  ^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 3 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpmnp4vp4q.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphbp3idvo.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let is_palindrome = res.chars().eq(res.chars().rev());\n\
    \    (res, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut is_palindrome = true;\n    let mut c_chars = c.chars();\n    while let Some(ch)\
    \ = chars.next() {\n        if !c_chars.any(|x| x == ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut chars = result.chars();\n    let mut chars_rev\
    \ = result.chars().rev();\n    while let Some(ch) = chars.next() {\n        if\
    \ let Some(ch_rev) = chars_rev.next() {\n            if ch != ch_rev {\n     \
    \           is_palindrome = false;\n                break;\n            }\n  \
    \      }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"bcde\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmppf4lh3y2.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut c_set = HashSet::new();\n    while let\
    \ Some(c) = chars_c.next() {\n        c_set.insert(c);\n    }\n    while let Some(c)\
    \ = chars.next() {\n        if !c_set.contains(&c) {\n            result.push(c);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_0euhmll.rs:17:21\n   |\n17 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    let mut s = s.chars().collect::<Vec<char>>();\n    s.reverse();\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<char>>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&char`\n    --> /tmp/tmpfz5tj25b.rs:20:46\n     |\n20\
    \   |     (s.iter().collect(), s == s.iter().rev().collect::<Vec<char>>())\n \
    \    |                                              ^^^^^^^ value of type `Vec<char>`\
    \ cannot be built from `std::iter::Iterator<Item=&char>`\n     |\n     = help:\
    \ the trait `FromIterator<&char>` is not implemented for `Vec<char>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpx4vicaft.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmsenm34q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp68jq3z7w.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpwko0entx.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpzqvccrtt.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpzqvccrtt.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        if !c.is_alphanumeric() {\n   \
    \         result.push(c);\n            continue;\n        }\n        if !c.is_lowercase()\
    \ {\n            result.push(c.to_lowercase().next().unwrap());\n            continue;\n\
    \        }\n        result.push(c);\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_alphanumeric() && !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        if c.is_alphanumeric() && !c.is_lowercase()\
    \ {\n            result.push(c.to_lowercase().next().unwrap());\n            continue;\n\
    \        }\n        result.push(c);\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_alphanumeric() && !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        if c.is_alphanumeric() && !c.is_lowercase()\
    \ {\n            result.push(c.to_lowercase().next().unwrap());\n            continue;\n\
    \        }\n        result.push(c);\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_alphanumeric() && !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        if c.is_alphanumeric() && !c.is_lowercase()\
    \ {\n            result.push(c.to_lowercase().next\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptvtz__16.rs:75:3\n\
    \   |\n13 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n56 |     while let Some(c) = chars.next() {\n   |                       \
    \               - unclosed delimiter\n...\n60 |         if c.is_alphanumeric()\
    \ && !c.is_lowercase() {\n   |                                               \
    \      - this delimiter might not be properly closed...\n61 |             result.push(c.to_lowercase().next\n\
    62 | }\n   | - ...as it matches this but it has different indentation\n...\n75\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmptvtz__16.rs:61:24\n\
    \   |\n13 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n61 |             result.push(c.to_lowercase().next\n\
    \   |                        ^ unclosed delimiter\n62 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0615]: attempted to take value of method `next` on type\
    \ `ToLowercase`\n  --> /tmp/tmptvtz__16.rs:61:42\n   |\n61 |             result.push(c.to_lowercase().next\n\
    \   |                                          ^^^^ method, not a field\n   |\n\
    help: use parentheses to call the method\n   |\n61 |             result.push(c.to_lowercase().next()\n\
    \   |                                              ++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptvtz__16.rs:56:5\n   |\n13 |   fn reverse_delete(s: String,\
    \ c: String) -> (String, bool) {\n   |                                       \
    \       -------------- expected `(String, bool)` because of return type\n...\n\
    56 | /     while let Some(c) = chars.next() {\n57 | |         if c.is_alphanumeric()\
    \ && !c.is_whitespace() && !c.is_alphanumeric() {\n58 | |             continue;\n\
    59 | |         }\n...  |\n74 | |     assert_eq!(candidate(String::from(\"mamma\"\
    ), String::from(\"mia\")), (String::from(\"\"), true));\n75 | | }\n   | |__^ expected\
    \ tuple, found `()`\n   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp8qrrrmdd.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp5qe9wr_e.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp7arg7jro.rs:18:9\n\
    \   |\n18 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp7arg7jro.rs:20:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n20 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpco17vmot.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpco17vmot.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpcetm8dx2.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut chars = s.chars().collect::<Vec<char>>();\n    let mut c_chars =\
    \ c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n    while i < chars.len()\
    \ {\n        if c_chars.contains(&chars[i]) {\n            chars.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let s = chars.iter().collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp2u20has6.rs:15:9\n\
    \   |\n15 |     let mut c_chars = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmp2u20has6.rs:25:9\n   |\n24 |     let s = chars.iter().collect::<String>();\n\
    \   |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n25 |     (s, s == s.chars().rev().collect::<String>())\n \
    \  |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp1s6ujtr9.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in c.chars() {\n        s =\
    \ s.replace(i, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbv28556o.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpbv28556o.rs:19:9\n\
    \   |\n19 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpbv28556o.rs:21:9\n   |\n14 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n21 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    let s = s.chars().collect::<Vec<char>>();\n    let mut i = 0;\n  \
    \  let mut j = s.len() - 1;\n    while i < j {\n        if s[i] != s[j] {\n  \
    \          return (s.iter().collect(), false);\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n    (s.iter().collect(), true)\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4faboufk.rs:20:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpdipoh_1m.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp5o4idt1n.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in 0..c.len() {\n        s\
    \ = s.replace(c.chars().nth(i).unwrap(), \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgifuz11y.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpgifuz11y.rs:19:9\n \
    \  |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n19 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp34lljjvu.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in c.chars() {\n        s =\
    \ s.replace(i, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp3knjzqh1.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmp3knjzqh1.rs:19:9\n\
    \   |\n19 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmp3knjzqh1.rs:21:9\n   |\n14 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n21 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp2jinmwpo.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut chars_c_set = HashSet::new();\n    while\
    \ let Some(ch) = chars_c.next() {\n        chars_c_set.insert(ch);\n    }\n  \
    \  while let Some(ch) = chars.next() {\n        if !chars_c_set.contains(&ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut chars = result.chars();\n\
    \    let mut chars_rev = result.chars().rev();\n    let mut is_palindrome = true;\n\
    \    while let Some(ch) = chars.next() {\n        if ch != chars_rev.next().unwrap()\
    \ {\n            is_palindrome = false;\n            break;\n        }\n    }\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpdbz8l68k.rs:17:27\n   |\n17 |     let mut chars_c_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprl5f83eo.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvzcgd5dq.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgh1ps_qa.rs:20:14\n   |\n20 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpk6smmtu1.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut set = HashSet::new();\n    for ch in chars_c\
    \ {\n        set.insert(ch);\n    }\n    for ch in chars {\n        if !set.contains(&ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_chars\
    \ = result.chars();\n    let mut result_chars_rev = result.chars().rev();\n  \
    \  let mut is_palindrome = true;\n    for (ch1, ch2) in result_chars.zip(result_chars_rev)\
    \ {\n        if ch1 != ch2 {\n            is_palindrome = false;\n           \
    \ break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n  \
    \  let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpxpmhk42t.rs:17:19\n   |\n17 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut c_chars = c.chars();\n    let mut c_set = HashSet::new();\n    while let\
    \ Some(c) = c_chars.next() {\n        c_set.insert(c);\n    }\n    while let Some(c)\
    \ = chars.next() {\n        if !c_set.contains(&c) {\n            result.push(c);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpi_19la8x.rs:17:21\n   |\n17 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4nir43az.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut is_palindrome = true;\n    while let Some(c) = chars.next() {\n        if\
    \ !c.is_ascii_lowercase() {\n            continue;\n        }\n        if c.is_ascii_lowercase()\
    \ && !c.is_ascii_lowercase() {\n            continue;\n        }\n        if c.is_ascii_lowercase()\
    \ && c.is_ascii_lowercase() {\n            continue;\n        }\n        result.push(c);\n\
    \    }\n    let mut chars = result.chars();\n    let mut chars_rev = result.chars().rev();\n\
    \    while let Some(c) = chars.next() {\n        if c != chars_rev.next().unwrap()\
    \ {\n            is_palindrome = false;\n            break;\n        }\n    }\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpfi4g9btc.rs:42:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpet0_0vhg.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmp2515a8sn.rs:20:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n20 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp_uzaupqk.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in 0..c.len() {\n        s\
    \ = s.replace(c.chars().nth(i).unwrap(), \"\");\n    }\n    let mut s_rev = s.clone();\n\
    \    s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcpga6fof.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpcpga6fof.rs:19:9\n\
    \   |\n19 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpcpga6fof.rs:21:9\n   |\n14 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n21 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(ch) = chars.next() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut chars = result.chars();\n    let mut is_palindrome\
    \ = true;\n    while let Some(ch) = chars.next() {\n        if let Some(ch2) =\
    \ chars.next_back() {\n            if ch != ch2 {\n                is_palindrome\
    \ = false;\n                break;\n            }\n        }\n    }\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpiqs_ht4n.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpzcz_c59r.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in c.chars() {\n        s =\
    \ s.replace(i, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpw438awzo.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpw438awzo.rs:19:9\n\
    \   |\n19 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpw438awzo.rs:21:9\n   |\n14 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n21 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp_zvrdu5h.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp2lmg_733.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp2lmg_733.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp2zwq90bj.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphx5iyage.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    for (i, ch) in result.chars().enumerate() {\n        if ch != result.chars().rev().nth(i).unwrap()\
    \ {\n            is_palindrome = false;\n            break;\n        }\n    }\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp9pmzkzbg.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpe7vjzmkf.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpa_chj3ep.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpfi4g34p5.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp5ufpien7.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ c_chars: HashSet<char> = c.chars().collect();\n    while let Some(c) = chars.next()\
    \ {\n        if !c_chars.contains(&c) {\n            result.push(c);\n       \
    \ }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpk26gtxup.rs:16:18\n\
    \   |\n16 |     let c_chars: HashSet<char> = c.chars().collect();\n   |      \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|&x|\
    \ !chars_c.contains(&x));\n    for i in chars {\n        result.push(i);\n   \
    \ }\n    let mut chars_result = result.chars().collect::<Vec<char>>();\n    chars_result.reverse();\n\
    \    let mut result_reverse = String::new();\n    for i in chars_result {\n  \
    \      result_reverse.push(i);\n    }\n    (result, result == result_reverse)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjflxkc6t.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpjflxkc6t.rs:27:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n27 |     (result,\
    \ result == result_reverse)\n   |      ------  ^^^^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpa36wbb1g.rs:18:9\n\
    \   |\n18 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpa36wbb1g.rs:20:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n20 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp5747wit6.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmptkkbpkmd.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpi25913nz.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmputyf846e.rs:18:14\n\
    \   |\n14 |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    18 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut is_palindrome = true;\n    while let Some(ch) = chars.next() {\n       \
    \ if !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n    let\
    \ mut chars = result.chars();\n    while let Some(ch) = chars.next() {\n     \
    \   if ch != chars.next_back().unwrap() {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp6ln1uoev.rs:24:36\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpa_ejb_pg.rs:20:14\n   |\n20 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpcsffyvul.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_alphabetic() {\n            continue;\n\
    \        }\n        if !c.is_uppercase() {\n            result.push(c);\n    \
    \    }\n    }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_alphabetic() {\n   \
    \         continue;\n        }\n        if !c.is_lowercase() {\n            result.push(c);\n\
    \        }\n    }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_alphabetic() {\n   \
    \         continue;\n        }\n        if !c.is_numeric() {\n            result.push(c);\n\
    \        }\n    }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_alphabetic() {\n   \
    \         continue;\n        }\n        if !c.is_whitespace() {\n            result.push(c);\n\
    \        }\n    }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_alphabetic() {\n   \
    \         continue;\n        }\n        if !c.is_alphanumeric() {\n          \
    \  result.push(c);\n        }\n    }\n    let mut chars = result.chars();\n  \
    \  let mut result = String::new();\n    while let Some(c) = chars.next() {\n \
    \       if !c.is_alphabetic() {\n            continue;\n        }\n        if\
    \ !c.is_alphabetic() {\n            result.push(c);\n        }\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=` or `|`, found `}`\n  --> /tmp/tmpxqqe91ly.rs:77:1\n\
    \   |\n76 |     while let Some(c)\n   |     -----            - expected one of\
    \ `=` or `|`\n   |     |\n   |     while parsing the condition of this `while`\
    \ expression\n77 | }\n   | ^ unexpected token\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmke3q_om.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in c.chars() {\n        s =\
    \ s.replace(i, \"\");\n    }\n    (s, is_palindrome(&s))\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2jaflx1i.rs:19:9\n   |\n19 |     (s, is_palindrome(&s))\n   |      \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut c_set = HashSet::new();\n    while let\
    \ Some(c) = chars_c.next() {\n        c_set.insert(c);\n    }\n    while let Some(c)\
    \ = chars.next() {\n        if !c_set.contains(&c) {\n            result.push(c);\n\
    \        }\n    }\n    let mut result_chars = result.chars();\n    let mut result_chars_rev\
    \ = result.chars().rev();\n    let mut is_palindrome = true;\n    while let Some(c)\
    \ = result_chars.next() {\n        if let Some(c_rev) = result_chars_rev.next()\
    \ {\n            if c != c_rev {\n                is_palindrome = false;\n   \
    \             break;\n            }\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp53egiqlm.rs:17:21\n   |\n17 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpiv_b9r85.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut is_palindrome = true;\n    while let Some(ch) = chars.next() {\n       \
    \ if !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n    let\
    \ mut chars = result.chars();\n    while let Some(ch) = chars.next() {\n     \
    \   if let Some(ch2) = chars.next_back() {\n            if ch != ch2 {\n     \
    \           is_palindrome = false;\n                break;\n            }\n  \
    \      }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmzfnagc1.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpw_hbq14l.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_ascii_lowercase() {\n       \
    \     continue;\n        }\n        result.push(c);\n    }\n    let mut chars\
    \ = c.chars();\n    while let Some(c) = chars.next() {\n        if !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        result = result.replace(c, \"\"\
    );\n    }\n    let mut chars = result.chars();\n    let mut result_rev = String::new();\n\
    \    while let Some(c) = chars.next_back() {\n        result_rev.push(c);\n  \
    \  }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp0rehvlo6.rs:34:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n34 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpuf2si7sl.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpgao65wi2.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpkzfiscr3.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    let mut i = 0;\n    let mut j = result.len() - 1;\n    while i\
    \ < j {\n        if result.chars().nth(i) != result.chars().nth(j) {\n       \
    \     is_palindrome = false;\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9t2frb1a.rs:22:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpfhdp4ecn.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    let result_str = result.chars().collect::<Vec<char>>();\n\
    \    let is_palindrome = result_str.iter().eq(result_str.iter().rev());\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmplmbfjaod.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    let mut s = s.chars().collect::<Vec<char>>();\n    s.reverse();\n\
    \    (s.iter().collect(), s == s.iter().rev().collect::<Vec<char>>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&char`\n    --> /tmp/tmpjfe83zm9.rs:20:46\n     |\n20\
    \   |     (s.iter().collect(), s == s.iter().rev().collect::<Vec<char>>())\n \
    \    |                                              ^^^^^^^ value of type `Vec<char>`\
    \ cannot be built from `std::iter::Iterator<Item=&char>`\n     |\n     = help:\
    \ the trait `FromIterator<&char>` is not implemented for `Vec<char>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpnazxfcd9.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr7q6pwn8.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpk6s6105b.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s_chars: Vec<char> = s.chars().collect();\n    let c_chars: Vec<char>\
    \ = c.chars().collect();\n    let mut i = 0;\n    while i < s_chars.len() {\n\
    \        if c_chars.contains(&s_chars[i]) {\n            s_chars.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let s_chars_reversed:\
    \ Vec<char> = s_chars.iter().rev().map(|x| *x).collect();\n    let is_palindrome\
    \ = s_chars == s_chars_reversed;\n    (s_chars.into_iter().collect(), is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpklo_40gb.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut c_chars = c.chars().collect::<Vec<char>>();\n    c_chars.sort();\n\
    \    chars.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < chars.len()\
    \ && j < c_chars.len() {\n        if chars[i] == c_chars[j] {\n            i +=\
    \ 1;\n        } else if chars[i] < c_chars[j] {\n            result.push(chars[i]);\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    while i < chars.len() {\n        result.push(chars[i]);\n        i += 1;\n\
    \    }\n    (result, is_palindrome(&result))\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgsuuyuhe.rs:35:14\n   |\n35 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpu_hawnf5.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpq5j111qs.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpsjmh362z.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpa5_5zo3g.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpe3m8rtvc.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut new_s = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            new_s.push(ch);\n        }\n    }\n    let is_palindrome = new_s\
    \ == new_s.chars().rev().collect::<String>();\n    (new_s, is_palindrome)\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpnv4zxana.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let c_chars = c.chars().collect::<Vec<char>>();\n    for i in 0..chars.len()\
    \ {\n        if !c_chars.contains(&chars[i]) {\n            result.push(chars[i]);\n\
    \        }\n    }\n    let mut is_palindrome = true;\n    let mut result_chars\
    \ = result.chars().collect::<Vec<char>>();\n    for i in 0..result_chars.len()\
    \ / 2 {\n        if result_chars[i] != result_chars[result_chars.len() - i - 1]\
    \ {\n            is_palindrome = false;\n            break;\n        }\n    }\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|&x|\
    \ !chars_c.contains(&x));\n    for i in chars {\n        result.push(i);\n   \
    \ }\n    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpy4pbaftf.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpy4pbaftf.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpgctwoy5i.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpuhmb48li.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let mut chars_c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n \
    \   while i < chars.len() {\n        if chars_c.contains(&chars[i]) {\n      \
    \      chars.remove(i);\n        } else {\n            i += 1;\n        }\n  \
    \  }\n    for i in chars {\n        result.push(i);\n    }\n    let mut is_palindrome\
    \ = true;\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmprijwzx9t.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpsevboi1e.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut is_palindrome = true;\n    let\
    \ mut chars = s.chars().collect::<Vec<char>>();\n    let mut chars_c = c.chars().collect::<Vec<char>>();\n\
    \    chars_c.sort();\n    chars.sort();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < chars.len() && j < chars_c.len() {\n        if chars[i] == chars_c[j]\
    \ {\n            i += 1;\n        } else if chars[i] < chars_c[j] {\n        \
    \    result.push(chars[i]);\n            i += 1;\n        } else {\n         \
    \   j += 1;\n        }\n    }\n    while i < chars.len() {\n        result.push(chars[i]);\n\
    \        i += 1;\n    }\n    let mut chars_result = result.chars().collect::<Vec<char>>();\n\
    \    chars_result.reverse();\n    for i in 0..chars_result.len() {\n        if\
    \ chars_result[i] != result.chars().nth(i).unwrap() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"ccdde\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmp1f9f_p9o.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_ascii_lowercase() {\n       \
    \     continue;\n        }\n        if !c.is_ascii_lowercase() {\n           \
    \ continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_lowercase() && !c.is_ascii_lowercase()\
    \ {\n            continue;\n        }\n        if c.is_ascii_\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfjd2ifi6.rs:73:3\n\
    \   |\n13 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n16 |     while let Some(c) = chars.next() {\n   |                       \
    \               - this delimiter might not be properly closed...\n...\n60 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n73 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpfjd2ifi6.rs:60:1\n\
    \   |\n59 |         if c.is_ascii_\n   |         -- this `if` expression has a\
    \ condition, but no block\n60 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfjd2ifi6.rs:13:44\n   |\n13 | fn reverse_delete(s: String,\
    \ c: String) -> (String, bool) {\n   |    --------------                     \
    \     ^^^^^^^^^^^^^^ expected tuple, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \  expected tuple `(String, bool)`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpspz9j7fv.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmphzyziy4j.rs:20:14\n   |\n20 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut chars = s.chars().collect::<Vec<char>>();\n    let mut c_chars =\
    \ c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n    while i < chars.len()\
    \ {\n        if c_chars.contains(&chars[i]) {\n            chars.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let mut j = 0;\n\
    \    let mut k = chars.len() - 1;\n    while j < k {\n        if chars[j] != chars[k]\
    \ {\n            return (chars.into_iter().collect(), false);\n        }\n   \
    \     j += 1;\n        k -= 1;\n    }\n    (chars.into_iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp24hwt5h4.rs:25:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in 0..c.len() {\n        s\
    \ = s.replace(c.chars().nth(i).unwrap(), \"\");\n    }\n    let mut result = String::new();\n\
    \    for i in 0..s.len() {\n        result.push(s.chars().nth(s.len() - i - 1).unwrap());\n\
    \    }\n    (result, s == result)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp7qi3dod7.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp7qi3dod7.rs:23:19\n\
    \   |\n19 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n23 |     (result, s == result)\n   |      ------       ^^^^^^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut c_chars = c.chars();\n    let mut c_set = HashSet::new();\n    while let\
    \ Some(c) = c_chars.next() {\n        c_set.insert(c);\n    }\n    while let Some(c)\
    \ = chars.next() {\n        if !c_set.contains(&c) {\n            result.push(c);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpq_6r0mjj.rs:17:21\n   |\n17 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpy2lk82i9.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut chars_c_set = HashSet::new();\n    while\
    \ let Some(c) = chars_c.next() {\n        chars_c_set.insert(c);\n    }\n    while\
    \ let Some(c) = chars.next() {\n        if !chars_c_set.contains(&c) {\n     \
    \       result.push(c);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmphllu2aj1.rs:17:27\n   |\n17 |     let mut chars_c_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_palindrome` in this scope\n  --> /tmp/tmphllu2aj1.rs:26:14\n\
    \   |\n26 |     (result, is_palindrome(&result))\n   |              ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    while\
    \ let Some(c) = chars.next() {\n        if !c.is_ascii_lowercase() {\n       \
    \     continue;\n        }\n        if !c.is_ascii_lowercase() || c.is_ascii_lowercase()\
    \ && !c.is_ascii_lowercase() {\n            result.push(c);\n        }\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `c`\n  --> /tmp/tmpljp35ejz.rs:13:30\n   |\n\
    13 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                       ^ help: if this is intentional, prefix it with an underscore:\
    \ `_c`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `result`\n  --> /tmp/tmpljp35ejz.rs:24:14\n   |\n14 |\
    \     let mut result = String::new();\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    24 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpb5v5url0.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp6ks20t9x.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut chars = s.chars().collect::<Vec<char>>();\n    let mut chars_c =\
    \ c.chars().collect::<Vec<char>>();\n    chars.retain(|x| !chars_c.contains(x));\n\
    \    let mut result = String::new();\n    for i in chars {\n        result.push(i);\n\
    \    }\n    let mut result_rev = String::new();\n    for i in chars.iter().rev()\
    \ {\n        result_rev.push(*i);\n    }\n    (result, result == result_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpyozkxp0l.rs:15:9\n\
    \   |\n15 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `chars`\n   --> /tmp/tmpyozkxp0l.rs:22:14\n    |\n14  |     let mut chars\
    \ = s.chars().collect::<Vec<char>>();\n    |         --------- move occurs because\
    \ `chars` has type `Vec<char>`, which does not implement the `Copy` trait\n...\n\
    18  |     for i in chars {\n    |              ----- `chars` moved due to this\
    \ implicit call to `.into_iter()`\n...\n22  |     for i in chars.iter().rev()\
    \ {\n    |              ^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `chars`\n\
    \    = note: borrow occurs due to deref coercion to `[char]`\nhelp: consider iterating\
    \ over a slice of the `Vec<char>`'s content to avoid moving into the `for` loop\n\
    \    |\n18  |     for i in &chars {\n    |              +\n\nerror[E0382]: borrow\
    \ of moved value: `result`\n  --> /tmp/tmpyozkxp0l.rs:25:14\n   |\n17 |     let\
    \ mut result = String::new();\n   |         ---------- move occurs because `result`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n25 |    \
    \ (result, result == result_rev)\n   |      ------  ^^^^^^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpw_2vjykr.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let mut rev = res.clone();\n\
    \    rev.chars().rev();\n    (res, res == rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpb2c2pvpr.rs:20:9\n\
    \   |\n20 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpb2c2pvpr.rs:22:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n22 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpvq8c8xcp.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0174o6rm.rs:20:14\n   |\n20 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmyx1ebix.rs:18:14\n\
    \   |\n14 |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    18 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpzskgcjrx.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    chars.iter().for_each(|x| result.push(*x));\n  \
    \  (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpr1v6p4u5.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpr1v6p4u5.rs:19:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n19 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp91alxdtc.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s_chars: Vec<char> = s.chars().collect();\n    let c_chars: Vec<char>\
    \ = c.chars().collect();\n    let mut i = 0;\n    while i < s_chars.len() {\n\
    \        if c_chars.contains(&s_chars[i]) {\n            s_chars.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let s_chars_rev:\
    \ Vec<char> = s_chars.iter().rev().cloned().collect();\n    (s_chars.iter().collect(),\
    \ s_chars == s_chars_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp72j9q6s_.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp0jja5lyq.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars();\n    let\
    \ mut chars_c = c.chars();\n    let mut chars_c_set = HashSet::new();\n    while\
    \ let Some(ch) = chars_c.next() {\n        chars_c_set.insert(ch);\n    }\n  \
    \  while let Some(ch) = chars.next() {\n        if !chars_c_set.contains(&ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut chars = result.chars();\n\
    \    let mut chars_rev = result.chars().rev();\n    let mut is_palindrome = true;\n\
    \    while let Some(ch) = chars.next() {\n        if ch != chars_rev.next().unwrap()\
    \ {\n            is_palindrome = false;\n            break;\n        }\n    }\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmplwnswm_u.rs:17:27\n   |\n17 |     let mut chars_c_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
