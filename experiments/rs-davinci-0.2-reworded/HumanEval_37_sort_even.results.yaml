name: HumanEval_37_sort_even
language: rs
results:
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[even_indices[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpx9bkhtib.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp3y42wvn2.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpf4wodplt.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n        \
    \    even_indicies.push(i);\n        } else {\n            odd_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp34ufqihf.rs:24:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n20  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpx2il03pm.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpfc1ydq04.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp_bimchh5.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    for i in (0..l.len()).step_by(2) {\n        let mut j =\
    \ i + 1;\n        while j < l.len() {\n            if l[i] > l[j] {\n        \
    \        l.swap(i, j);\n            }\n            j += 2;\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, -5, 3, -3, 3, 1, 9, 2, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp2qtyrus2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpxtf9spne.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpcqoln_ei.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpg7vb5fu0.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpg2ogw_ke.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9oqozzgy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for (index, value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            even_indicies.push(index);\n        }\n    }\n    for index in even_indicies\
    \ {\n        l_prime[index] = l[index];\n    }\n    l_prime\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5sjjt3_8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indicies: Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(*x);\n        } else\
    \ {\n            odd_indicies.push(*x);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (i, x) in even_indicies.iter().enumerate() {\n        l[i * 2] = *x;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        }\n \
    \   }\n    let mut even_indices_values = Vec::new();\n    for i in even_indices\
    \ {\n        even_indices_values.push(l[i]);\n    }\n    even_indices_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[even_indices[i]] = even_indices_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpzl8c0052.rs:21:17\n\
    \    |\n10  |     let mut even_indices = Vec::new();\n    |         ----------------\
    \ move occurs because `even_indices` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indices {\n    |            \
    \  ------------ `even_indices` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indices.len() {\n    |                 ^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indices`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[even_indices[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpfsin214k.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpng9uyb5l.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        let mut\
    \ j = i + 1;\n        while j < l.len() {\n            if l[i] > l[j] {\n    \
    \            let temp = l[i];\n                l[i] = l[j];\n                l[j]\
    \ = temp;\n            }\n            j += 2;\n        }\n        i += 2;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, -5, 3, -3, 3, 1, 9, 2, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp6cfl2ucb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    let temp = l[i];\n    \
    \                l[i] = l[j];\n                    l[j] = temp;\n            \
    \    }\n                j += 1;\n            }\n        }\n        i += 1;\n \
    \   }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpy9oqldop.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp7c7vo4t5.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp5zd0s0ua.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp52hswkmt.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpmywszl58.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp0avo294u.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<usize> = Vec::new();\n\
    \    let mut even_values: Vec<isize> = Vec::new();\n    for (i, v) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n            even_values.push(*v);\n\
    \        }\n    }\n    even_values.sort();\n    for (i, v) in even_indices.iter().enumerate()\
    \ {\n        l_prime[*v] = even_values[i];\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l.sort();\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp27pi2h2l.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp5soppwe3.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    for i in (0..l.len()).step_by(2) {\n        let mut j =\
    \ i + 1;\n        while j < l.len() {\n            if l[i] > l[j] {\n        \
    \        l.swap(i, j);\n            }\n            j += 2;\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, -5, 3, -3, 3, 1, 9, 2, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpnug8knem.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpo_1qk22p.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even.push(*x);\n        } else {\n            odd.push(*x);\n        }\n \
    \   }\n    even.sort();\n    for (i, x) in even.iter().enumerate() {\n       \
    \ l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = vec![];\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = vec![];\n    for i in\
    \ even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpux48suea.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = vec![];\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            even_indices.push(l[i]);\n        } else {\n\
    \            odd_indices.push(l[i]);\n        }\n    }\n    even_indices.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[i * 2] = even_indices[i];\n \
    \   }\n    for i in 0..odd_indices.len() {\n        l[i * 2 + 1] = odd_indices[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut evens = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            evens.push(l[i]);\n        }\n    }\n  \
    \  evens.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n       \
    \     l[i] = evens[i / 2];\n        }\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    l.sort_by(|a, b| a.cmp(b));\n    l\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpqok6u1w8.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptmyu9gzd.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(i, _)| i).collect::<Vec<usize>>();\n    even_indices.sort_by(|a,\
    \ b| l[*a].cmp(&l[*b]));\n    for i in 0..even_indices.len() {\n        l.swap(i\
    \ * 2, even_indices[i]);\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 3, -5, 2, -3, 3, 123, 0, 5, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmphs19vom5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for\
    \ (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indicies.push(*x);\n\
    \        }\n    }\n    even_indicies.sort();\n    for (i, x) in even_indicies.iter().enumerate()\
    \ {\n        l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptrdhecex.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  if i % 2 == 0 {\n            v[i] = v[i + 1];\n        }\n        i += 2;\n\
    \    }\n    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp70bu_dr1.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    let mut even_values: Vec<isize> = Vec::new();\n    for (i, &v) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n           \
    \ even_values.push(v);\n        }\n    }\n    even_values.sort();\n    for (i,\
    \ &v) in even_indicies.iter().enumerate() {\n        l_prime[*v] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp_wjph9k7.rs:20:17\n\
    \   |\n20 |         l_prime[*v] = even_values[i];\n   |                 ^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp8pe7fj5d.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(i, _)| i).collect::<Vec<usize>>();\n    even_indices.sort_by(|a,\
    \ b| l[*a].cmp(&l[*b]));\n    for (i, j) in even_indices.iter().enumerate() {\n\
    \        l_prime[i * 2] = l[*j];\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ (i, v) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indicies.push(v);\n\
    \        }\n    }\n    even_indicies.sort();\n    for (i, v) in even_indicies.iter().enumerate()\
    \ {\n        l_prime[i * 2] = *v;\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk7hbx5t5.rs:18:26\n   |\n\
    18 |         l_prime[i * 2] = *v;\n   |         --------------   ^^ expected `isize`,\
    \ found `&isize`\n   |         |\n   |         expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |         l_prime[i\
    \ * 2] = **v;\n   |                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  if i % 2 == 0 {\n            v[i] = v[i + 1];\n        }\n        i += 2;\n\
    \    }\n    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpec7abwz9.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_sorted = l.clone();\n    even_sorted.sort();\n    let mut l_prime\
    \ = l.clone();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n         \
    \   l_prime[i] = even_sorted[i / 2];\n        }\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp46plnz1d.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ - 1 {\n            if l[even_indicies[j]] > l[even_indicies[j + 1]] {\n    \
    \            l.swap(even_indicies[j], even_indicies[j + 1]);\n            }\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   odds.push(*x);\n        } else {\n            evens.push(*x);\n        }\n\
    \    }\n    evens.sort();\n    for (i, x) in evens.iter().enumerate() {\n    \
    \    l[i * 2 + 1] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp4owigmhm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut result = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..result.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in even_indicies {\n        let mut temp = result[i];\n\
    \        for j in i..result.len() {\n            if result[j] < temp {\n     \
    \           temp = result[j];\n                result[j] = result[i];\n      \
    \          result[i] = temp;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvjycrlyl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpuxkkz3n8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpsa0frxvd.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpe4d33nc4.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp7e487unh.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp3p9rnf1e.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = vec![];\n    let mut odd_indicies\
    \ = vec![];\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        } else {\n            odd_indicies.push(i);\n        }\n    }\n    even_indicies.sort_by(|a,\
    \ b| l[*a].cmp(&l[*b]));\n    for i in 0..even_indicies.len() {\n        l.swap(even_indicies[i],\
    \ odd_indicies[i]);\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpm3ohkw_q.rs:21:34\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp0kdh6ec6.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_even = l.clone();\n    let mut l_odd = l;\n    l_even.retain(|x| x\
    \ % 2 == 0);\n    l_odd.retain(|x| x % 2 != 0);\n    l_even.sort();\n    l_odd.append(&mut\
    \ l_even);\n    l_odd\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpocah6ich.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp6y4qbqw5.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpxgnjp8u1.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpdschdg9t.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in even_indicies {\n        let mut even_values =\
    \ Vec::new();\n        for j in even_indicies.clone() {\n            even_values.push(l[j]);\n\
    \        }\n        even_values.sort();\n        for (j, k) in even_indicies.clone().iter().enumerate()\
    \ {\n            l_prime[*k] = even_values[j];\n        }\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmp2aw0p3ng.rs:16:9\n   |\n16\
    \ |     for i in even_indicies {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `even_indicies`\n   -->\
    \ /tmp/tmp2aw0p3ng.rs:18:18\n    |\n10  |     let mut even_indicies = Vec::new();\n\
    \    |         ----------------- move occurs because `even_indicies` has type\
    \ `Vec<usize>`, which does not implement the `Copy` trait\n...\n16  |     for\
    \ i in even_indicies {\n    |              ------------- `even_indicies` moved\
    \ due to this implicit call to `.into_iter()`\n17  |         let mut even_values\
    \ = Vec::new();\n18  |         for j in even_indicies.clone() {\n    |       \
    \           ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    let mut even_vec = Vec::new();\n    for (i,\
    \ item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_vec.push(*item);\n\
    \        }\n    }\n    even_vec.sort();\n    for (i, item) in even_vec.iter().enumerate()\
    \ {\n        new_vec[i * 2] = *item;\n    }\n    new_vec\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpci1x0mzz.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even.push(*x);\n        } else {\n            odd.push(*x);\n        }\n \
    \   }\n    even.sort();\n    for (i, x) in even.iter().enumerate() {\n       \
    \ l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in i..even_indicies.len()\
    \ {\n            if l[even_indicies[i]] > l[even_indicies[j]] {\n            \
    \    let temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp75y80mmh.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[even_indices[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpvp6oeqsn.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut evens = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, &x)|\
    \ x).collect::<Vec<isize>>();\n    evens.sort();\n    let mut res = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   res.push(evens.remove(0));\n        } else {\n            res.push(*x);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  if i % 2 == 0 {\n            let mut j = i + 1;\n            while j < v.len()\
    \ {\n                if v[j] < v[i] {\n                    let temp = v[i];\n\
    \                    v[i] = v[j];\n                    v[j] = temp;\n        \
    \        }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8aomjtfi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l_prime[even_indices[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpxxh50fru.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in i..even_indicies.len()\
    \ {\n            if l[even_indicies[i]] > l[even_indicies[j]] {\n            \
    \    let temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ (i, item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indices.push(*item);\n\
    \        }\n    }\n    even_indices.sort();\n    for (i, item) in even_indices.iter().enumerate()\
    \ {\n        l[i * 2] = *item;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even.push(*x);\n        } else {\n            odd.push(*x);\n        }\n \
    \   }\n    even.sort();\n    for (i, x) in even.iter().enumerate() {\n       \
    \ l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for (index, _) in l.iter().enumerate() {\n        if index % 2 == 0 {\n \
    \           even_indicies.push(index);\n        }\n    }\n    for index in even_indicies\
    \ {\n        l_prime[index] = l[index];\n    }\n    l_prime\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpul86m5ij.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        }\n \
    \   }\n    let mut even_values = Vec::new();\n    for i in even_indices {\n  \
    \      even_values.push(l[i]);\n    }\n    even_values.sort();\n    for (i, v)\
    \ in even_values.iter().enumerate() {\n        l[even_indices[i]] = *v;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpwk4jm1vt.rs:22:11\n\
    \    |\n10  |     let mut even_indices = Vec::new();\n    |         ----------------\
    \ move occurs because `even_indices` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indices {\n    |            \
    \  ------------ `even_indices` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indices[i]] = *v;\n    |           ^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `even_indices`\nhelp: consider iterating over a\
    \ slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n  \
    \  |\n17  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        let mut temp = l[i];\n        for\
    \ j in i..l.len() {\n            if l[j] < temp {\n                l[i] = l[j];\n\
    \                l[j] = temp;\n                temp = l[i];\n            }\n \
    \       }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvocgo_t3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  if i % 2 == 0 {\n            v[i] = v[i + 1];\n        }\n        i += 2;\n\
    \    }\n    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpkkyd879c.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l_prime[even_indices[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpitl_pd52.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ - 1 {\n            if l_prime[even_indicies[j]] > l_prime[even_indicies[j +\
    \ 1]] {\n                let temp = l_prime[even_indicies[j]];\n             \
    \   l_prime[even_indicies[j]] = l_prime[even_indicies[j + 1]];\n             \
    \   l_prime[even_indicies[j + 1]] = temp;\n            }\n        }\n    }\n \
    \   l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indices: Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(*x);\n        } else\
    \ {\n            odd_indices.push(*x);\n        }\n    }\n    even_indices.sort();\n\
    \    for (i, x) in even_indices.iter().enumerate() {\n        l[i * 2] = *x;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indicies.push(i);\n        }\n    }\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for i in even_indicies {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for (i, v) in even_values.iter().enumerate()\
    \ {\n        l_prime[even_indicies[i]] = *v;\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp8okyg0a0.rs:22:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |         l_prime[even_indicies[i]] = *v;\n\
    \    |                 ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for (i, item) in l.iter().enumerate() {\n        if i % 2\
    \ == 0 {\n            even_indicies.push(item);\n        } else {\n          \
    \  odd_indicies.push(item);\n        }\n    }\n    even_indicies.sort();\n   \
    \ for (i, item) in even_indicies.iter().enumerate() {\n        l[i * 2] = *item;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_llpkhiu.rs:21:20\n   |\n\
    21 |         l[i * 2] = *item;\n   |         --------   ^^^^^ expected `isize`,\
    \ found `&isize`\n   |         |\n   |         expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |         l[i\
    \ * 2] = **item;\n   |                    +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpr2m86o6b.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in i..even_indicies.len()\
    \ {\n            if l[even_indicies[i]] > l[even_indicies[j]] {\n            \
    \    let temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpmn67uwtg.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp9ziyixjc.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpwyijbzht.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_indices_sorted = even_indices.clone();\n \
    \   even_indices_sorted.sort();\n    for i in 0..even_indices.len() {\n      \
    \  l[even_indices[i]] = l[even_indices_sorted[i]];\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5t7zwgrp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp1s6nxm5j.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpm1jsjqa4.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpe455ek6t.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpyhuy70n0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_indicies_sorted = even_indicies.clone();\n    even_indicies_sorted.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l.swap(even_indicies[i], even_indicies_sorted[i]);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpjvunh_7k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpe7fkn6f_.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp__5eetvw.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    let temp = l[i];\n    \
    \                l[i] = l[j];\n                    l[j] = temp;\n            \
    \    }\n                j += 1;\n            }\n        }\n        i += 1;\n \
    \   }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpn80x8495.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut sorted = l.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result.push(l[i]);\n\
    \        } else {\n            result.push(sorted[i]);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbay1coew.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp46xjobwi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptv7ptqph.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpwzhy25df.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpbhblkxdt.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l.sort();\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpiazusisq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ {\n            if l_prime[even_indicies[i]] < l_prime[even_indicies[j]] {\n\
    \                let temp = l_prime[even_indicies[i]];\n                l_prime[even_indicies[i]]\
    \ = l_prime[even_indicies[j]];\n                l_prime[even_indicies[j]] = temp;\n\
    \            }\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut evens = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            evens.push(*x);\n        }\n    }\n\
    \    evens.sort();\n    for (i, x) in evens.iter().enumerate() {\n        l[i\
    \ * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpyas58phx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpgvjsp667.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = l.iter().enumerate().filter(|&(i, _)| i %\
    \ 2 == 0).map(|(_, &x)| x).collect::<Vec<_>>();\n    even.sort();\n    for (i,\
    \ &x) in even.iter().enumerate() {\n        l[i * 2] = x;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpd514vwf7.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ {\n            if l_prime[even_indicies[i]] < l_prime[even_indicies[j]] {\n\
    \                let temp = l_prime[even_indicies[i]];\n                l_prime[even_indicies[i]]\
    \ = l_prime[even_indicies[j]];\n                l_prime[even_indicies[j]] = temp;\n\
    \            }\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        } else {\n\
    \            odd_indicies.push(l[i]);\n        }\n    }\n    even_indicies.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[i * 2] = even_indicies[i];\n\
    \    }\n    for i in 0..odd_indicies.len() {\n        l[i * 2 + 1] = odd_indicies[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpvj14nwdf.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<isize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l_prime[i] = even_indicies[i / 2];\n       \
    \ }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpu874kc4b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmphgbyanhq.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpdfbrhool.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpmh5yhtu1.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpxw9pyvu5.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even.push(l[i]);\n        }\n    }\n   \
    \ even.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n         \
    \   l[i] = even[i / 2];\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpvgecxto9.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp07sa1qfn.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        let mut\
    \ j = i + 1;\n        while j < l.len() {\n            if l[i] > l[j] {\n    \
    \            let tmp = l[i];\n                l[i] = l[j];\n                l[j]\
    \ = tmp;\n            }\n            j += 2;\n        }\n        i += 2;\n   \
    \ }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, -5, 3, -3, 3, 1, 9, 2, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmptmuzzqrx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for (i, v) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indicies.push(*v);\n        } else {\n            odd_indicies.push(*v);\n\
    \        }\n    }\n    even_indicies.sort();\n    let mut result = Vec::new();\n\
    \    for (i, v) in even_indicies.iter().enumerate() {\n        result.push(*v);\n\
    \        result.push(odd_indicies[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp7198h19q.rs:22:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ - 1 {\n            if l[even_indicies[j]] > l[even_indicies[j + 1]] {\n    \
    \            l.swap(even_indicies[j], even_indicies[j + 1]);\n            }\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpqh9ce2mq.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        }\n \
    \   }\n    let mut even_values = Vec::new();\n    for i in even_indices {\n  \
    \      even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in 0..even_values.len()\
    \ {\n        l[even_indices[i]] = even_values[i];\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpl_elpk5m.rs:22:11\n\
    \    |\n10  |     let mut even_indices = Vec::new();\n    |         ----------------\
    \ move occurs because `even_indices` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indices {\n    |            \
    \  ------------ `even_indices` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indices[i]] = even_values[i];\n    |           ^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indices`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<isize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l_prime[i] = even_indicies[i as usize / 2];\n\
    \        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpmm0thjm8.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut evens = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            evens.push(l[i]);\n        }\n    }\n  \
    \  evens.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n       \
    \     l[i] = evens[i / 2];\n        }\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = (0..l.len()).filter(|x|\
    \ x % 2 == 0).collect();\n    even_indices.sort_by_key(|&x| l[x]);\n    for i\
    \ in 0..even_indices.len() {\n        l.swap(i * 2, even_indices[i]);\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 3, -5, 2, -3, 3, 123, 0, 5, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpdtur3ux8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpy15uyytm.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpoufjvmzk.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmps_iuf_uh.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpgn518pbj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3tw2b8gu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(i, _)| i).collect::<Vec<usize>>();\n    even_indicies.sort_by(|a,\
    \ b| l[*a].cmp(&l[*b]));\n    for (i, j) in even_indicies.iter().enumerate() {\n\
    \        l_prime[i * 2] = l[*j];\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpo7a15wev.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = l.clone();\n    let mut even_vec = Vec::new();\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            even_vec.push(l[i]);\n\
    \        }\n    }\n    even_vec.sort();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            new_vec[i] = even_vec[i / 2];\n        }\n    }\n\
    \    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut new_vec = Vec::new();\n    let mut even_vec = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            new_vec.push(*x);\n\
    \        } else {\n            even_vec.push(*x);\n        }\n    }\n    even_vec.sort();\n\
    \    for (i, x) in even_vec.iter().enumerate() {\n        new_vec.insert(i * 2\
    \ + 1, *x);\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpy787rwbx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    for i in even_indices {\n        l_prime[i] = l[i];\n \
    \   }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp017rby29.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_indices_sorted = even_indices.clone();\n \
    \   even_indices_sorted.sort();\n    for i in 0..even_indices.len() {\n      \
    \  l.swap(even_indices[i], even_indices_sorted[i]);\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpsmyfyymb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indices: Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(*x);\n        } else\
    \ {\n            odd_indices.push(*x);\n        }\n    }\n    even_indices.sort();\n\
    \    for (i, x) in even_indices.iter().enumerate() {\n        l[i * 2] = *x;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l_prime[even_indices[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmp6ru3z4x9.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp748ndn_j.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ {\n            if l_prime[even_indicies[i]] < l_prime[even_indicies[j]] {\n\
    \                let temp = l_prime[even_indicies[i]];\n                l_prime[even_indicies[i]]\
    \ = l_prime[even_indicies[j]];\n                l_prime[even_indicies[j]] = temp;\n\
    \            }\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = l[i + 1];\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpm3z48n0r.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpsoyd_jnc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpy9y_4m_c.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<isize> = Vec::new();\n\
    \    for (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indices.push(i as isize);\n        }\n    }\n    for i in even_indices\
    \ {\n        let mut temp = l[i as usize];\n        for j in even_indices.clone()\
    \ {\n            if l[j as usize] < temp {\n                temp = l[j as usize];\n\
    \            }\n        }\n        l_prime[i as usize] = temp;\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmp67lzqh8o.rs:18:18\n\
    \    |\n10  |     let mut even_indices: Vec<isize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n16  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n17  |         let mut temp = l[i as usize];\n18  | \
    \        for j in even_indices.clone() {\n    |                  ^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indices`\nhelp: consider iterating over\
    \ a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n16  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_sorted = l.clone();\n    l_sorted.sort();\n    let mut l_sorted_even\
    \ = Vec::new();\n    for i in 0..l_sorted.len() {\n        if i % 2 == 0 {\n \
    \           l_sorted_even.push(l_sorted[i]);\n        }\n    }\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 1 {\n            l_sorted_even.push(l[i]);\n        }\n\
    \    }\n    l_sorted_even\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpy5t8tws2.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpc_uu3kpt.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmppi9yp4pq.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp6z6sfyns.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    even_indicies.sort_by(|a, b| l[*a].cmp(&l[*b]));\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = l[even_indicies[i]];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7vwxf7vk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    for i in (0..v.len()).step_by(2) {\n        v[i]\
    \ = l[i];\n    }\n    for i in (1..v.len()).step_by(2) {\n        v[i] = l[i];\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_ud_dfcm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp42io8f2t.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        for j in i + 1..l.len() {\n    \
    \        if l[i] > l[j] {\n                let temp = l[i];\n                l[i]\
    \ = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n   \
    \ l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmphsvm71v9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp52mzg0wq.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ - 1 {\n            if l[even_indicies[j]] > l[even_indicies[j + 1]] {\n    \
    \            let temp = l[even_indicies[j]];\n                l[even_indicies[j]]\
    \ = l[even_indicies[j + 1]];\n                l[even_indicies[j + 1]] = temp;\n\
    \            }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_indicies_sorted = even_indicies.clone();\n    even_indicies_sorted.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l.swap(even_indicies[i], even_indicies_sorted[i]);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvq5nk5b4.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp3o6qg5_p.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = vec![];\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_indicies_values: Vec<isize> = vec![];\n  \
    \  for i in even_indicies {\n        even_indicies_values.push(l[i]);\n    }\n\
    \    even_indicies_values.sort();\n    for i in 0..even_indicies.len() {\n   \
    \     l_prime[even_indicies[i]] = even_indicies_values[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpqyhau9ju.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = vec![];\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    let\
    \ mut odd_indices: Vec<usize> = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        } else\
    \ {\n            odd_indices.push(i);\n        }\n    }\n    let mut even_values:\
    \ Vec<isize> = Vec::new();\n    for i in even_indices {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for (i, v) in even_values.iter().enumerate()\
    \ {\n        l[even_indices[i]] = *v;\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpq2pa8yjh.rs:25:11\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n25  |         l[even_indices[i]] = *v;\n    | \
    \          ^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `even_indices`\nhelp: consider\
    \ iterating over a slice of the `Vec<usize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n20  |     for i in &even_indices {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpqisukuim.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indices {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indices.len() {\n        l[even_indices[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpvcaeflny.rs:21:17\n\
    \    |\n10  |     let mut even_indices: Vec<usize> = Vec::new();\n    |      \
    \   ---------------- move occurs because `even_indices` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indices\
    \ {\n    |              ------------ `even_indices` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indices.len() {\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indices`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indices {\n    |      \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..l.len() {\n     \
    \   if i % 2 == 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ {\n            if l_prime[even_indicies[i]] < l_prime[even_indicies[j]] {\n\
    \                let temp = l_prime[even_indicies[i]];\n                l_prime[even_indicies[i]]\
    \ = l_prime[even_indicies[j]];\n                l_prime[even_indicies[j]] = temp;\n\
    \            }\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices: Vec<isize> = Vec::new();\n\
    \    let mut odd_indices: Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(*x);\n        } else\
    \ {\n            odd_indices.push(*x);\n        }\n    }\n    even_indices.sort();\n\
    \    for (i, x) in even_indices.iter().enumerate() {\n        l_prime[i * 2] =\
    \ *x;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for\
    \ (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indicies.push(i\
    \ as isize);\n        }\n    }\n    let mut even_indicies_sorted = even_indicies.clone();\n\
    \    even_indicies_sorted.sort();\n    for (i, j) in even_indicies.iter().zip(even_indicies_sorted.iter())\
    \ {\n        l.swap(*i as usize, *j as usize);\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpc8wdmdck.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpndhnn6p_.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    l.swap(i, j);\n       \
    \         }\n                j += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpxk0zzbd6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmprq_m3s6c.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_indicies_values: Vec<isize> = Vec::new();\n\
    \    for i in even_indicies {\n        even_indicies_values.push(l[i]);\n    }\n\
    \    even_indicies_values.sort();\n    for i in 0..even_indicies.len() {\n   \
    \     l_prime[even_indicies[i]] = even_indicies_values[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmphgaujte4.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmph_vrxnfr.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut v = l.clone();\n    let mut i = 0;\n    while i < v.len() {\n      \
    \  if i % 2 == 0 {\n            let mut j = i + 1;\n            while j < v.len()\
    \ {\n                if v[j] < v[i] {\n                    v.swap(i, j);\n   \
    \             }\n                j += 1;\n            }\n        }\n        i\
    \ += 1;\n    }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp84e_w_6n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indices = Vec::new();\n    for\
    \ (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even_indices.push(i);\n\
    \        }\n    }\n    for i in even_indices {\n        l_prime[i] = l[i];\n \
    \   }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5dpacegx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpqm7b_k4u.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmptpnol62w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for (i, _) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indicies.push(i);\n        }\n    }\n    for i in even_indicies {\n \
    \       l_prime[i] = l[i];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbkw9pp3t.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut evens: Vec<isize> = Vec::new();\n    let mut odds:\
    \ Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n       \
    \ if i % 2 == 0 {\n            evens.push(*x);\n        } else {\n           \
    \ odds.push(*x);\n        }\n    }\n    evens.sort();\n    for (i, x) in evens.iter().enumerate()\
    \ {\n        l[i * 2] = *x;\n    }\n    for (i, x) in odds.iter().enumerate()\
    \ {\n        l[i * 2 + 1] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        }\n \
    \   }\n    let mut even_values = Vec::new();\n    for i in even_indices {\n  \
    \      even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in 0..even_values.len()\
    \ {\n        l[even_indices[i]] = even_values[i];\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpiensp5k9.rs:22:11\n\
    \    |\n10  |     let mut even_indices = Vec::new();\n    |         ----------------\
    \ move occurs because `even_indices` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indices {\n    |            \
    \  ------------ `even_indices` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indices[i]] = even_values[i];\n    |           ^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indices`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 1;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1,\
    \ j);\n            j -= 1;\n        }\n        i += 2;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpenrdt8f0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            let mut j = i + 1;\n            while j < l.len() {\n\
    \                if l[j] < l[i] {\n                    let tmp = l[i];\n     \
    \               l[i] = l[j];\n                    l[j] = tmp;\n              \
    \  }\n                j += 1;\n            }\n        }\n        i += 1;\n   \
    \ }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9pfypfzo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_indicies_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_indicies_values.push(l[i]);\n    }\n    even_indicies_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_indicies_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptc7cmvjy.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptgmsuo4z.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indices = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i);\n        }\n \
    \   }\n    let mut even_values = Vec::new();\n    for i in even_indices {\n  \
    \      even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in 0..even_values.len()\
    \ {\n        l[even_indices[i]] = even_values[i];\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indices`\n   --> /tmp/tmpypb8z389.rs:22:11\n\
    \    |\n10  |     let mut even_indices = Vec::new();\n    |         ----------------\
    \ move occurs because `even_indices` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indices {\n    |            \
    \  ------------ `even_indices` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indices[i]] = even_values[i];\n    |           ^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indices`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indices {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpf7d_br5y.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp42h1n3lw.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in i..even_indicies.len()\
    \ {\n            if l[even_indicies[i]] > l[even_indicies[j]] {\n            \
    \    let temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_even = l.clone();\n    let mut l_odd = l.clone();\n    l_even.retain(|&x|\
    \ x % 2 == 0);\n    l_odd.retain(|&x| x % 2 != 0);\n    l_even.sort();\n    let\
    \ mut l_even_odd = l_even.clone();\n    l_even_odd.append(&mut l_odd);\n    l_even_odd\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmporoua_u8.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n        if i % 2 ==\
    \ 0 {\n            even_indicies.push(x);\n        } else {\n            odd_indicies.push(x);\n\
    \        }\n    }\n    even_indicies.sort();\n    for (i, x) in even_indicies.iter().enumerate()\
    \ {\n        l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl70hhad8.rs:21:20\n   |\n\
    21 |         l[i * 2] = *x;\n   |         --------   ^^ expected `isize`, found\
    \ `&isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         l[i * 2] =\
    \ **x;\n   |                    +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l = l;\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_indicies_values: Vec<isize> = Vec::new();\n\
    \    for i in even_indicies {\n        even_indicies_values.push(l[i]);\n    }\n\
    \    even_indicies_values.sort();\n    for i in 0..even_indicies.len() {\n   \
    \     l[even_indicies[i]] = even_indicies_values[i];\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpyt8bmx8v.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3,\
    \ 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n   \
    \ let mut l_prime = l.clone();\n    let mut even_indicies = Vec::new();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp0h11c3u_.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
