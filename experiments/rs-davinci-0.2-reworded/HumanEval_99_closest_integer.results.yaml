name: HumanEval_99_closest_integer
language: rs
results:
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    if float_value.fract()\
    \ < 0.5 {\n        float_value.floor() as isize\n    } else {\n        float_value.ceil()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp6b_wy5al.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp8ewux_3y.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp9g5ryhv7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ (value - 0.5).floor() as isize;\n    }\n    (value + 0.5).floor() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    let value_round = value_abs.round();\n    if value_abs - value_floor < value_ceil\
    \ - value_abs {\n        if value_abs - value_floor < value_round - value_abs\
    \ {\n            if value < 0.0 {\n                -value_floor as isize\n   \
    \         } else {\n                value_floor as isize\n            }\n    \
    \    } else {\n            if value < 0.0 {\n                -value_round as isize\n\
    \            } else {\n                value_round as isize\n            }\n \
    \       }\n    } else {\n        if value_ceil - value_abs < value_round - value_abs\
    \ {\n            if value < 0.0 {\n                -value_ceil as isize\n    \
    \        } else {\n                value_ceil as isize\n            }\n      \
    \  } else {\n            if value < 0.0 {\n                -value_round as isize\n\
    \            } else {\n                value_round as isize\n            }\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpzaidp4i_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n      \
    \  value -= 0.5;\n    } else {\n        value += 0.5;\n    }\n    value as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpyq9xznz4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value >= 0.0 {\n\
    \        value + 0.5\n    } else {\n        value - 0.5\n    };\n    value.trunc()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let int_value = float_value.round()\
    \ as isize;\n    if float_value - int_value as f64 >= 0.5 {\n        int_value\
    \ + 1\n    } else {\n        int_value\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmp4b8gtsf7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_floor = num_abs.floor();\n    let num_ceil = num_abs.ceil();\n    let num_floor_diff\
    \ = num_abs - num_floor;\n    let num_ceil_diff = num_ceil - num_abs;\n    if\
    \ num_floor_diff < num_ceil_diff {\n        num_floor as isize * num.signum()\
    \ as isize\n    } else {\n        num_ceil as isize * num.signum() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpiuw067yd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num - num_int as f64 == 0.5 {\n        if num_int > 0 {\n            num_int\
    \ + 1\n        } else {\n            num_int - 1\n        }\n    } else {\n  \
    \      num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpx1z_s8fw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.is_sign_negative() {\n        value -= 1.0;\n    }\n    value as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp7anuevkq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpf0d57ak7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp7epv7j8i.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpagxza5ud.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp9d393hex.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if value > 0.0 {\n       \
    \     result += 1;\n        } else {\n            result -= 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpiie7mr0o.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let mut int_value = float_value.round()\
    \ as isize;\n    if int_value == 0 {\n        int_value = 1;\n    }\n    int_value\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpoemls8jc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num = num.round();\n    num\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmprg43ac5q.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f = value.parse::<f64>().unwrap();\n    if f.fract() >= 0.5 {\n       \
    \ (f + 1.0).round() as isize\n    } else {\n        f.round() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp7g0dt62b.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let rounded_number = number.round();\n\
    \    if rounded_number > number {\n        rounded_number as isize - 1\n    }\
    \ else {\n        rounded_number as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpqba3l25l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num >= 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpul79l_yz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpu4lennzv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp6lyvk792.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcfngfsay.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value > 0.0 {\n        value += 0.5;\n    } else {\n        value -= 0.5;\n\
    \    }\n    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value < 0.0 {\
    \ value - 0.5 } else { value + 0.5 };\n    value.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpql1vsihh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut closest = value.round()\
    \ as isize;\n    if closest < value as isize {\n        closest += 1;\n    }\n\
    \    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmp62ya4v_p.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if result.is_positive() {\n\
    \            result += 1;\n        } else {\n            result -= 1;\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmphwrg5m6l.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpyfczldln.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if result.is_positive() {\n\
    \            result += 1;\n        } else {\n            result -= 1;\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpilju66yh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if result < value as isize {\n        result += 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmplohy3rhr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmppldfk3by.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let closest_int = value.round();\n\
    \    closest_int as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    if float_value > 0.0\
    \ {\n        return float_value.ceil() as isize;\n    }\n    float_value.floor()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp3dygwtge.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpqxezbgy8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.fract()\
    \ >= 0.5 {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ (value - 0.5).floor() as isize;\n    }\n    (value + 0.5).floor() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<f64>().unwrap();\n    if value < 0.0 {\n    \
    \    value -= 0.5;\n    } else {\n        value += 0.5;\n    }\n    value.trunc()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num.fract() == 0.5 {\n        if num_int > 0 {\n            num_int +\
    \ 1\n        } else {\n            num_int - 1\n        }\n    } else {\n    \
    \    num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp92tmis1z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp4w4_xhcv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpoex7_nwn.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_int = value.round()\
    \ as isize;\n    if value - value_int as f64 == 0.5 {\n        if value_int >\
    \ 0 {\n            value_int + 1\n        } else {\n            value_int - 1\n\
    \        }\n    } else {\n        value_int\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpawrcm114.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpgc6khgwh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value - value.floor() < 0.5\
    \ {\n        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpcu4j_ukc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let mut num_int = num.round() as\
    \ isize;\n    if num_int < num as isize {\n        num_int += 1;\n    }\n    num_int\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmp7unwfqar.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_floor = num_abs.floor();\n    let num_ceil = num_abs.ceil();\n    if num_floor\
    \ == num_ceil {\n        return num_floor as isize;\n    }\n    if num_abs - num_floor\
    \ < num_ceil - num_abs {\n        return num_floor as isize;\n    }\n    return\
    \ num_ceil as isize;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmp3bny_dma.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp4mz8w6v7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmphouwjz3y.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpic6o28fr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpoh573k9c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if result < value as isize {\n        result += 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpiqrqsaep.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.fract()\
    \ >= 0.5 {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value < 0.0 {\n        return\
    \ (value - 0.5).floor() as isize;\n    }\n    (value + 0.5).floor() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  return num.floor() as isize;\n    }\n    num.ceil() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let num_int = num.round() as\
    \ isize;\n    if num_int >= 0 {\n        num_int\n    } else {\n        num_int\
    \ - 1\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp6mua11k1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let value = if value >= 0.0\
    \ {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n    value\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpjto6dof9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp76et9hs_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    if value_abs - value_floor < value_ceil - value_abs {\n        value_floor\
    \ as isize * value.signum() as isize\n    } else {\n        value_ceil as isize\
    \ * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value < 0.0 {\n\
    \        value - 0.5\n    } else {\n        value + 0.5\n    };\n    value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpv6phgnwm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut num: f64 = value.parse().unwrap();\n    if num < 0.0 {\n        num\
    \ -= 0.5;\n    } else {\n        num += 0.5;\n    }\n    num as isize\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value < 0.0 {\n        value -= 1.0;\n    }\n    value as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp3ysthhxi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp08i28ypp.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        (value_rounded - 1.0) as isize\n    }\
    \ else {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmplkudsjqz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpdkd6x1sg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() < 0.5 {\n\
    \        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.trunc();\n  \
    \  let num_dec = num - num_int;\n    if num_dec >= 0.5 {\n        (num_int + 1.0)\
    \ as isize\n    } else {\n        num_int as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmp73gtdj_n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.fract()\
    \ >= 0.5 {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpjtw59l8f.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let closest_integer: isize =\
    \ value.round() as isize;\n    closest_integer\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpz73wdthb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp00pp5i_r.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcvwxa289.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmptfzwh6r4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        value += 1.0;\n    }\n    value.round() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpz0cboz4i.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpj8_wlzwi.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp9dafjl1p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_abs_floor = value_abs.floor();\n    let value_abs_ceil = value_abs.ceil();\n\
    \    if value_abs - value_abs_floor < value_abs_ceil - value_abs {\n        value_abs_floor\
    \ as isize * value.signum() as isize\n    } else {\n        value_abs_ceil as\
    \ isize * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_abs_ceil = value_abs.ceil();\n    let value_abs_floor = value_abs.floor();\n\
    \    if value_abs_ceil - value_abs < value_abs - value_abs_floor {\n        value_abs_ceil\
    \ as isize * value.signum() as isize\n    } else {\n        value_abs_floor as\
    \ isize * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpozn1zegp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value > 0.0 {\n        value += 0.5;\n    } else {\n        value -= 0.5;\n\
    \    }\n    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut num = value.parse::<f64>().unwrap();\n    if num.fract() == 0.5 {\n\
    \        num += 0.5;\n    }\n    num.round() as isize\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_int = num_abs.floor() as isize;\n    let num_dec = num_abs - num_int as\
    \ f64;\n    if num_dec >= 0.5 {\n        num_int + 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmpddca95b9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_abs_floor = num_abs.floor();\n    let num_abs_ceil = num_abs.ceil();\n \
    \   if num_abs_floor == num_abs_ceil {\n        return num.round() as isize;\n\
    \    }\n    if num_abs - num_abs_floor < num_abs_ceil - num_abs {\n        return\
    \ num_abs_floor as isize;\n    }\n    return num_abs_ceil as isize;\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmpr6rs7az3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpowq4wmap.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value - value.floor() < 0.5\
    \ {\n        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmptkrj9i3p.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpywuez21a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value >= 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpdak1fw_0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp6y8np7z9.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_floor = num_abs.floor();\n    let num_ceil = num_abs.ceil();\n    let num_floor_diff\
    \ = num_abs - num_floor;\n    let num_ceil_diff = num_ceil - num_abs;\n    if\
    \ num_floor_diff == num_ceil_diff {\n        if num < 0.0 {\n            -num_ceil\
    \ as isize\n        } else {\n            num_ceil as isize\n        }\n    }\
    \ else if num_floor_diff < num_ceil_diff {\n        num_floor as isize\n    }\
    \ else {\n        num_ceil as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.is_sign_negative() {\n        value -= 1.0;\n    }\n    value as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpa7nm26f3.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpvwny32cp.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value < 0.0 {\n        value -= 1.0;\n    }\n    value as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp1v2wfgj5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() == 0.5 {\n \
    \       if value > 0.0 {\n            value.ceil() as isize\n        } else {\n\
    \            value.floor() as isize\n        }\n    } else {\n        value.round()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    let i: isize = f.round() as isize;\n\
    \    i\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpct2xdlf3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcbmix6cv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpgyw1c5um.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_int = value.round()\
    \ as isize;\n    if value_int > value as isize {\n        value_int - 1\n    }\
    \ else {\n        value_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpwc05j6eo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmped0_6ksv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_ceil = num.ceil();\n  \
    \  let num_floor = num.floor();\n    if num_ceil - num == num - num_floor {\n\
    \        if num >= 0.0 {\n            num_ceil as isize\n        } else {\n  \
    \          num_floor as isize\n        }\n    } else if num_ceil - num > num -\
    \ num_floor {\n        num_floor as isize\n    } else {\n        num_ceil as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpvrgmv8sf.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpss2js44z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        result = if value.is_sign_positive()\
    \ {\n            result + 1\n        } else {\n            result - 1\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp2tfe03eh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpc2bf04_c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value > 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcg09q13k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    return num.floor() as isize;\n    }\n    num.ceil() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        value += 1.0;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_int_abs = num_int.abs();\n    let num_abs = num.abs();\n    if num_abs\
    \ - num_int_abs < 0.5 {\n        num_int\n    } else {\n        num_int + num_int\
    \ / num_int_abs\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `isize` from `f64`\n  --> /tmp/tmptlsaurw8.rs:19:16\n\
    \   |\n19 |     if num_abs - num_int_abs < 0.5 {\n   |                ^ no implementation\
    \ for `f64 - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpw5gj1u9o.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n      \
    \  value -= 0.5;\n    } else {\n        value += 0.5;\n    }\n    value as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpmhy116h4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() < 0.5 {\n\
    \        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut closest_int = value.round()\
    \ as isize;\n    if closest_int == 0 {\n        closest_int = 1;\n    }\n    if\
    \ value.abs() - value.round().abs() == 0.5 {\n        closest_int *= -1;\n   \
    \ }\n    closest_int\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpngudbae2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if value > 0.0 {\n       \
    \     result += 1;\n        } else {\n            result -= 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpw6uyqn4b.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpycrddfkk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpo1ma6k63.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpqsrdfc5e.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_abs_floor = value_abs.floor();\n    let value_abs_ceil = value_abs.ceil();\n\
    \    let value_abs_floor_diff = value_abs - value_abs_floor;\n    let value_abs_ceil_diff\
    \ = value_abs_ceil - value_abs;\n    if value_abs_floor_diff < value_abs_ceil_diff\
    \ {\n        value_abs_floor as isize * value.signum() as isize\n    } else {\n\
    \        value_abs_ceil as isize * value.signum() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num - num_int as f64 > 0.5 {\n        num_int + 1\n    } else {\n    \
    \    num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp_48qc2g2.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num - num_int as f64 >= 0.5 {\n        num_int + 1\n    } else {\n   \
    \     num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmprly8j6vz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp5rs0zzhh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    if float_value > 0.0\
    \ {\n        float_value.ceil() as isize\n    } else {\n        float_value.floor()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpvpqgdtdp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
