name: HumanEval_119_match_parens
language: rs
results:
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open < 0 && s2_open > 0 {\n        if s1_open.abs() > s2_open\
    \ {\n            return String::from(\"No\");\n        }\n    }\n    if s1_open\
    \ > 0 && s2_open < 0 {\n        if s2_open.abs() > s1_open {\n            return\
    \ String::from(\"No\");\n        }\n    }\n    if s1_open > 0 && s2_open > 0 {\n\
    \        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp66sim88x.rs:40:20\n   |\n40 |         if s1_open.abs() > s2_open\
    \ {\n   |                    ^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n   |\n17 |     let mut s1_open: i32 = 0;\n   |        \
    \ ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `abs` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmp66sim88x.rs:45:20\n   |\n45 |         if s2_open.abs()\
    \ > s1_open {\n   |                    ^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n18 |     let mut s2_open: i32 = 0;\n   |\
    \         ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    let mut s1_done = false;\n    let mut s2_done\
    \ = false;\n    while !(s1_done && s2_done) {\n        if !s1_done {\n       \
    \     match s1.next() {\n                Some('(') => stack.push('('),\n     \
    \           Some(')') => {\n                    if stack.pop() != Some('(') {\n\
    \                        return String::from(\"No\");\n                    }\n\
    \                }\n                None => s1_done = true,\n            }\n \
    \       }\n        if !s2_done {\n            match s2.next() {\n            \
    \    Some('(') => stack.push('('),\n                Some(')') => {\n         \
    \           if stack.pop() != Some('(') {\n                        return String::from(\"\
    No\");\n                    }\n                }\n                None => s2_done\
    \ = true,\n            }\n        }\n    }\n    if stack.is_empty() {\n      \
    \  String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0004]: non-exhaustive patterns: `Some('\\0'..='\\'')`, `Some('*'..='\\\
    u{d7ff}')` and `Some('\\u{e000}'..='\\u{10ffff}')` not covered\n   --> /tmp/tmp694m2pbf.rs:22:19\n\
    \    |\n22  |             match s1.next() {\n    |                   ^^^^^^^^^\
    \ patterns `Some('\\0'..='\\'')`, `Some('*'..='\\u{d7ff}')` and `Some('\\u{e000}'..='\\\
    u{10ffff}')` not covered\n    |\nnote: `Option<char>` defined here\n    = note:\
    \ the matched value is of type `Option<char>`\nhelp: ensure that all possible\
    \ cases are being handled by adding a match arm with a wildcard pattern, a match\
    \ arm with multiple or-patterns as shown, or multiple match arms\n    |\n29  ~\
    \                 None => s1_done = true,\n30  ~                 Some('\\0'..='\\\
    '') | Some('*'..='\\u{d7ff}') | Some('\\u{e000}'..='\\u{10ffff}') => todo!(),\n\
    \    |\n\nerror[E0004]: non-exhaustive patterns: `Some('\\0'..='\\'')`, `Some('*'..='\\\
    u{d7ff}')` and `Some('\\u{e000}'..='\\u{10ffff}')` not covered\n   --> /tmp/tmp694m2pbf.rs:33:19\n\
    \    |\n33  |             match s2.next() {\n    |                   ^^^^^^^^^\
    \ patterns `Some('\\0'..='\\'')`, `Some('*'..='\\u{d7ff}')` and `Some('\\u{e000}'..='\\\
    u{10ffff}')` not covered\n    |\nnote: `Option<char>` defined here\n    = note:\
    \ the matched value is of type `Option<char>`\nhelp: ensure that all possible\
    \ cases are being handled by adding a match arm with a wildcard pattern, a match\
    \ arm with multiple or-patterns as shown, or multiple match arms\n    |\n40  ~\
    \                 None => s2_done = true,\n41  ~                 Some('\\0'..='\\\
    '') | Some('*'..='\\u{d7ff}') | Some('\\u{e000}'..='\\u{10ffff}') => todo!(),\n\
    \    |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0004`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvhm37m0.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7eeiqh1x.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 {\n        s1.append(&mut s2);\n    } else if s2_open ==\
    \ 0 {\n        s2.append(&mut s1);\n    } else {\n        return String::from(\"\
    No\");\n    }\n    let mut open = 0;\n    for c in s1.iter() {\n        if *c\
    \ == '(' {\n            open += 1;\n        } else {\n            open -= 1;\n\
    \        }\n        if open < 0 {\n            return String::from(\"No\");\n\
    \        }\n    }\n    if open == 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyy2zm_3l.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        if s1_open + s2_open\
    \ == 0 {\n            return String::from(\"Yes\");\n        }\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if\
    \ s1_open + s2_open == 0 {\n            return String::from(\"Yes\");\n      \
    \  }\n        return String::from(\"No\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprx1qnnxq.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1hqfisnu.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp37jjbafz.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    s3.push_str(&s1);\n    s3.push_str(&s2);\n\
    \    s4.push_str(&s2);\n    s4.push_str(&s1);\n    s5.push_str(&s1);\n    s5.push_str(&s1);\n\
    \    s6.push_str(&s2);\n    s6.push_str(&s2);\n    s7.push_str(&s1);\n    s7.push_str(&s2);\n\
    \    s7.push_str(&s1);\n    s8.push_str(&s2);\n    s8.push_str(&s1);\n    s8.push_str(&s2);\n\
    \    if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpkypkjy2w.rs:37:8\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpkypkjy2w.rs:37:24\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmpkypkjy2w.rs:37:40\n   |\n37 |     if is_good(&s3) || is_good(&s4)\
    \ || is_good(&s5) || is_good(&s6) || is_good(&s7) || is_good(&s8) {\n   |    \
    \                                    ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmpkypkjy2w.rs:37:56\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmpkypkjy2w.rs:37:72\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmpkypkjy2w.rs:37:88\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                                    ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            open += 1;\n        } else {\n       \
    \     close += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            open += 1;\n        } else {\n            close += 1;\n\
    \        }\n    }\n    if open == close {\n        String::from(\"Yes\")\n   \
    \ } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpoqxssv7c.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut s = String::new();\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    if is_good(&s) {\n        return String::from(\"Yes\");\n    }\n    s.clear();\n\
    \    s.push_str(&lst[1]);\n    s.push_str(&lst[0]);\n    if is_good(&s) {\n  \
    \      return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpkk7odh3u.rs:20:8\n\
    \   |\n20 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpkk7odh3u.rs:26:8\n\
    \   |\n26 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open != s2_close {\n        return String::from(\"\
    No\");\n    }\n    if s1_open != s1_close && s2_open == s2_close {\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open != s1_close && s2_open != s2_close\
    \ {\n        if s1_open > s1_close {\n            s1_open -= s1_close;\n     \
    \       s1_close = 0;\n        } else {\n            s1_close -= s1_open;\n  \
    \          s1_open = 0;\n        }\n        if s2_open > s2_close {\n        \
    \    s2_open -= s2_close;\n            s2_close = 0;\n        } else {\n     \
    \       s2_close -= s2_open;\n            s2_open = 0;\n        }\n        if\
    \ s1_open == s2_close && s2_open == s1_close {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp7lqi772d.rs:77:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut s = String::new();\n\
    \    for s1 in lst {\n        s.push_str(&s1);\n    }\n    for c in s.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else {\n   \
    \         if stack.is_empty() {\n                return String::from(\"No\");\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    if stack.is_empty() {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1hfghge4.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut str1 =\
    \ lst[0].chars();\n    let mut str2 = lst[1].chars();\n    let mut ch = str1.next();\n\
    \    while ch.is_some() {\n        if ch.unwrap() == '(' {\n            stack.push(ch.unwrap());\n\
    \        } else {\n            if stack.is_empty() {\n                return String::from(\"\
    No\");\n            } else {\n                stack.pop();\n            }\n  \
    \      }\n        ch = str1.next();\n    }\n    ch = str2.next();\n    while ch.is_some()\
    \ {\n        if ch.unwrap() == '(' {\n            stack.push(ch.unwrap());\n \
    \       } else {\n            if stack.is_empty() {\n                return String::from(\"\
    No\");\n            } else {\n                stack.pop();\n            }\n  \
    \      }\n        ch = str2.next();\n    }\n    if stack.is_empty() {\n      \
    \  return String::from(\"Yes\");\n    } else {\n        return String::from(\"\
    No\");\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzcz6s52k.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst_iter = lst.iter();\n    let mut s1 = lst_iter.next().unwrap();\n\
    \    let mut s2 = lst_iter.next().unwrap();\n    let mut s1_open = 0;\n    let\
    \ mut s2_open = 0;\n    for c in s1.chars() {\n        if c == '(' {\n       \
    \     s1_open += 1;\n        } else {\n            s1_open -= 1;\n        }\n\
    \    }\n    for c in s2.chars() {\n        if c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open != 0 {\n        return String::from(\"No\");\n\
    \    }\n    if s1_open != 0 && s2_open == 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open < 0 && s2_open < 0 {\n        if s1_open.abs()\
    \ < s2_open.abs() {\n            return String::from(\"Yes\");\n        } else\
    \ {\n            return String::from(\"No\");\n        }\n    }\n    if s1_open\
    \ > 0 && s2_open > 0 {\n        if s1_open > s2_open {\n            return String::from(\"\
    Yes\");\n        } else {\n            return String::from(\"No\");\n        }\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmph_ns7iyr.rs:50:20\n   |\n50 |         if s1_open.abs() < s2_open.abs()\
    \ {\n   |                    ^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n   |\n18 |     let mut s1_open: i32 = 0;\n   |        \
    \ ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `abs` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmph_ns7iyr.rs:50:36\n   |\n50 |         if s1_open.abs()\
    \ < s2_open.abs() {\n   |                                    ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n19 |     let mut\
    \ s2_open: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = String::new();\n\
    \    let mut s4 = String::new();\n    let mut s5 = String::new();\n    let mut\
    \ s6 = String::new();\n    let mut s7 = String::new();\n    let mut s8 = String::new();\n\
    \    let mut s9 = String::new();\n    let mut s10 = String::new();\n    let mut\
    \ s11 = String::new();\n    let mut s12 = String::new();\n    let mut s13 = String::new();\n\
    \    let mut s14 = String::new();\n    let mut s15 = String::new();\n    let mut\
    \ s16 = String::new();\n    let mut s17 = String::new();\n    let mut s18 = String::new();\n\
    \    let mut s19 = String::new();\n    let mut s20 = String::new();\n    let mut\
    \ s21 = String::new();\n    let mut s22 = String::new();\n    let mut s23 = String::new();\n\
    \    let mut s24 = String::new();\n    let mut s25 = String::new();\n    let mut\
    \ s26 = String::new();\n    let mut s27 = String::new();\n    let mut s28 = String::new();\n\
    \    let mut s29 = String::new();\n    let mut s30 = String::new();\n    let mut\
    \ s31 = String::new();\n    let mut s32 = String::new();\n    let mut s33 = String::new();\n\
    \    let mut s34 = String::new();\n    let mut s35 = String::new();\n    let mut\
    \ s36 = String::new();\n    let mut s37 = String::new();\n    let mut s38 = String::new();\n\
    \    let mut s39 = String::new();\n    let mut s40 = String::new();\n    let mut\
    \ s41 = String::new();\n    let mut s42 = String::new();\n    let mut s43 = String::new();\n\
    \    let mut s44 = String::new();\n   \n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1_ten5l.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        if s2_open < s2_close {\n        \
    \    if s2_close - s2_open > s1_open - s1_close {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if s1_open < s1_close {\n       \
    \ if s2_open < s2_close {\n            return String::from(\"No\");\n        }\n\
    \        if s2_open > s2_close {\n            if s2_open - s2_close > s1_close\
    \ - s1_open {\n                return String::from(\"No\");\n            }\n \
    \       }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmppib1gt83.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut cnt = 0;\n    for c in s.chars() {\n        if c == '(' {\n\
    \            cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n \
    \       if cnt < 0 {\n            return String::from(\"No\");\n        }\n  \
    \  }\n    if cnt == 0 {\n        String::from(\"Yes\")\n    } else {\n       \
    \ String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpr0n1nt50.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    s3.push_str(&s1);\n    s3.push_str(&s2);\n\
    \    s4.push_str(&s2);\n    s4.push_str(&s1);\n    s5.push_str(&s1);\n    s5.push_str(&s1);\n\
    \    s6.push_str(&s2);\n    s6.push_str(&s2);\n    s7.push_str(&s1);\n    s7.push_str(&s2);\n\
    \    s7.push_str(&s1);\n    s8.push_str(&s2);\n    s8.push_str(&s1);\n    s8.push_str(&s2);\n\
    \    if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpvo541r7x.rs:37:8\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpvo541r7x.rs:37:24\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmpvo541r7x.rs:37:40\n   |\n37 |     if is_good(&s3) || is_good(&s4)\
    \ || is_good(&s5) || is_good(&s6) || is_good(&s7) || is_good(&s8) {\n   |    \
    \                                    ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmpvo541r7x.rs:37:56\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmpvo541r7x.rs:37:72\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmpvo541r7x.rs:37:88\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                                    ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp854mofbs.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = s1.clone();\n    let mut s4 = s2.clone();\n    s1.push_str(&s2);\n\
    \    s2.push_str(&s3);\n    if is_good(&s1) || is_good(&s2) {\n        return\
    \ String::from(\"Yes\");\n    }\n    s3.push_str(&s4);\n    s4.push_str(&s1);\n\
    \    if is_good(&s3) || is_good(&s4) {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmprro7lobg.rs:21:8\n\
    \   |\n21 |     if is_good(&s1) || is_good(&s2) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmprro7lobg.rs:21:24\n   |\n21 |     if is_good(&s1) || is_good(&s2)\
    \ {\n   |                        ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmprro7lobg.rs:26:8\n\
    \   |\n26 |     if is_good(&s3) || is_good(&s4) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmprro7lobg.rs:26:24\n   |\n26 |     if is_good(&s3) || is_good(&s4)\
    \ {\n   |                        ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy0pq3fzh.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open > 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open > 0 && s2_open < 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpz3t69ag7.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            open += 1;\n        } else {\n       \
    \     close += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            open -= 1;\n        } else {\n            close -= 1;\n\
    \        }\n    }\n    if open < 0 || close < 0 {\n        return String::from(\"\
    No\");\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp8hzbejz1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        if s2_open < s2_close {\n        \
    \    if s1_open - s1_close > s2_close - s2_open {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if s1_open < s1_close {\n       \
    \ if s2_open < s2_close {\n            return String::from(\"No\");\n        }\n\
    \        if s2_open > s2_close {\n            if s1_close - s1_open > s2_open\
    \ - s2_close {\n                return String::from(\"No\");\n            }\n\
    \        }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmptzbxtc4j.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open {\n     \
    \       return String::from(\"Yes\");\n        }\n    }\n    if s1_open < 0 &&\
    \ s2_open > 0 {\n        if s1_open == -s2_open {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp6gcq6lom.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyvzi0nb4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close {\n        if s2_open > s2_close {\n            s1.append(&mut\
    \ s2);\n        } else {\n            s2.append(&mut s1);\n        }\n    } else\
    \ if s2_open == s2_close {\n        if s1_open > s1_close {\n            s2.append(&mut\
    \ s1);\n        } else {\n            s1.append(&mut s2);\n        }\n    } else\
    \ {\n        return String::from(\"No\");\n    }\n    let mut open = 0;\n    let\
    \ mut close = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n         \
    \   open += 1;\n        } else {\n            close += 1;\n        }\n       \
    \ if open < close {\n            return String::from(\"No\");\n        }\n   \
    \ }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5nrtaygv.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => cnt += 1,\n               \
    \ ')' => cnt -= 1,\n                _ => (),\n            }\n            if cnt\
    \ < 0 {\n                return String::from(\"No\");\n            }\n       \
    \ }\n    }\n    if cnt == 0 {\n        String::from(\"Yes\")\n    } else {\n \
    \       String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgwg7uomj.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0n988ltw.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut string = String::new();\n\
    \    for s in lst {\n        for c in s.chars() {\n            if c == '(' {\n\
    \                stack.push(c);\n            } else {\n                if stack.is_empty()\
    \ {\n                    return String::from(\"No\");\n                } else\
    \ {\n                    stack.pop();\n                }\n            }\n    \
    \    }\n        string.push_str(&s);\n    }\n    if stack.is_empty() {\n     \
    \   String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpkys9cmt7.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_open = 0;\n    let mut s2_open = 0;\n    let mut s1_close = 0;\n\
    \    let mut s2_close = 0;\n    for c in s1.chars() {\n        if c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_close += 1;\n   \
    \     }\n    }\n    for c in s2.chars() {\n        if c == '(' {\n           \
    \ s2_open += 1;\n        } else {\n            s2_close += 1;\n        }\n   \
    \ }\n    if s1_open == s1_close && s2_open == s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open == s1_close && s2_open != s2_close {\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open != s1_close && s2_open == s2_close\
    \ {\n        return String::from(\"No\");\n    }\n    if s1_open > s1_close {\n\
    \        s1_open -= s1_close;\n        s1_close = 0;\n    } else {\n        s1_close\
    \ -= s1_open;\n        s1_open = 0;\n    }\n    if s2_open > s2_close {\n    \
    \    s2_open -= s2_close;\n        s2_close = 0;\n    } else {\n        s2_close\
    \ -= s2_open;\n        s2_open = 0;\n    }\n    if s1_open == s2_close && s2_open\
    \ == s1_close {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpzp9hnm43.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut flag =\
    \ true;\n    for s in lst {\n        for c in s.chars() {\n            if c ==\
    \ '(' {\n                stack.push(c);\n            } else {\n              \
    \  if stack.is_empty() {\n                    flag = false;\n                \
    \    break;\n                } else {\n                    stack.pop();\n    \
    \            }\n            }\n        }\n    }\n    if flag && stack.is_empty()\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpsm0sgaza.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter();\n    let mut s1 = lst.next().unwrap();\n\
    \    let mut s2 = lst.next().unwrap();\n    let mut s1_open = 0;\n    let mut\
    \ s2_open = 0;\n    for c in s1.chars() {\n        if c == '(' {\n           \
    \ s1_open += 1;\n        } else {\n            s1_open -= 1;\n        }\n    }\n\
    \    for c in s2.chars() {\n        if c == '(' {\n            s2_open += 1;\n\
    \        } else {\n            s2_open -= 1;\n        }\n    }\n    if s1_open\
    \ == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n    }\n\
    \    if s1_open < 0 {\n        s1_open = -s1_open;\n        s2_open = -s2_open;\n\
    \        std::mem::swap(&mut s1, &mut s2);\n    }\n    if s1_open > s2_open {\n\
    \        return String::from(\"No\");\n    }\n    let mut s1_open = 0;\n    let\
    \ mut s2_open = 0;\n    for c in s1.chars() {\n        if c == '(' {\n       \
    \     s1_open += 1;\n        } else {\n            s1_open -= 1;\n        }\n\
    \    }\n    for c in s2.chars() {\n        if c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp23gc5hdq.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut res = String::new();\n\
    \    for i in 0..lst.len() {\n        for j in 0..lst[i].len() {\n           \
    \ if lst[i][j] == '(' {\n                res.push('(');\n            } else {\n\
    \                if res.chars().last() == Some('(') {\n                    res.pop();\n\
    \                } else {\n                    return String::from(\"No\");\n\
    \                }\n            }\n        }\n    }\n    if res.is_empty() {\n\
    \        String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4klgpkjw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s = String::new();\n    let mut count = 0;\n    while !s1.is_empty()\
    \ || !s2.is_empty() {\n        if !s1.is_empty() {\n            let c = s1.pop().unwrap();\n\
    \            if c == '(' {\n                count += 1;\n            } else {\n\
    \                count -= 1;\n            }\n            s.push(c);\n        }\n\
    \        if !s2.is_empty() {\n            let c = s2.pop().unwrap();\n       \
    \     if c == '(' {\n                count += 1;\n            } else {\n     \
    \           count -= 1;\n            }\n            s.push(c);\n        }\n  \
    \      if count < 0 {\n            return String::from(\"No\");\n        }\n \
    \   }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else {\n    \
    \    String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpi7o34hle.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp09kpxiw5.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp6c58pxq4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|x| x.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut ans = String::new();\n    for i in 0..lst.len() {\n        if i ==\
    \ 0 {\n            ans.push_str(&lst[i].iter().collect::<String>());\n       \
    \ } else {\n            let mut tmp = String::new();\n            for j in 0..lst[i].len()\
    \ {\n                tmp.push(lst[i][j]);\n                if tmp.chars().filter(|x|\
    \ *x == '(').count() == tmp.chars().filter(|x| *x == ')').count() {\n        \
    \            ans.push_str(&tmp);\n                    tmp.clear();\n         \
    \       }\n            }\n            if tmp.chars().filter(|x| *x == '(').count()\
    \ != tmp.chars().filter(|x| *x == ')').count() {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if ans.chars().filter(|x| *x == '(').count()\
    \ == ans.chars().filter(|x| *x == ')').count() {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyxed29ed.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open_parens = 0;\n    let mut close_parens = 0;\n \
    \   for s in lst {\n        for c in s.chars() {\n            match c {\n    \
    \            '(' => open_parens += 1,\n                ')' => close_parens +=\
    \ 1,\n                _ => panic!(\"Invalid character\"),\n            }\n   \
    \     }\n    }\n    if open_parens == close_parens {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpx7nt15ru.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpravxjr5k.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![];\n    let mut s = String::new();\n \
    \   for i in lst {\n        s.push_str(&i);\n    }\n    for c in s.chars() {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else {\n       \
    \     if stack.is_empty() {\n                return String::from(\"No\");\n  \
    \          } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    if stack.is_empty() {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp6si_jatm.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0lhwkcif.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1x6nf6h8.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open > s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s2_open == s2_close && s1_open > s1_close {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_open > s1_close && s2_open > s2_close\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8klbl96y.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    let mut s1_done = false;\n    let mut s2_done\
    \ = false;\n    loop {\n        if !s1_done {\n            match s1.next() {\n\
    \                Some(c) => {\n                    if c == '(' {\n           \
    \             stack.push(c);\n                    } else {\n                 \
    \       match stack.pop() {\n                            Some(_) => (),\n    \
    \                        None => return String::from(\"No\"),\n              \
    \          }\n                    }\n                }\n                None =>\
    \ s1_done = true,\n            }\n        }\n        if !s2_done {\n         \
    \   match s2.next() {\n                Some(c) => {\n                    if c\
    \ == '(' {\n                        stack.push(c);\n                    } else\
    \ {\n                        match stack.pop() {\n                           \
    \ Some(_) => (),\n                            None => return String::from(\"No\"\
    ),\n                        }\n                    }\n                }\n    \
    \            None => s2_done = true,\n            }\n        }\n        if s1_done\
    \ && s2_done {\n            break;\n        }\n    }\n    if stack.is_empty()\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmptfj97aso.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        s2.reverse();\n        let mut s2_open\
    \ = 0;\n        let mut s2_close = 0;\n        for c in s2.iter() {\n        \
    \    if *c == '(' {\n                s2_open += 1;\n            } else {\n   \
    \             s2_close += 1;\n            }\n            if s2_open < s2_close\
    \ {\n                return String::from(\"No\");\n            }\n        }\n\
    \        return String::from(\"Yes\");\n    }\n    if s2_open > s2_close {\n \
    \       s1.reverse();\n        let mut s1_open = 0;\n        let mut s1_close\
    \ = 0;\n        for c in s1.iter() {\n            if *c == '(' {\n           \
    \     s1_open += 1;\n            } else {\n                s1_close += 1;\n  \
    \          }\n            if s1_open < s1_close {\n                return String::from(\"\
    No\");\n            }\n        }\n        return String::from(\"Yes\");\n    }\n\
    \    String::from(\"\n}\n\nfn main() {\n    let candidate = match_parens;\n  \
    \  assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpve4gqezh.rs:80:75\n\
    \   |\n57 |     if s2_open > s2_close {\n   |                           - this\
    \ opening brace...\n...\n72 |     }\n   |     - ...matches this closing brace\n\
    ...\n80 |     assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"\
    ())())\")]), String::from(\"No\"));\n   |                                    \
    \                                       ^ unexpected closing delimiter\n\nerror:\
    \ mismatched closing delimiter: `)`\n  --> /tmp/tmpve4gqezh.rs:14:45\n   |\n14\
    \ | fn match_parens(lst: Vec<String>) -> String {\n   |                      \
    \                       ^ unclosed delimiter\n...\n79 |     assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n   |                    \
    \                                            ^ mismatched closing delimiter\n\n\
    error: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpinqdx3em.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    if lst[0].len() >\
    \ lst[1].len() {\n        lst.swap(0, 1);\n    }\n    let mut count = 0;\n   \
    \ for c in lst[0].chars() {\n        if c == '(' {\n            count += 1;\n\
    \        } else {\n            count -= 1;\n        }\n    }\n    if count < 0\
    \ {\n        return String::from(\"No\");\n    }\n    for c in lst[1].chars()\
    \ {\n        if c == '(' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n    }\n    if count == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgcftmpe_.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open != s2_close {\n        if s2_open > s2_close\
    \ {\n            s2.reverse();\n            s2.push('(');\n            s2.reverse();\n\
    \        } else {\n            s2.push(')');\n        }\n        s1.append(&mut\
    \ s2);\n        if is_good(&s1) {\n            return String::from(\"Yes\");\n\
    \        }\n    }\n    if s1_open != s1_close && s2_open == s2_close {\n     \
    \   if s1_open > s1_close {\n            s1.reverse();\n            s1.push('(');\n\
    \            s1.reverse();\n        } else {\n            s1.push(')');\n    \
    \    }\n        s1.append(&mut s2);\n        if is_good(&s1) {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    if s1_open != s1_close && s2_open\
    \ != s2_close {\n        if s1_open > s1_close {\n            s1.reverse();\n\
    \            s1.push('(');\n            s1.reverse();\n       \n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdlrk__uk.rs:86:3\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - unclosed delimiter\n...\n64 |     if s1_open\
    \ != s1_close && s2_open != s2_close {\n   |                                 \
    \                  - unclosed delimiter\n65 |         if s1_open > s1_close {\n\
    \   |                               - this delimiter might not be properly closed...\n\
    ...\n70 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    86 | }\n   |   ^\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmpdlrk__uk.rs:47:12\n   |\n47 |         if is_good(&s1) {\n   | \
    \           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_good` in this scope\n  --> /tmp/tmpdlrk__uk.rs:60:12\n   |\n60 |       \
    \  if is_good(&s1) {\n   |            ^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdlrk__uk.rs:64:51\n   |\n64 |       if s1_open\
    \ != s1_close && s2_open != s2_close {\n   |  ___________________________________________________^\n\
    65 | |         if s1_open > s1_close {\n66 | |             s1.reverse();\n67 |\
    \ |             s1.push('(');\n...  |\n85 | |     assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n86 | | }\n   | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpfgj6puu5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = String::new();\n    let mut s2 = String::new();\n\
    \    for s in lst {\n        if s1.len() == 0 {\n            s1 = s;\n       \
    \ } else {\n            s2 = s;\n        }\n    }\n    let mut s1_open = 0;\n\
    \    let mut s1_close = 0;\n    let mut s2_open = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.chars() {\n        if c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.chars() {\n        if c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close {\n        return String::from(\"No\");\n    }\n    if\
    \ s2_open == s2_close {\n        return String::from(\"No\");\n    }\n    if s1_open\
    \ < s1_close {\n        if s2_open < s2_close {\n            return String::from(\"\
    No\");\n        }\n        if s2_open - s2_close == s1_close - s1_open {\n   \
    \         return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s2_open < s2_close {\n        if s1_open - s1_close == s2_close\
    \ - s2_open {\n            return String::from(\"Yes\");\n        }\n        return\
    \ String::from(\"No\");\n    }\n    return String::from(\"No\");\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpbftk_6fd.rs:80:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    let mut cnt = 0;\n    for c in s.chars() {\n        if c == '(' {\n\
    \            cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n \
    \       if cnt < 0 {\n            return String::from(\"No\");\n        }\n  \
    \  }\n    if cnt == 0 {\n        String::from(\"Yes\")\n    } else {\n       \
    \ String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzz9sm8c3.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        if s1_open + s2_open ==\
    \ 0 {\n            return String::from(\"Yes\");\n        }\n    }\n    if s1_open\
    \ > 0 && s2_open > 0 {\n        if s1_open + s2_open == 0 {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprj73djgz.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpg0t28g2x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut res = String::new();\n\
    \    for v in lst {\n        res.push_str(&v.into_iter().collect::<String>());\n\
    \    }\n    let mut count = 0;\n    for c in res.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpp7wsgz4y.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s = String::new();\n\
    \    let mut count = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n  \
    \          count += 1;\n        } else {\n            count -= 1;\n        }\n\
    \        if count < 0 {\n            return String::from(\"No\");\n        }\n\
    \    }\n    for c in s2.iter() {\n        if *c == '(' {\n            count +=\
    \ 1;\n        } else {\n            count -= 1;\n        }\n        if count <\
    \ 0 {\n            return String::from(\"No\");\n        }\n    }\n    if count\
    \ == 0 {\n        return String::from(\"Yes\");\n    }\n    s1.reverse();\n  \
    \  s2.reverse();\n    for c in s1.iter() {\n        if *c == ')' {\n         \
    \   count += 1;\n        } else {\n            count -= 1;\n        }\n      \
    \  if count < 0 {\n            return String::from(\"No\");\n        }\n    }\n\
    \    for c in s2.iter() {\n        if *c == ')' {\n            count += 1;\n \
    \       } else {\n            count -= 1;\n        }\n        if count < 0 {\n\
    \            return String::from(\"No\");\n        }\n    }\n    if count == 0\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpqgubo5ia.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open {\n     \
    \       return String::from(\"Yes\");\n        }\n    }\n    if s1_open < 0 &&\
    \ s2_open > 0 {\n        if s1_open == -s2_open {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpkznjlrk7.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut s = String::new();\n    let mut count = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < lst[0].len() || j < lst[1].len() {\n      \
    \  if i < lst[0].len() && lst[0][i] == '(' {\n            count += 1;\n      \
    \      s.push(lst[0][i]);\n            i += 1;\n        } else if j < lst[1].len()\
    \ && lst[1][j] == '(' {\n            count += 1;\n            s.push(lst[1][j]);\n\
    \            j += 1;\n        } else if i < lst[0].len() && lst[0][i] == ')' {\n\
    \            if count == 0 {\n                return String::from(\"No\");\n \
    \           }\n            count -= 1;\n            s.push(lst[0][i]);\n     \
    \       i += 1;\n        } else if j < lst[1].len() && lst[1][j] == ')' {\n  \
    \          if count == 0 {\n                return String::from(\"No\");\n   \
    \         }\n            count -= 1;\n            s.push(lst[1][j]);\n       \
    \     j += 1;\n        }\n    }\n    if count == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpi01ny1bc.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open < s2_close {\n        if s2_open + s1_open\
    \ == s2_close {\n            return String::from(\"Yes\");\n        }\n    }\n\
    \    if s2_open == s2_close && s1_open < s1_close {\n        if s1_open + s2_open\
    \ == s1_close {\n            return String::from(\"Yes\");\n        }\n    }\n\
    \    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpkc5szdyz.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpstd9i3um.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = String::new();\n\
    \    let mut s4 = String::new();\n    let mut s5 = String::new();\n    let mut\
    \ s6 = String::new();\n    let mut s7 = String::new();\n    let mut s8 = String::new();\n\
    \    let mut s9 = String::new();\n    let mut s10 = String::new();\n    let mut\
    \ s11 = String::new();\n    let mut s12 = String::new();\n    let mut s13 = String::new();\n\
    \    let mut s14 = String::new();\n    let mut s15 = String::new();\n    let mut\
    \ s16 = String::new();\n    let mut s17 = String::new();\n    let mut s18 = String::new();\n\
    \    let mut s19 = String::new();\n    let mut s20 = String::new();\n    let mut\
    \ s21 = String::new();\n    let mut s22 = String::new();\n    let mut s23 = String::new();\n\
    \    let mut s24 = String::new();\n    let mut s25 = String::new();\n    let mut\
    \ s26 = String::new();\n    let mut s27 = String::new();\n    let mut s28 = String::new();\n\
    \    let mut s29 = String::new();\n    let mut s30 = String::new();\n    let mut\
    \ s31 = String::new();\n    let mut s32 = String::new();\n    let mut s33 = String::new();\n\
    \    let mut s34 = String::new();\n    let mut s35 = String::new();\n    let mut\
    \ s36 = String::new();\n    let mut s37 = String::new();\n    let mut s38 = String::new();\n\
    \    let mut s39 = String::new();\n    let mut s40 = String::new();\n    let mut\
    \ s41 = String::new();\n    let mut s42 = String::new();\n    let mut s43 = String::new();\n\
    \    let mut s44 = String::new();\n   \n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv9c1x55x.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpuxl2u54n.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    let mut s1_done = false;\n    let mut s2_done\
    \ = false;\n    let mut curr_s = &mut s1;\n    let mut curr_done = &mut s1_done;\n\
    \    loop {\n        if !stack.is_empty() && *curr_done {\n            let top\
    \ = stack.pop().unwrap();\n            if top == '(' {\n                return\
    \ String::from(\"No\");\n            }\n        }\n        if stack.is_empty()\
    \ && *curr_done {\n            if curr_s == &mut s1 {\n                curr_s\
    \ = &mut s2;\n                curr_done = &mut s2_done;\n            } else {\n\
    \                break;\n            }\n        }\n        match curr_s.next()\
    \ {\n            Some('(') => stack.push('('),\n            Some(')') => {\n \
    \               if stack.is_empty() {\n                    return String::from(\"\
    No\");\n                }\n                let top = stack.pop().unwrap();\n \
    \               if top != '(' {\n                    return String::from(\"No\"\
    );\n                }\n            }\n            None => *curr_done = true,\n\
    \            _ => (),\n        }\n    }\n    if stack.is_empty() {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `&mut Chars<'_>`\n\
    \  --> /tmp/tmp0sj5rxaf.rs:30:23\n   |\n30 |             if curr_s == &mut s1\
    \ {\n   |                ------ ^^ ------- &mut Chars<'_>\n   |              \
    \  |\n   |                &mut Chars<'_>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close {\n        if s2_open > s2_close {\n            s1.push('(');\n\
    \        } else {\n            s1.push(')');\n        }\n    } else if s2_open\
    \ == s2_close {\n        if s1_open > s1_close {\n            s2.push('(');\n\
    \        } else {\n            s2.push(')');\n        }\n    } else {\n      \
    \  return String::from(\"No\");\n    }\n    let mut s = s1.iter().chain(s2.iter()).collect::<String>();\n\
    \    let mut open = 0;\n    let mut close = 0;\n    for c in s.chars() {\n   \
    \     if c == '(' {\n            open += 1;\n        } else {\n            close\
    \ += 1;\n        }\n        if close > open {\n            return String::from(\"\
    No\");\n        }\n    }\n    if open == close {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpxj22g94o.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = String::new();\n\
    \    let mut s4 = String::new();\n    let mut s5 = String::new();\n    let mut\
    \ s6 = String::new();\n    let mut s7 = String::new();\n    let mut s8 = String::new();\n\
    \    let mut s9 = String::new();\n    let mut s10 = String::new();\n    let mut\
    \ s11 = String::new();\n    let mut s12 = String::new();\n    let mut s13 = String::new();\n\
    \    let mut s14 = String::new();\n    let mut s15 = String::new();\n    let mut\
    \ s16 = String::new();\n    let mut s17 = String::new();\n    let mut s18 = String::new();\n\
    \    let mut s19 = String::new();\n    let mut s20 = String::new();\n    let mut\
    \ s21 = String::new();\n    let mut s22 = String::new();\n    let mut s23 = String::new();\n\
    \    let mut s24 = String::new();\n    let mut s25 = String::new();\n    let mut\
    \ s26 = String::new();\n    let mut s27 = String::new();\n    let mut s28 = String::new();\n\
    \    let mut s29 = String::new();\n    let mut s30 = String::new();\n    let mut\
    \ s31 = String::new();\n    let mut s32 = String::new();\n    let mut s33 = String::new();\n\
    \    let mut s34 = String::new();\n    let mut s35 = String::new();\n    let mut\
    \ s36 = String::new();\n    let mut s37 = String::new();\n    let mut s38 = String::new();\n\
    \    let mut s39 = String::new();\n    let mut s40 = String::new();\n    let mut\
    \ s41 = String::new();\n    let mut s42 = String::new();\n    let mut s43 = String::new();\n\
    \    let mut s44 = String::new();\n   \n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo1i30e7.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyx71614_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphs0zuw0f.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s = String::new();\n\
    \    let mut cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n    \
    \        cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n     \
    \   if cnt < 0 {\n            return String::from(\"No\");\n        }\n    }\n\
    \    for c in s2.iter() {\n        if *c == '(' {\n            cnt += 1;\n   \
    \     } else {\n            cnt -= 1;\n        }\n        if cnt < 0 {\n     \
    \       return String::from(\"No\");\n        }\n    }\n    if cnt == 0 {\n  \
    \      return String::from(\"Yes\");\n    }\n    s1.append(&mut s2);\n    let\
    \ mut cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n           \
    \ cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n        if cnt\
    \ < 0 {\n            return String::from(\"No\");\n        }\n    }\n    if cnt\
    \ == 0 {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\"\
    )\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpcztgfqv_.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uiy5gbu.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    let mut s1_done = false;\n    let mut s2_done\
    \ = false;\n    while !s1_done || !s2_done {\n        if !s1_done {\n        \
    \    match s1.next() {\n                Some('(') => stack.push('('),\n      \
    \          Some(')') => {\n                    if stack.len() > 0 && stack[stack.len()\
    \ - 1] == '(' {\n                        stack.pop();\n                    } else\
    \ {\n                        stack.push(')');\n                    }\n       \
    \         }\n                None => s1_done = true,\n                _ => (),\n\
    \            }\n        }\n        if !s2_done {\n            match s2.next()\
    \ {\n                Some('(') => stack.push('('),\n                Some(')')\
    \ => {\n                    if stack.len() > 0 && stack[stack.len() - 1] == '('\
    \ {\n                        stack.pop();\n                    } else {\n    \
    \                    stack.push(')');\n                    }\n               \
    \ }\n                None => s2_done = true,\n                _ => (),\n     \
    \       }\n        }\n    }\n    if stack.len() == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpmej16564.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_open = 0;\n    let mut s2_open = 0;\n    let mut s1_close = 0;\n\
    \    let mut s2_close = 0;\n    for c in s1.chars() {\n        if c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_close += 1;\n   \
    \     }\n    }\n    for c in s2.chars() {\n        if c == '(' {\n           \
    \ s2_open += 1;\n        } else {\n            s2_close += 1;\n        }\n   \
    \ }\n    if s1_open == s1_close && s2_open == s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open == s1_close && s2_open != s2_close {\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open != s1_close && s2_open == s2_close\
    \ {\n        return String::from(\"No\");\n    }\n    if s1_open > s1_close {\n\
    \        s1_open -= s1_close;\n        s1_close = 0;\n    } else {\n        s1_close\
    \ -= s1_open;\n        s1_open = 0;\n    }\n    if s2_open > s2_close {\n    \
    \    s2_open -= s2_close;\n        s2_close = 0;\n    } else {\n        s2_close\
    \ -= s2_open;\n        s2_open = 0;\n    }\n    if s1_open == s2_close && s2_open\
    \ == s1_close {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpnjqy1hio.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpod922yji.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3wrhjvv6.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open {\n     \
    \       return String::from(\"Yes\");\n        }\n    }\n    if s1_open < 0 &&\
    \ s2_open > 0 {\n        if s1_open == -s2_open {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpn3roshlj.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    if s.chars().filter(|&c| c == '(').count() != s.chars().filter(|&c|\
    \ c == ')').count() {\n        return String::from(\"No\");\n    }\n    let mut\
    \ stack = Vec::new();\n    for c in s.chars() {\n        if c == '(' {\n     \
    \       stack.push(c);\n        } else {\n            if stack.is_empty() {\n\
    \                return String::from(\"No\");\n            }\n            stack.pop();\n\
    \        }\n    }\n    if stack.is_empty() {\n        return String::from(\"Yes\"\
    );\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7ijtb_zb.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9trf1hac.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    if s.len() % 2 == 1 {\n        return String::from(\"No\");\n    }\n\
    \    let mut stack = Vec::new();\n    for c in s.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ stack.pop();\n        }\n    }\n    if stack.is_empty() {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpde8cz6wb.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"No\"\
    );\n    }\n    if s1_open > 0 {\n        s1.append(&mut s2);\n    } else {\n \
    \       s2.append(&mut s1);\n    }\n    let mut open = 0;\n    for c in s1.iter()\
    \ {\n        if *c == '(' {\n            open += 1;\n        } else {\n      \
    \      open -= 1;\n        }\n        if open < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpmnu5gb1t.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcntg91te.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == s2_open {\n        return String::from(\"Yes\");\n    }\n \
    \   if s1_open == -s2_open {\n        return String::from(\"Yes\");\n    }\n \
    \   String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp5sy2clyx.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = String::new();\n    for s in lst {\n     \
    \   parens.push_str(&s);\n    }\n    let mut count = 0;\n    for c in parens.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp35ox94ma.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open > 0 && s2_open < 0 {\n        return String::from(\"No\"\
    );\n    }\n    if s1_open < 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpwjec_hg9.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut result = String::from(\"\
    Yes\");\n    for s in lst {\n        for c in s.chars() {\n            match c\
    \ {\n                '(' => stack.push(c),\n                ')' => {\n       \
    \             if stack.is_empty() {\n                        result = String::from(\"\
    No\");\n                        break;\n                    } else {\n       \
    \                 stack.pop();\n                    }\n                }\n   \
    \             _ => (),\n            }\n        }\n    }\n    if !stack.is_empty()\
    \ {\n        result = String::from(\"No\");\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8igzl59z.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if s2_open == -s1_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmponmrat_2.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpru5waxob.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<char> = lst.into_iter().flat_map(|s| s.chars()).collect();\n\
    \    lst.sort();\n    lst.dedup();\n    if lst.len() == 1 && lst[0] == ')' {\n\
    \        return String::from(\"No\");\n    }\n    String::from(\"Yes\")\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0515]: cannot return reference to function parameter `s`\n  -->\
    \ /tmp/tmpagds5i7h.rs:15:59\n   |\n15 |     let mut lst: Vec<char> = lst.into_iter().flat_map(|s|\
    \ s.chars()).collect();\n   |                                                \
    \           ^^^^^^^^^ returns a reference to data owned by the current function\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0515`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut s = String::new();\n\
    \    for c in lst.pop().unwrap() {\n        s.push(c);\n        if s.ends_with(\"\
    ()\") {\n            s.pop();\n            s.pop();\n        }\n    }\n    if\
    \ s.is_empty() {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprz_dordf.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_cnt = 0;\n \
    \   let mut s2_cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n  \
    \          s1_cnt += 1;\n        } else {\n            s1_cnt -= 1;\n        }\n\
    \    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_cnt +=\
    \ 1;\n        } else {\n            s2_cnt -= 1;\n        }\n    }\n    if s1_cnt\
    \ == 0 && s2_cnt == 0 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ s1_cnt == -1 && s2_cnt == 1 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_cnt == 1 && s2_cnt == -1 {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmps3p16__1.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    s3.push_str(&s1);\n    s3.push_str(&s2);\n\
    \    s4.push_str(&s2);\n    s4.push_str(&s1);\n    s5.push_str(&s1);\n    s5.push_str(&s1);\n\
    \    s6.push_str(&s2);\n    s6.push_str(&s2);\n    s7.push_str(&s1);\n    s7.push_str(&s2);\n\
    \    s7.push_str(&s1);\n    s8.push_str(&s2);\n    s8.push_str(&s1);\n    s8.push_str(&s2);\n\
    \    if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp8qohbuzj.rs:37:8\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp8qohbuzj.rs:37:24\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmp8qohbuzj.rs:37:40\n   |\n37 |     if is_good(&s3) || is_good(&s4)\
    \ || is_good(&s5) || is_good(&s6) || is_good(&s7) || is_good(&s8) {\n   |    \
    \                                    ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmp8qohbuzj.rs:37:56\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmp8qohbuzj.rs:37:72\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmp8qohbuzj.rs:37:88\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                                    ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"No\"\
    );\n    }\n    if s1_open > 0 {\n        s1.reverse();\n        s1.append(&mut\
    \ s2);\n    } else {\n        s2.reverse();\n        s2.append(&mut s1);\n   \
    \ }\n    let mut open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            open += 1;\n        } else {\n            open -= 1;\n        }\n\
    \        if open < 0 {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if open == 0 {\n        return String::from(\"Yes\");\n    }\n   \
    \ String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpn0_jgfhe.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if s2_open == -s1_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpg7y_r_kx.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_cnt = 0;\n \
    \   let mut s2_cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n  \
    \          s1_cnt += 1;\n        } else {\n            s1_cnt -= 1;\n        }\n\
    \    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_cnt +=\
    \ 1;\n        } else {\n            s2_cnt -= 1;\n        }\n    }\n    if s1_cnt\
    \ == 0 && s2_cnt == 0 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ s1_cnt == 0 && s2_cnt != 0 {\n        return String::from(\"No\");\n    }\n\
    \    if s1_cnt != 0 && s2_cnt == 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_cnt > 0 && s2_cnt < 0 {\n        if s1_cnt == -s2_cnt {\n   \
    \         return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s1_cnt < 0 && s2_cnt > 0 {\n        if s2_cnt == -s1_cnt\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp5yikzt85.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_open = 0;\n    let mut s2_open = 0;\n    let mut s1_close = 0;\n\
    \    let mut s2_close = 0;\n    for c in s1.chars() {\n        if c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_close += 1;\n   \
    \     }\n    }\n    for c in s2.chars() {\n        if c == '(' {\n           \
    \ s2_open += 1;\n        } else {\n            s2_close += 1;\n        }\n   \
    \ }\n    if s1_open == s1_close && s2_open == s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open == s1_close {\n        if s2_open > s2_close {\n\
    \            s1.push_str(&s2);\n            return if is_good(&s1) {\n       \
    \         String::from(\"Yes\")\n            } else {\n                String::from(\"\
    No\")\n            };\n        } else {\n            s2.push_str(&s1);\n     \
    \       return if is_good(&s2) {\n                String::from(\"Yes\")\n    \
    \        } else {\n                String::from(\"No\")\n            };\n    \
    \    }\n    }\n    if s2_open == s2_close {\n        if s1_open > s1_close {\n\
    \            s2.push_str(&s1);\n            return if is_good(&s2) {\n       \
    \         String::from(\"Yes\")\n            } else {\n                String::from(\"\
    No\")\n            };\n        } else {\n            s1.push_str(&s2);\n     \
    \       return if is_good(&s1) {\n                String::from(\"Yes\")\n    \
    \        } else {\n                String::from(\"No\")\n            };\n    \
    \    }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpuxtth7z7.rs:41:23\n\
    \   |\n41 |             return if is_good(&s1) {\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_good` in this\
    \ scope\n  --> /tmp/tmpuxtth7z7.rs:48:23\n   |\n48 |             return if is_good(&s2)\
    \ {\n   |                       ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmpuxtth7z7.rs:58:23\n\
    \   |\n58 |             return if is_good(&s2) {\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_good` in this\
    \ scope\n  --> /tmp/tmpuxtth7z7.rs:65:23\n   |\n65 |             return if is_good(&s1)\
    \ {\n   |                       ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        s2.reverse();\n        let mut s2_open\
    \ = 0;\n        let mut s2_close = 0;\n        for c in s2.iter() {\n        \
    \    if *c == '(' {\n                s2_open += 1;\n            } else {\n   \
    \             s2_close += 1;\n            }\n            if s2_open == s2_close\
    \ {\n                return String::from(\"Yes\");\n            }\n        }\n\
    \    } else {\n        if s2_open < s2_close {\n            return String::from(\"\
    No\");\n        }\n        s1.reverse();\n        let mut s1_open = 0;\n     \
    \   let mut s1_close = 0;\n        for c in s1.iter() {\n            if *c ==\
    \ '(' {\n                s1_open += 1;\n            } else {\n               \
    \ s1_close += 1;\n            }\n            if s1_open == s1_close {\n      \
    \          return String::from(\"Yes\");\n            }\n        }\n    }\n  \
    \  String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpmuexyr1p.rs:78:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp892tjueh.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open != s2_close {\n        return String::from(\"\
    No\");\n    }\n    if s1_open != s1_close && s2_open == s2_close {\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open > s1_close {\n        if s2_open\
    \ > s2_close {\n            return String::from(\"Yes\");\n        } else {\n\
    \            return String::from(\"No\");\n        }\n    } else {\n        if\
    \ s2_open > s2_close {\n            return String::from(\"No\");\n        } else\
    \ {\n            return String::from(\"Yes\");\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzre1v_rt.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open > s2_close {\n        let diff = s2_open -\
    \ s2_close;\n        s2.reverse();\n        for _ in 0..diff {\n            s2.push('(');\n\
    \        }\n        s2.reverse();\n        s1.append(&mut s2);\n        let mut\
    \ open = 0;\n        let mut close = 0;\n        for c in s1.iter() {\n      \
    \      if *c == '(' {\n                open += 1;\n            } else {\n    \
    \            close += 1;\n            }\n            if open < close {\n     \
    \           return String::from(\"No\");\n            }\n        }\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_open > s1_close && s2_open == s2_close\
    \ {\n        let diff = s1_open - s1_close;\n        s1.reverse();\n        for\
    \ _ in 0..diff {\n            s1.push('(');\n        }\n        s1.reverse();\n\
    \        s1.append(&mut s2);\n        let mut open = 0;\n        let mut close\
    \ = 0;\n        for c in s1.iter() {\n           \n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptb4o99ow.rs:88:3\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - unclosed delimiter\n...\n60 |     if s1_open\
    \ > s1_close && s2_open == s2_close {\n   |                                  \
    \                - unclosed delimiter\n...\n70 |         for c in s1.iter() {\n\
    \   |                            - this delimiter might not be properly closed...\n\
    71 |            \n72 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n88 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptb4o99ow.rs:60:50\n\
    \   |\n60 |       if s1_open > s1_close && s2_open == s2_close {\n   |  __________________________________________________^\n\
    61 | |         let diff = s1_open - s1_close;\n62 | |         s1.reverse();\n\
    63 | |         for _ in 0..diff {\n...  |\n87 | |     assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n88 | | }\n   | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    s1.push_str(&s2);\n    if is_good(&s1) {\n        return String::from(\"\
    Yes\");\n    }\n    s1.clear();\n    s2.push_str(&lst[0]);\n    if is_good(&s2)\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpo2kcmu66.rs:18:8\n\
    \   |\n18 |     if is_good(&s1) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpo2kcmu66.rs:23:8\n\
    \   |\n23 |     if is_good(&s2) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"No\"\
    );\n    }\n    if s1_open > 0 {\n        while s1_open > 0 {\n            s1.push(')');\n\
    \            s1_open -= 1;\n        }\n        s1.append(&mut s2);\n    } else\
    \ {\n        while s2_open > 0 {\n            s2.push(')');\n            s2_open\
    \ -= 1;\n        }\n        s2.append(&mut s1);\n    }\n    let mut open = 0;\n\
    \    for c in s2.iter() {\n        if *c == '(' {\n            open += 1;\n  \
    \      } else {\n            open -= 1;\n        }\n        if open < 0 {\n  \
    \          return String::from(\"No\");\n        }\n    }\n    if open == 0 {\n\
    \        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp9_9na_ru.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    s1.append(&mut s2);\n \
    \   let mut count = 0;\n    for c in s1 {\n        if c == '(' {\n           \
    \ count += 1;\n        } else {\n            count -= 1;\n        }\n        if\
    \ count < 0 {\n            return String::from(\"No\");\n        }\n    }\n  \
    \  if count == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpoxb66v7g.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdmeic_t6.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_count = 0;\n\
    \    let mut s2_count = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_count += 1;\n        } else {\n            s1_count -= 1;\n  \
    \      }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n          \
    \  s2_count += 1;\n        } else {\n            s2_count -= 1;\n        }\n \
    \   }\n    if s1_count == 0 && s2_count == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_count == 0 && s2_count != 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_count != 0 && s2_count == 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_count > 0 && s2_count < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_count < 0 && s2_count > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_count > 0 && s2_count > 0 {\n        if s1_count > s2_count\
    \ {\n            return String::from(\"Yes\");\n        } else {\n           \
    \ return String::from(\"No\");\n        }\n    }\n    if s1_count < 0 && s2_count\
    \ < 0 {\n        if s1_count < s2_count {\n            return String::from(\"\
    Yes\");\n        } else {\n            return String::from(\"No\");\n        }\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpq_kl4uin.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    if s.chars().filter(|&x| x == '(').count() == s.chars().filter(|&x|\
    \ x == ')').count() {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpdjw085bd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9cr17rk8.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => parens += 1,\n            \
    \    ')' => parens -= 1,\n                _ => panic!(\"Invalid character\"),\n\
    \            }\n            if parens < 0 {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if parens == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpp6ld3otp.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpaxrgdepb.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        if s2_open < s2_close {\n        \
    \    if s2_close - s2_open > s1_open - s1_close {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if s1_open < s1_close {\n       \
    \ if s2_open < s2_close {\n            return String::from(\"No\");\n        }\n\
    \        if s2_open > s2_close {\n            if s2_open - s2_close > s1_close\
    \ - s1_open {\n                return String::from(\"No\");\n            }\n \
    \       }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpvrmju5ro.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = String::new();\n    for s in lst {\n     \
    \   parens.push_str(&s);\n    }\n    let mut balance = 0;\n    for c in parens.chars()\
    \ {\n        if c == '(' {\n            balance += 1;\n        } else {\n    \
    \        balance -= 1;\n        }\n        if balance < 0 {\n            return\
    \ String::from(\"No\");\n        }\n    }\n    if balance == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp07drhasy.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut s = String::new();\n    let mut i = 0;\n    while i < lst.len() {\n\
    \        if lst[i].len() == 0 {\n            lst.remove(i);\n        } else {\n\
    \            s.push(lst[i].remove(0));\n            i += 1;\n        }\n    }\n\
    \    let mut stack = Vec::new();\n    for c in s.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else {\n            if stack.len()\
    \ == 0 {\n                return String::from(\"No\");\n            } else {\n\
    \                stack.pop();\n            }\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpcousxx6o.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    let mut count = 0;\n    for c in s.chars() {\n        if c == '(' {\n   \
    \         count += 1;\n        } else {\n            count -= 1;\n        }\n\
    \        if count < 0 {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else {\n   \
    \     String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4ux6updz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_count = 0;\n\
    \    let mut s2_count = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_count += 1;\n        } else {\n            s1_count -= 1;\n  \
    \      }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n          \
    \  s2_count += 1;\n        } else {\n            s2_count -= 1;\n        }\n \
    \   }\n    if s1_count == 0 && s2_count == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_count < 0 || s2_count < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_count == s2_count {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_count > s2_count {\n        s1.push('(');\n        s1.append(&mut\
    \ s2);\n    } else {\n        s2.push('(');\n        s2.append(&mut s1);\n   \
    \ }\n    let mut count = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            count += 1;\n        } else {\n            count -= 1;\n        }\n\
    \        if count < 0 {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if count == 0 {\n        return String::from(\"Yes\");\n    }\n  \
    \  String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp12_pdfv8.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            if c == '(' {\n                count += 1;\n            } else\
    \ {\n                count -= 1;\n            }\n            if count < 0 {\n\
    \                return String::from(\"No\");\n            }\n        }\n    }\n\
    \    if count == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp3m6vcy5e.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == s2_open && s1_open > 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open == -s2_open && s1_open < 0 {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4vd_z80f.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_count = 0;\n\
    \    let mut s2_count = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_count += 1;\n        } else {\n            s1_count -= 1;\n  \
    \      }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n          \
    \  s2_count += 1;\n        } else {\n            s2_count -= 1;\n        }\n \
    \   }\n    if s1_count == 0 && s2_count == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_count == 0 && s2_count < 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_count > 0 && s2_count == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_count > 0 && s2_count < 0 {\n        if s1_count ==\
    \ -s2_count {\n            return String::from(\"Yes\");\n        }\n    }\n \
    \   if s1_count < 0 && s2_count == 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_count < 0 && s2_count > 0 {\n        if s2_count == -s1_count\
    \ {\n            return String::from(\"Yes\");\n        }\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp6gq3owvr.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpcrart_m8.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open < 0 {\n        s1_open = -s1_open;\n        for _ in 0..s1_open\
    \ {\n            s1.push(')');\n        }\n    } else if s2_open < 0 {\n     \
    \   s2_open = -s2_open;\n        for _ in 0..s2_open {\n            s2.push(')');\n\
    \        }\n    }\n    let mut s1_open = 0;\n    let mut s2_open = 0;\n    for\
    \ c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n      \
    \  } else {\n            s1_open -= 1;\n        }\n    }\n    for c in s2.iter()\
    \ {\n        if *c == '(' {\n            s2_open += 1;\n        } else {\n   \
    \         s2_open -= 1;\n        }\n    }\n    if s1_open == 0 && s2_open == 0\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp28ejmkek.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    s1.append(&mut s2);\n \
    \   let mut count = 0;\n    for c in s1 {\n        if c == '(' {\n           \
    \ count += 1;\n        } else {\n            count -= 1;\n        }\n        if\
    \ count < 0 {\n            return String::from(\"No\");\n        }\n    }\n  \
    \  if count == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpul4jxpxe.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut res = String::new();\n    let mut i = 0;\n    while i < lst.len()\
    \ {\n        if lst[i].len() == 0 {\n            lst.remove(i);\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    while lst.len() > 0 {\n      \
    \  let mut i = 0;\n        while i < lst.len() {\n            if lst[i].len()\
    \ == 0 {\n                lst.remove(i);\n            } else {\n             \
    \   i += 1;\n            }\n        }\n        if lst.len() == 0 {\n         \
    \   break;\n        }\n        let mut i = 0;\n        while i < lst.len() {\n\
    \            if lst[i][0] == '(' {\n                let mut j = i + 1;\n     \
    \           while j < lst.len() {\n                    if lst[j][0] == ')' {\n\
    \                        break;\n                    }\n                    j\
    \ += 1;\n                }\n                if j == lst.len() {\n            \
    \        return String::from(\"No\");\n                }\n                lst[i].remove(0);\n\
    \                lst[j].remove(0);\n                if lst[i].len() == 0 {\n \
    \                   lst.remove(i);\n                }\n                if lst[j].len()\
    \ == 0 {\n                    lst.remove(j);\n                }\n            \
    \    res.push('(');\n                res.push(')');\n            } else {\n  \
    \              i += 1;\n            }\n        }\n    }\n    if is_good(&res)\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpt_z1_exw.rs:65:8\n\
    \   |\n65 |     if is_good(&res) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    let mut s = String::new();\n    let\
    \ mut open = 0;\n    let mut close = 0;\n    for i in 0..2 {\n        let mut\
    \ s1 = lst.remove(0);\n        for c in s1.chars() {\n            if c == '('\
    \ {\n                open += 1;\n            } else {\n                close +=\
    \ 1;\n            }\n        }\n        s.push_str(&s1);\n    }\n    if open ==\
    \ close {\n        return String::from(\"Yes\");\n    }\n    let mut open = 0;\n\
    \    let mut close = 0;\n    for c in s.chars() {\n        if c == '(' {\n   \
    \         open += 1;\n        } else {\n            close += 1;\n        }\n \
    \       if close > open {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if open == close {\n        return String::from(\"Yes\");\n    }\n\
    \    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpgsxfi8he.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst_iter = lst.iter();\n    let mut s1 = lst_iter.next().unwrap();\n\
    \    let mut s2 = lst_iter.next().unwrap();\n    let mut s1_iter = s1.chars();\n\
    \    let mut s2_iter = s2.chars();\n    let mut s1_parens = Vec::new();\n    let\
    \ mut s2_parens = Vec::new();\n    let mut s1_parens_iter = s1_parens.iter();\n\
    \    let mut s2_parens_iter = s2_parens.iter();\n    let mut s1_parens_iter_mut\
    \ = s1_parens.iter_mut();\n    let mut s2_parens_iter_mut = s2_parens.iter_mut();\n\
    \    let mut s1_parens_iter_mut_rev = s1_parens.iter_mut().rev();\n    let mut\
    \ s2_parens_iter_mut_rev = s2_parens.iter_mut().rev();\n    let mut s1_parens_iter_rev\
    \ = s1_parens.iter().rev();\n    let mut s2_parens_iter_rev = s2_parens.iter().rev();\n\
    \    let mut s1_parens_iter_rev_mut = s1_parens.iter_mut().rev();\n    let mut\
    \ s2_parens_iter_rev_mut = s2_parens.iter_mut().rev();\n    let mut s1_parens_iter_rev_mut_rev\
    \ = s1_parens.iter_mut().rev().rev();\n    let mut s2_parens_iter_rev_mut_rev\
    \ = s2_parens.iter_mut().rev().rev();\n    let mut s1_parens_iter_mut_rev_rev\
    \ = s1_parens.iter_mut().rev().rev();\n    let mut s2_parens_iter_mut_rev_rev\
    \ = s2_parens.iter_mut().rev().rev();\n    let mut s1_parens_iter_mut_rev_rev_rev\
    \ = s1_parens.iter_mut().\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmph1x8bfg0.rs:37:1\n   |\n37\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmph1x8bfg0.rs:36:67\n\
    \   |\n36 |     let mut s1_parens_iter_mut_rev_rev_rev = s1_parens.iter_mut().\n\
    \   |                                                                   ^ help:\
    \ add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph1x8bfg0.rs:14:38\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |    ------------                      ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9h09df_d.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut balance = 0;\n    for s in lst {\n        for c in\
    \ s.chars() {\n            if c == '(' {\n                balance += 1;\n    \
    \        } else {\n                balance -= 1;\n            }\n            if\
    \ balance < 0 {\n                return String::from(\"No\");\n            }\n\
    \        }\n    }\n    if balance == 0 {\n        String::from(\"Yes\")\n    }\
    \ else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpvvou3se1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if s2_open == -s1_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpuhmmvwzc.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = vec![];\n\
    \    let mut s4 = vec![];\n    let mut s5 = vec![];\n    let mut s6 = vec![];\n\
    \    let mut s7 = vec![];\n    let mut s8 = vec![];\n    let mut s9 = vec![];\n\
    \    let mut s10 = vec![];\n    let mut s11 = vec![];\n    let mut s12 = vec![];\n\
    \    let mut s13 = vec![];\n    let mut s14 = vec![];\n    let mut s15 = vec![];\n\
    \    let mut s16 = vec![];\n    let mut s17 = vec![];\n    let mut s18 = vec![];\n\
    \    let mut s19 = vec![];\n    let mut s20 = vec![];\n    let mut s21 = vec![];\n\
    \    let mut s22 = vec![];\n    let mut s23 = vec![];\n    let mut s24 = vec![];\n\
    \    let mut s25 = vec![];\n    let mut s26 = vec![];\n    let mut s27 = vec![];\n\
    \    let mut s28 = vec![];\n    let mut s29 = vec![];\n    let mut s30 = vec![];\n\
    \    let mut s31 = vec![];\n    let mut s32 = vec![];\n    let mut s33 = vec![];\n\
    \    let mut s34 = vec![];\n    let mut s35 = vec![];\n    let mut s36 = vec![];\n\
    \    let mut s37 = vec![];\n    let mut s38 = vec![];\n    let mut s39 = vec![];\n\
    \    let mut s40 = vec![];\n    let mut s41 = vec![];\n    let mut s42 = vec![];\n\
    \    let mut s43 = vec![];\n    let mut s44 = vec![];\n   \n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1eek63sl.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open != s2_close {\n        if s2_open > s2_close\
    \ {\n            s2.reverse();\n            s2_open = 0;\n            s2_close\
    \ = 0;\n            for c in s2.iter() {\n                if *c == '(' {\n   \
    \                 s2_open += 1;\n                } else {\n                  \
    \  s2_close += 1;\n                }\n            }\n        }\n        if s2_open\
    \ < s2_close {\n            return String::from(\"No\");\n        }\n        if\
    \ s2_open == s2_close {\n            return String::from(\"Yes\");\n        }\n\
    \    }\n    if s1_open != s1_close && s2_open == s2_close {\n        if s1_open\
    \ > s1_close {\n            s1.reverse();\n            s1_open = 0;\n        \
    \    s1_close = 0;\n            for c in s1.iter() {\n                if *c ==\
    \ '(' {\n                    s1_open += 1;\n                } else {\n       \
    \             s1_close += 1;\n                }\n            }\n        }\n  \
    \      if s1_open <\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplv_u0m34.rs:88:3\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - unclosed delimiter\n...\n58 |     if s1_open\
    \ != s1_close && s2_open == s2_close {\n   |                                 \
    \                  - this delimiter might not be properly closed...\n...\n72 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n88 |\
    \ }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmplv_u0m34.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplv_u0m34.rs:14:38\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |    ------------                      ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    let mut res = String::new();\n    let\
    \ mut count = 0;\n    while !lst.is_empty() {\n        let s = lst.pop().unwrap();\n\
    \        for c in s.chars() {\n            if c == '(' {\n                count\
    \ += 1;\n            } else {\n                count -= 1;\n            }\n  \
    \          if count < 0 {\n                return String::from(\"No\");\n    \
    \        }\n        }\n        res.push_str(&s);\n    }\n    if count == 0 {\n\
    \        String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7zobphi_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7kn9zkwm.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter();\n    let mut s1 = lst.next().unwrap();\n\
    \    let mut s2 = lst.next().unwrap();\n    let mut s1_open = 0;\n    let mut\
    \ s2_open = 0;\n    for c in s1.chars() {\n        if c == '(' {\n           \
    \ s1_open += 1;\n        } else {\n            s1_open -= 1;\n        }\n    }\n\
    \    for c in s2.chars() {\n        if c == '(' {\n            s2_open += 1;\n\
    \        } else {\n            s2_open -= 1;\n        }\n    }\n    if s1_open\
    \ < 0 || s2_open < 0 {\n        return String::from(\"No\");\n    }\n    if s1_open\
    \ == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ s1_open == 0 {\n        return match_parens(vec![s2, s1]);\n    }\n    if s2_open\
    \ == 0 {\n        return match_parens(vec![s1, s2]);\n    }\n    if s1_open >\
    \ s2_open {\n        return match_parens(vec![s2, s1]);\n    }\n    match_parens(vec![s1,\
    \ s2])\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyh_4_sju.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6mu6sk4d.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut res = String::from(\"\
    Yes\");\n    for s in lst {\n        for c in s.chars() {\n            if c ==\
    \ '(' {\n                stack.push(c);\n            } else {\n              \
    \  if stack.is_empty() {\n                    res = String::from(\"No\");\n  \
    \                  break;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n        }\n    }\n    if !stack.is_empty()\
    \ {\n        res = String::from(\"No\");\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0nskjh9x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else {\n   \
    \         if stack.is_empty() {\n                return String::from(\"No\");\n\
    \            }\n            stack.pop();\n        }\n    }\n    for c in lst[1].chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else {\n   \
    \         if stack.is_empty() {\n                return String::from(\"No\");\n\
    \            }\n            stack.pop();\n        }\n    }\n    if stack.is_empty()\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpu4f56hbc.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            left += 1;\n        } else {\n       \
    \     right += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            left -= 1;\n        } else {\n            right -= 1;\n\
    \        }\n    }\n    if left == 0 && right == 0 {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7wc93jx3.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            left += 1;\n        } else {\n       \
    \     right += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            left -= 1;\n        } else {\n            right -= 1;\n\
    \        }\n    }\n    if left == 0 && right == 0 {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpaytyzowg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open > s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s2_open == s2_close && s1_open > s1_close {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_open > s1_close && s2_open > s2_close\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpkjlhlmtq.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpcrgfljo5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplp01px3r.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_open = 0;\n    let mut s2_open = 0;\n    for c in s1.chars() {\n\
    \        if c == '(' {\n            s1_open += 1;\n        } else {\n        \
    \    s1_open -= 1;\n        }\n    }\n    for c in s2.chars() {\n        if c\
    \ == '(' {\n            s2_open += 1;\n        } else {\n            s2_open -=\
    \ 1;\n        }\n    }\n    if s1_open == 0 && s2_open == 0 {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_open == 0 && s2_open < 0 {\n      \
    \  return String::from(\"Yes\");\n    }\n    if s1_open > 0 && s2_open == 0 {\n\
    \        return String::from(\"Yes\");\n    }\n    if s1_open < 0 && s2_open ==\
    \ 0 {\n        return String::from(\"Yes\");\n    }\n    if s1_open > 0 && s2_open\
    \ < 0 {\n        if s1_open == -s2_open {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if s2_open\
    \ == -s1_open {\n            return String::from(\"Yes\");\n        }\n    }\n\
    \    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpksrm8u24.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<char> = lst.join(\"\").chars().collect();\n\
    \    let mut count = 0;\n    for c in lst.iter() {\n        if *c == '(' {\n \
    \           count += 1;\n        } else {\n            count -= 1;\n        }\n\
    \        if count < 0 {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else {\n   \
    \     String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpqk9hrfx7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    let mut s1_done = false;\n    let mut s2_done\
    \ = false;\n    loop {\n        if !s1_done {\n            match s1.next() {\n\
    \                Some(c) => {\n                    if c == '(' {\n           \
    \             stack.push(c);\n                    } else {\n                 \
    \       if stack.is_empty() {\n                            return String::from(\"\
    No\");\n                        } else {\n                            stack.pop();\n\
    \                        }\n                    }\n                }\n       \
    \         None => s1_done = true,\n            }\n        }\n        if !s2_done\
    \ {\n            match s2.next() {\n                Some(c) => {\n           \
    \         if c == '(' {\n                        stack.push(c);\n            \
    \        } else {\n                        if stack.is_empty() {\n           \
    \                 return String::from(\"No\");\n                        } else\
    \ {\n                            stack.pop();\n                        }\n   \
    \                 }\n                }\n                None => s2_done = true,\n\
    \            }\n        }\n        if s1_done && s2_done {\n            break;\n\
    \        }\n    }\n    if stack.is_empty() {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp439_57ix.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1rmklql.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        if s1_open + s2_open ==\
    \ 0 {\n            return String::from(\"Yes\");\n        }\n    }\n    if s1_open\
    \ > 0 && s2_open > 0 {\n        if s1_open + s2_open == 0 {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    return String::from(\"No\");\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0o1pd4aq.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmptrtl41tq.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut s = String::new();\n\
    \    for c in lst[0].chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \            } else {\n                return String::from(\"No\");\n        \
    \    }\n        }\n    }\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    for c in s.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \            } else {\n                return String::from(\"No\");\n        \
    \    }\n        }\n    }\n    if stack.len() == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpdz6y3ddp.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            if c == '(' {\n                parens += 1;\n            } else\
    \ {\n                parens -= 1;\n            }\n            if parens < 0 {\n\
    \                return String::from(\"No\");\n            }\n        }\n    }\n\
    \    if parens == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzbb3z8rm.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open != 0 {\n        s1.append(&mut s2);\n        let\
    \ mut open = 0;\n        for c in s1.iter() {\n            if *c == '(' {\n  \
    \              open += 1;\n            } else {\n                open -= 1;\n\
    \            }\n            if open < 0 {\n                return String::from(\"\
    No\");\n            }\n        }\n        if open == 0 {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    if s1_open != 0 && s2_open == 0 {\n        s2.append(&mut\
    \ s1);\n        let mut open = 0;\n        for c in s2.iter() {\n            if\
    \ *c == '(' {\n                open += 1;\n            } else {\n            \
    \    open -= 1;\n            }\n            if open < 0 {\n                return\
    \ String::from(\"No\");\n            }\n        }\n        if open == 0 {\n  \
    \          return String::from(\"Yes\");\n        }\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbh6g7g1u.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"\
    No\");\n    }\n    if s1_open > 0 && s2_open < 0 {\n        if s1_open == -s2_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    if s1_open < 0 && s2_open > 0 {\n        if s2_open == -s1_open\
    \ {\n            return String::from(\"Yes\");\n        }\n        return String::from(\"\
    No\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpa0xwl4t3.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    if is_good(&s) {\n        String::from(\"Yes\")\n    } else {\n  \
    \      String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpz917tzm9.rs:19:8\n\
    \   |\n19 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    s3.push_str(&s1);\n    s3.push_str(&s2);\n\
    \    s4.push_str(&s2);\n    s4.push_str(&s1);\n    s5.push_str(&s1);\n    s5.push_str(&s1);\n\
    \    s6.push_str(&s2);\n    s6.push_str(&s2);\n    s7.push_str(&s1);\n    s7.push_str(&s2);\n\
    \    s7.push_str(&s1);\n    s8.push_str(&s2);\n    s8.push_str(&s1);\n    s8.push_str(&s2);\n\
    \    if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp4tmhntth.rs:37:8\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp4tmhntth.rs:37:24\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmp4tmhntth.rs:37:40\n   |\n37 |     if is_good(&s3) || is_good(&s4)\
    \ || is_good(&s5) || is_good(&s6) || is_good(&s7) || is_good(&s8) {\n   |    \
    \                                    ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmp4tmhntth.rs:37:56\n\
    \   |\n37 |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6)\
    \ || is_good(&s7) || is_good(&s8) {\n   |                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmp4tmhntth.rs:37:72\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_good` in this scope\n  --> /tmp/tmp4tmhntth.rs:37:88\n   |\n37\
    \ |     if is_good(&s3) || is_good(&s4) || is_good(&s5) || is_good(&s6) || is_good(&s7)\
    \ || is_good(&s8) {\n   |                                                    \
    \                                    ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open > 0 && s2_open > 0 {\n        return String::from(\"No\"\
    );\n    }\n    if s1_open > 0 {\n        s1.append(&mut s2);\n    } else {\n \
    \       s2.append(&mut s1);\n    }\n    let mut open = 0;\n    for c in s1.iter()\
    \ {\n        if *c == '(' {\n            open += 1;\n        } else {\n      \
    \      open -= 1;\n        }\n        if open < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmptllaab5g.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    for ch in lst[0].chars()\
    \ {\n        if ch == '(' {\n            left += 1;\n        } else {\n      \
    \      right += 1;\n        }\n    }\n    for ch in lst[1].chars() {\n       \
    \ if ch == '(' {\n            left -= 1;\n        } else {\n            right\
    \ -= 1;\n        }\n    }\n    if left == 0 && right == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpnw2sd3sw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut s = String::new();\n    let mut cnt = 0;\n    for i in 0..2 {\n \
    \       for c in lst[i].iter() {\n            if *c == '(' {\n               \
    \ cnt += 1;\n            } else {\n                cnt -= 1;\n            }\n\
    \            if cnt < 0 {\n                break;\n            }\n        }\n\
    \        if cnt < 0 {\n            break;\n        }\n    }\n    if cnt == 0 {\n\
    \        s.push_str(\"Yes\");\n    } else {\n        s.push_str(\"No\");\n   \
    \ }\n    s\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpjvj7brad.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        return String::from(\"No\");\n \
    \   }\n    if s1_open < 0 {\n        s1_open = -s1_open;\n        for _ in 0..s1_open\
    \ {\n            s1.push(')');\n        }\n    } else if s2_open < 0 {\n     \
    \   s2_open = -s2_open;\n        for _ in 0..s2_open {\n            s2.push(')');\n\
    \        }\n    }\n    let mut s1_open = 0;\n    let mut s2_open = 0;\n    for\
    \ c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n      \
    \  } else {\n            s1_open -= 1;\n        }\n    }\n    for c in s2.iter()\
    \ {\n        if *c == '(' {\n            s2_open += 1;\n        } else {\n   \
    \         s2_open -= 1;\n        }\n    }\n    if s1_open == 0 && s2_open == 0\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpq6nm228x.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = s1.clone();\n\
    \    s3.append(&mut s2);\n    if is_good(&s3) {\n        return String::from(\"\
    Yes\");\n    }\n    s1.append(&mut s2);\n    if is_good(&s1) {\n        return\
    \ String::from(\"Yes\");\n    }\n    s2.append(&mut s3);\n    if is_good(&s2)\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp2crh9rig.rs:19:8\n\
    \   |\n19 |     if is_good(&s3) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp2crh9rig.rs:23:8\n\
    \   |\n23 |     if is_good(&s1) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp2crh9rig.rs:27:8\n\
    \   |\n27 |     if is_good(&s2) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_count = 0;\n    let mut s2_count = 0;\n    for c in s1.chars()\
    \ {\n        if c == '(' {\n            s1_count += 1;\n        } else {\n   \
    \         s1_count -= 1;\n        }\n    }\n    for c in s2.chars() {\n      \
    \  if c == '(' {\n            s2_count += 1;\n        } else {\n            s2_count\
    \ -= 1;\n        }\n    }\n    if s1_count == 0 && s2_count == 0 {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_count == 0 && s2_count > 0 {\n    \
    \    for _ in 0..s2_count {\n            s1.push(')');\n        }\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_count < 0 && s2_count == 0 {\n    \
    \    for _ in 0..s1_count.abs() {\n            s2.push('(');\n        }\n    \
    \    return String::from(\"Yes\");\n    }\n    if s1_count > 0 && s2_count < 0\
    \ {\n        for _ in 0..s1_count {\n            s2.push(')');\n        }\n  \
    \      for _ in 0..s2_count.abs() {\n            s1.push('(');\n        }\n  \
    \      return String::from(\"Yes\");\n    }\n    return String::from(\"No\");\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmplmlxzh2j.rs:43:30\n   |\n43 |         for _ in 0..s1_count.abs()\
    \ {\n   |                              ^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n17 |     let mut s1_count: i32 = 0;\n  \
    \ |         ~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `abs` on ambiguous\
    \ numeric type `{integer}`\n  --> /tmp/tmplmlxzh2j.rs:52:30\n   |\n52 |      \
    \   for _ in 0..s2_count.abs() {\n   |                              ^^^\n   |\n\
    help: you must specify a type for this binding, like `i32`\n   |\n18 |     let\
    \ mut s2_count: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            left += 1;\n        } else {\n       \
    \     right += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            left -= 1;\n        } else {\n            right -= 1;\n\
    \        }\n    }\n    if left == 0 && right == 0 {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpjv75eijk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    if s.len() % 2 != 0 {\n        return String::from(\"No\");\n    }\n\
    \    let mut stack = Vec::new();\n    for c in s.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else {\n            if stack.len()\
    \ == 0 {\n                return String::from(\"No\");\n            }\n      \
    \      stack.pop();\n        }\n    }\n    if stack.len() == 0 {\n        return\
    \ String::from(\"Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpe778uuts.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        s2.reverse();\n        for c in\
    \ s2.iter() {\n            if *c == '(' {\n                s2_open += 1;\n   \
    \         } else {\n                s2_open -= 1;\n            }\n           \
    \ if s2_open == 0 {\n                return String::from(\"Yes\");\n         \
    \   }\n        }\n    }\n    if s2_open == 0 && s1_open < 0 {\n        s1.reverse();\n\
    \        for c in s1.iter() {\n            if *c == '(' {\n                s1_open\
    \ += 1;\n            } else {\n                s1_open -= 1;\n            }\n\
    \            if s1_open == 0 {\n                return String::from(\"Yes\");\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzhylhp58.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpslpteb0s.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            open += 1;\n        } else {\n       \
    \     close += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            open -= 1;\n        } else {\n            close -= 1;\n\
    \        }\n    }\n    if open == 0 && close == 0 {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprovuxwp1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close && s2_open > s2_close {\n        return String::from(\"\
    Yes\");\n    }\n    if s1_open < s1_close && s2_open < s2_close {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_open > s1_close && s2_open < s2_close\
    \ {\n        if s1_open - s1_close == s2_close - s2_open {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    if s1_open < s1_close && s2_open\
    \ > s2_close {\n        if s1_close - s1_open == s2_open - s2_close {\n      \
    \      return String::from(\"Yes\");\n        }\n    }\n    String::from(\"No\"\
    )\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmppk9pcj89.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut ans = String::new();\n    let mut stack = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < lst[0].len() && j < lst[1].len() {\n\
    \        if lst[0][i] == '(' {\n            stack.push(lst[0][i]);\n        }\
    \ else {\n            if stack.is_empty() {\n                ans.push(lst[1][j]);\n\
    \                j += 1;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n        i += 1;\n    }\n    if stack.is_empty() {\n\
    \        ans.push_str(&lst[0][i..].iter().collect::<String>());\n        ans.push_str(&lst[1][j..].iter().collect::<String>());\n\
    \        if ans.chars().filter(|&c| c == '(').count() == ans.chars().filter(|&c|\
    \ c == ')').count() {\n            return String::from(\"Yes\");\n        }\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp9cdzaa43.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open == s1_close && s2_open > s2_close {\n        s2.reverse();\n    \
    \    s2.push('(');\n        s2.reverse();\n        s2.push(')');\n        let\
    \ mut s2_open = 0;\n        let mut s2_close = 0;\n        for c in s2.iter()\
    \ {\n            if *c == '(' {\n                s2_open += 1;\n            }\
    \ else {\n                s2_close += 1;\n            }\n        }\n        if\
    \ s2_open == s2_close {\n            return String::from(\"Yes\");\n        }\n\
    \    }\n    if s1_open > s1_close && s2_open == s2_close {\n        s1.reverse();\n\
    \        s1.push('(');\n        s1.reverse();\n        s1.push(')');\n       \
    \ let mut s1_open = 0;\n        let mut s1_close = 0;\n        for c in s1.iter()\
    \ {\n            if *c == '(' {\n                s1_open += 1;\n            }\
    \ else {\n                s1_close += 1;\n            }\n        }\n        if\
    \ s1_open\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0_pz177s.rs:87:3\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - unclosed delimiter\n...\n56 |     if s1_open\
    \ > s1_close && s2_open == s2_close {\n   |                                  \
    \                - this delimiter might not be properly closed...\n...\n71 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n87 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp0_pz177s.rs:71:1\n\
    \   |\n70 |         if s1_open\n   |         -- this `if` expression has a condition,\
    \ but no block\n71 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_pz177s.rs:14:38\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |    ------------                      ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s3 = String::new();\n\
    \    let mut s4 = String::new();\n    let mut s5 = String::new();\n    let mut\
    \ s6 = String::new();\n    let mut s7 = String::new();\n    let mut s8 = String::new();\n\
    \    let mut s9 = String::new();\n    let mut s10 = String::new();\n    let mut\
    \ s11 = String::new();\n    let mut s12 = String::new();\n    let mut s13 = String::new();\n\
    \    let mut s14 = String::new();\n    let mut s15 = String::new();\n    let mut\
    \ s16 = String::new();\n    let mut s17 = String::new();\n    let mut s18 = String::new();\n\
    \    let mut s19 = String::new();\n    let mut s20 = String::new();\n    let mut\
    \ s21 = String::new();\n    let mut s22 = String::new();\n    let mut s23 = String::new();\n\
    \    let mut s24 = String::new();\n    let mut s25 = String::new();\n    let mut\
    \ s26 = String::new();\n    let mut s27 = String::new();\n    let mut s28 = String::new();\n\
    \    let mut s29 = String::new();\n    let mut s30 = String::new();\n    let mut\
    \ s31 = String::new();\n    let mut s32 = String::new();\n    let mut s33 = String::new();\n\
    \    let mut s34 = String::new();\n    let mut s35 = String::new();\n    let mut\
    \ s36 = String::new();\n    let mut s37 = String::new();\n    let mut s38 = String::new();\n\
    \    let mut s39 = String::new();\n    let mut s40 = String::new();\n    let mut\
    \ s41 = String::new();\n    let mut s42 = String::new();\n    let mut s43 = String::new();\n\
    \    let mut s44 = String::new();\n   \n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkls81_5.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < s1.len() && j < s2.len() {\n        if s1[i..i + 1] == \"(\" {\n       \
    \     s.push_str(\"(\");\n            i += 1;\n        } else if s2[j..j + 1]\
    \ == \")\" {\n            s.push_str(\")\");\n            j += 1;\n        } else\
    \ {\n            break;\n        }\n    }\n    s.push_str(&s1[i..]);\n    s.push_str(&s2[j..]);\n\
    \    if is_good(&s) {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpb4d7cz6f.rs:33:8\n\
    \   |\n33 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpb4d7cz6f.rs:21:25\n\
    \   |\n21 |         if s1[i..i + 1] == \"(\" {\n   |                         ^^\
    \ no implementation for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `str` with `&str`\n  -->\
    \ /tmp/tmpb4d7cz6f.rs:24:32\n   |\n24 |         } else if s2[j..j + 1] == \")\"\
    \ {\n   |                                ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut s = String::new();\n\
    \    for c in lst.pop().unwrap() {\n        s.push(c);\n        if s.len() > 1\
    \ && s.chars().last().unwrap() == ')' && s.chars().nth(s.len() - 2).unwrap() ==\
    \ '(' {\n            s.pop();\n            s.pop();\n        }\n    }\n    for\
    \ c in lst.pop().unwrap() {\n        s.push(c);\n        if s.len() > 1 && s.chars().last().unwrap()\
    \ == ')' && s.chars().nth(s.len() - 2).unwrap() == '(' {\n            s.pop();\n\
    \            s.pop();\n        }\n    }\n    if s.len() == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpf526onth.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut stack = Vec::new();\n    for c in s.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                return String::from(\"No\");\n            } else {\n    \
    \            stack.pop();\n            }\n        }\n    }\n    if stack.is_empty()\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp31y6vccr.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbfe6bc84.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3x7sndwo.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            if c == '(' {\n                cnt += 1;\n            } else\
    \ {\n                cnt -= 1;\n            }\n            if cnt < 0 {\n    \
    \            return String::from(\"No\");\n            }\n        }\n    }\n \
    \   if cnt == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp9tki_98f.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut s = String::new();\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    if is_good(&s) {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp0gjeehop.rs:20:8\n\
    \   |\n20 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    if s.len() % 2 == 1 {\n        return String::from(\"No\");\n    }\n\
    \    let mut stack = vec![];\n    for c in s.chars() {\n        if c == '(' {\n\
    \            stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ stack.pop();\n        }\n    }\n    if stack.is_empty() {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp9miax3bo.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s1_count = 0;\n    let mut s2_count = 0;\n    for c in s1.chars()\
    \ {\n        if c == '(' {\n            s1_count += 1;\n        } else {\n   \
    \         s1_count -= 1;\n        }\n    }\n    for c in s2.chars() {\n      \
    \  if c == '(' {\n            s2_count += 1;\n        } else {\n            s2_count\
    \ -= 1;\n        }\n    }\n    if s1_count == 0 && s2_count == 0 {\n        return\
    \ String::from(\"Yes\");\n    }\n    if s1_count == 0 && s2_count != 0 {\n   \
    \     return String::from(\"No\");\n    }\n    if s1_count != 0 && s2_count ==\
    \ 0 {\n        return String::from(\"No\");\n    }\n    if s1_count < 0 && s2_count\
    \ > 0 {\n        return String::from(\"No\");\n    }\n    if s1_count > 0 && s2_count\
    \ < 0 {\n        return String::from(\"No\");\n    }\n    if s1_count > 0 && s2_count\
    \ > 0 {\n        if s1_count > s2_count {\n            return String::from(\"\
    Yes\");\n        } else {\n            return String::from(\"No\");\n        }\n\
    \    }\n    if s1_count < 0 && s2_count < 0 {\n        if s1_count < s2_count\
    \ {\n            return String::from(\"Yes\");\n        } else {\n           \
    \ return String::from(\"No\");\n        }\n    }\n    String::from(\"No\")\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4up6vtek.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut s = String::new();\n\
    \    for s1 in lst {\n        s.push_str(&s1);\n    }\n    for c in s.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else {\n   \
    \         if stack.is_empty() {\n                return String::from(\"No\");\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    if stack.is_empty() {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpy90o4zjl.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open < 0 && s2_open < 0 {\n        if s1_open + s2_open == 0 {\n  \
    \          return String::from(\"Yes\");\n        }\n    }\n    if s1_open > 0\
    \ && s2_open > 0 {\n        if s1_open + s2_open == 0 {\n            return String::from(\"\
    Yes\");\n        }\n    }\n    return String::from(\"No\");\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpqfuowkv6.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = s1.clone();\n    let mut s4 = s2.clone();\n    s1.push_str(&s2);\n\
    \    s2.push_str(&s3);\n    if is_good(&s1) || is_good(&s2) {\n        return\
    \ String::from(\"Yes\");\n    }\n    s3.push_str(&s4);\n    s4.push_str(&s1);\n\
    \    if is_good(&s3) || is_good(&s4) {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp3fqjbno2.rs:21:8\n\
    \   |\n21 |     if is_good(&s1) || is_good(&s2) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmp3fqjbno2.rs:21:24\n   |\n21 |     if is_good(&s1) || is_good(&s2)\
    \ {\n   |                        ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmp3fqjbno2.rs:26:8\n\
    \   |\n26 |     if is_good(&s3) || is_good(&s4) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmp3fqjbno2.rs:26:24\n   |\n26 |     if is_good(&s3) || is_good(&s4)\
    \ {\n   |                        ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    let mut count = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp742lhxbx.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut lst = lst.into_iter();\n\
    \    let mut s = lst.next().unwrap();\n    let mut t = lst.next().unwrap();\n\
    \    while !s.is_empty() {\n        if s.pop().unwrap() == '(' {\n           \
    \ stack.push('(');\n        } else {\n            if stack.is_empty() {\n    \
    \            if t.is_empty() {\n                    return String::from(\"No\"\
    );\n                }\n                s.push(t.pop().unwrap());\n           \
    \ } else {\n                stack.pop();\n            }\n        }\n    }\n  \
    \  while !t.is_empty() {\n        if t.pop().unwrap() == '(' {\n            if\
    \ stack.is_empty() {\n                return String::from(\"No\");\n         \
    \   }\n            stack.pop();\n        } else {\n            stack.push(')');\n\
    \        }\n    }\n    if stack.is_empty() {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7iw0g11t.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n\
    \    for c in s1.iter() {\n        if *c == '(' {\n            s1_open += 1;\n\
    \        } else {\n            s1_close += 1;\n        }\n    }\n    for c in\
    \ s2.iter() {\n        if *c == '(' {\n            s2_open += 1;\n        } else\
    \ {\n            s2_close += 1;\n        }\n    }\n    if s1_open == s1_close\
    \ && s2_open == s2_close {\n        return String::from(\"Yes\");\n    }\n   \
    \ if s1_open > s1_close {\n        if s2_open > s2_close {\n            return\
    \ String::from(\"No\");\n        }\n        if s2_open < s2_close {\n        \
    \    if s2_close - s2_open > s1_open - s1_close {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if s1_open < s1_close {\n       \
    \ if s2_open < s2_close {\n            return String::from(\"No\");\n        }\n\
    \        if s2_open > s2_close {\n            if s2_open - s2_close > s1_close\
    \ - s1_open {\n                return String::from(\"No\");\n            }\n \
    \       }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp4k5ivu6z.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut cnt = 0;\n    for i in s.chars() {\n        if i == '(' {\n\
    \            cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n \
    \       if cnt < 0 {\n            return String::from(\"No\");\n        }\n  \
    \  }\n    if cnt == 0 {\n        String::from(\"Yes\")\n    } else {\n       \
    \ String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbnps1sm5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    if s.chars().filter(|&c| c == '(').count() == s.chars().filter(|&c|\
    \ c == ')').count() {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpotm0ngvg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj6wwqdzp.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == 0 && s2_open < 0 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open < 0 && s2_open == 0 {\n        return String::from(\"Yes\"\
    );\n    }\n    if s1_open < 0 && s2_open < 0 {\n        if s1_open + s2_open ==\
    \ 0 {\n            return String::from(\"Yes\");\n        }\n    }\n    if s1_open\
    \ > 0 && s2_open > 0 {\n        if s1_open + s2_open == 0 {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpq4he7bpp.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_cnt = 0;\n \
    \   let mut s2_cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n  \
    \          s1_cnt += 1;\n        } else {\n            s1_cnt -= 1;\n        }\n\
    \    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_cnt +=\
    \ 1;\n        } else {\n            s2_cnt -= 1;\n        }\n    }\n    if s1_cnt\
    \ == 0 && s2_cnt == 0 {\n        return String::from(\"Yes\");\n    }\n    if\
    \ s1_cnt > 0 && s2_cnt < 0 {\n        if s1_cnt + s2_cnt == 0 {\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    if s1_cnt < 0 && s2_cnt > 0 {\n\
    \        if s1_cnt + s2_cnt == 0 {\n            return String::from(\"Yes\");\n\
    \        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpgr8gd4_7.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsgj8kh63.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == -1 && s2_open == 1 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open == 1 && s2_open == -1 {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp19gmwafi.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<char> = lst.join(\"\").chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    while let Some(c) = lst.pop()\
    \ {\n        if c == ')' {\n            stack.push(c);\n        } else if c ==\
    \ '(' {\n            if let Some(s) = stack.pop() {\n                if s != ')'\
    \ {\n                    return String::from(\"No\");\n                }\n   \
    \         } else {\n                return String::from(\"No\");\n           \
    \ }\n        }\n    }\n    if stack.is_empty() {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpm0x7re5w.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for s1 in lst {\n        s.push_str(&s1);\n\
    \    }\n    let mut count = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpa40_3eb0.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut count = 0;\n    for i in s.chars() {\n        if i == '('\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            return String::from(\"No\");\n   \
    \     }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp3qgxjqhq.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter();\n    let mut s1 = lst.next().unwrap();\n\
    \    let mut s2 = lst.next().unwrap();\n    let mut s1_open = 0;\n    let mut\
    \ s2_open = 0;\n    let mut s1_close = 0;\n    let mut s2_close = 0;\n    for\
    \ c in s1.chars() {\n        if c == '(' {\n            s1_open += 1;\n      \
    \  } else {\n            s1_close += 1;\n        }\n    }\n    for c in s2.chars()\
    \ {\n        if c == '(' {\n            s2_open += 1;\n        } else {\n    \
    \        s2_close += 1;\n        }\n    }\n    if s1_open == s1_close && s2_open\
    \ == s2_close {\n        return String::from(\"Yes\");\n    }\n    if s1_open\
    \ == s1_close && s2_open < s2_close {\n        return String::from(\"No\");\n\
    \    }\n    if s1_open < s1_close && s2_open == s2_close {\n        return String::from(\"\
    No\");\n    }\n    if s1_open < s1_close && s2_open < s2_close {\n        return\
    \ String::from(\"No\");\n    }\n    if s1_open > s1_close && s2_open > s2_close\
    \ {\n        return String::from(\"No\");\n    }\n    if s1_open > s1_close &&\
    \ s2_open < s2_close {\n        return String::from(\"Yes\");\n    }\n    if s1_open\
    \ < s1_close && s2_open > s2_close {\n        return String::from(\"Yes\");\n\
    \    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmphjxfn0ye.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2zfsz2f.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    s1.append(&mut s2);\n \
    \   let mut count = 0;\n    for c in s1 {\n        if c == '(' {\n           \
    \ count += 1;\n        } else {\n            count -= 1;\n        }\n        if\
    \ count < 0 {\n            return String::from(\"No\");\n        }\n    }\n  \
    \  if count == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpl5rbnz16.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = String::new();\n    for s in lst {\n     \
    \   parens.push_str(&s);\n    }\n    let mut count = 0;\n    for c in parens.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpj5_d9h0n.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let mut s = String::new();\n\
    \    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n    if s.len() % 2 == 1 {\n\
    \        return String::from(\"No\");\n    }\n    let mut stack = Vec::new();\n\
    \    for c in s.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else {\n            if stack.len() == 0 {\n                return String::from(\"\
    No\");\n            }\n            stack.pop();\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\"\
    )\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        if c == '(' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5s7xd7bp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut res = String::new();\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < lst[0].len() || j < lst[1].len() {\n        if i < lst[0].len() &&\
    \ lst[0][i] == '(' {\n            res.push('(');\n            i += 1;\n      \
    \  } else if j < lst[1].len() && lst[1][j] == '(' {\n            res.push('(');\n\
    \            j += 1;\n        } else if i < lst[0].len() && lst[0][i] == ')' {\n\
    \            res.push(')');\n            i += 1;\n        } else if j < lst[1].len()\
    \ && lst[1][j] == ')' {\n            res.push(')');\n            j += 1;\n   \
    \     }\n    }\n    if is_good(&res) {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpvq491i2u.rs:34:8\n\
    \   |\n34 |     if is_good(&res) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_cnt = 0;\n \
    \   let mut s2_cnt = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n  \
    \          s1_cnt += 1;\n        } else {\n            s1_cnt -= 1;\n        }\n\
    \    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_cnt +=\
    \ 1;\n        } else {\n            s2_cnt -= 1;\n        }\n    }\n    if s1_cnt\
    \ > 0 {\n        for _ in 0..s1_cnt {\n            s2.push(')');\n        }\n\
    \    } else {\n        for _ in 0..s2_cnt.abs() {\n            s1.push(')');\n\
    \        }\n    }\n    let mut cnt = 0;\n    for c in s1.iter().chain(s2.iter())\
    \ {\n        if *c == '(' {\n            cnt += 1;\n        } else {\n       \
    \     cnt -= 1;\n        }\n        if cnt < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if cnt == 0 {\n        String::from(\"Yes\")\n \
    \   } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpjxb2jpx2.rs:38:28\n   |\n38 |         for _ in 0..s2_cnt.abs()\
    \ {\n   |                            ^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n18 |     let mut s2_cnt: i32 = 0;\n   |\
    \         ~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\
    \    let mut lst_len = lst.len();\n    while lst_len > 1 {\n        let mut new_lst\
    \ = Vec::new();\n        for i in 0..lst_len - 1 {\n            let mut new_vec\
    \ = Vec::new();\n            new_vec.append(&mut lst[i].clone());\n          \
    \  new_vec.append(&mut lst[i + 1].clone());\n            new_lst.push(new_vec);\n\
    \        }\n        lst = new_lst;\n        lst_len -= 1;\n    }\n    if lst[0].iter().filter(|&c|\
    \ *c == '(').count() == lst[0].iter().filter(|&c| *c == ')').count() {\n     \
    \   String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpukailj_5.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut s3 = String::new();\n    let mut s4 = String::new();\n    let mut\
    \ s5 = String::new();\n    let mut s6 = String::new();\n    let mut s7 = String::new();\n\
    \    let mut s8 = String::new();\n    let mut s9 = String::new();\n    let mut\
    \ s10 = String::new();\n    let mut s11 = String::new();\n    let mut s12 = String::new();\n\
    \    let mut s13 = String::new();\n    let mut s14 = String::new();\n    let mut\
    \ s15 = String::new();\n    let mut s16 = String::new();\n    let mut s17 = String::new();\n\
    \    let mut s18 = String::new();\n    let mut s19 = String::new();\n    let mut\
    \ s20 = String::new();\n    let mut s21 = String::new();\n    let mut s22 = String::new();\n\
    \    let mut s23 = String::new();\n    let mut s24 = String::new();\n    let mut\
    \ s25 = String::new();\n    let mut s26 = String::new();\n    let mut s27 = String::new();\n\
    \    let mut s28 = String::new();\n    let mut s29 = String::new();\n    let mut\
    \ s30 = String::new();\n    let mut s31 = String::new();\n    let mut s32 = String::new();\n\
    \    let mut s33 = String::new();\n    let mut s34 = String::new();\n    let mut\
    \ s35 = String::new();\n    let mut s36 = String::new();\n    let mut s37 = String::new();\n\
    \    let mut s38 = String::new();\n    let mut s39 = String::new();\n    let mut\
    \ s40 = String::new();\n    let mut s41 = String::new();\n    let mut s42 = String::new();\n\
    \    let mut s43 = String::new();\n    let mut s44 = String::new();\n    let mut\
    \ s45 = String::new();\n    let mut s46 = String::new();\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaf4__tos.rs:14:38\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------     \
    \                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_open = 0;\n\
    \    let mut s2_open = 0;\n    for c in s1.iter() {\n        if *c == '(' {\n\
    \            s1_open += 1;\n        } else {\n            s1_open -= 1;\n    \
    \    }\n    }\n    for c in s2.iter() {\n        if *c == '(' {\n            s2_open\
    \ += 1;\n        } else {\n            s2_open -= 1;\n        }\n    }\n    if\
    \ s1_open == 0 && s2_open == 0 {\n        return String::from(\"Yes\");\n    }\n\
    \    if s1_open == -1 && s2_open == 1 {\n        return String::from(\"Yes\");\n\
    \    }\n    if s1_open == 1 && s2_open == -1 {\n        return String::from(\"\
    Yes\");\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpu9n_uzfg.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
