name: HumanEval_118_get_closest_vowel
language: rs
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = Vec::new();\n    let mut consonants = Vec::new();\n    let mut\
    \ result = String::new();\n    for c in word.chars() {\n        if is_vowel(c)\
    \ {\n            vowels.push(c);\n        } else {\n            consonants.push(c);\n\
    \        }\n    }\n    if vowels.len() == 0 || consonants.len() < 2 {\n      \
    \  return result;\n    }\n    let mut i = vowels.len() - 1;\n    let mut j = consonants.len()\
    \ - 1;\n    while i >= 0 && j >= 1 {\n        if vowels[i] == consonants[j] {\n\
    \            i -= 1;\n            j -= 1;\n        } else {\n            result.push(vowels[i]);\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4rzwk8f9.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = 0;\n    let mut closest_vowel_distance = 0;\n\
    \    let mut last_consonant_index = 0;\n    let mut last_vowel_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n            if last_vowel_index != 0 {\n                let distance =\
    \ last_consonant_index - last_vowel_index;\n                if closest_vowel_distance\
    \ == 0 || distance < closest_vowel_distance {\n                    closest_vowel_distance\
    \ = distance;\n                    closest_vowel_index = last_vowel_index;\n \
    \               }\n            }\n        }\n    }\n    if closest_vowel_index\
    \ != 0 {\n        closest_vowel.push(word.chars().nth(closest_vowel_index).unwrap());\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp51zhlo2w.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n        if last_vowel_index > last_consonant_index {\n    \
    \        result = c.to_string();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp65yi7os6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_is_consonant = false;\n    let\
    \ mut prev_is_vowel = false;\n    for c in word.chars().rev() {\n        if c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if prev_is_consonant\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \            prev_is_vowel = true;\n        } else {\n            if prev_is_vowel\
    \ {\n                break;\n            }\n            prev_is_consonant = true;\n\
    \        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp_mozvgit.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_consonant > last_vowel {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpauckjbc5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (index, letter) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&letter) {\n            if index < closest_vowel_index\
    \ {\n                closest_vowel_index = index;\n                closest_vowel\
    \ = letter.to_string();\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp0wmuf4_k.rs:19:53\n     |\n19   |     for (index, letter) in\
    \ word.chars().enumerate().rev() {\n     |                                   \
    \                  ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmp0wmuf4_k.rs:19:28\n   |\n19 |     for (index,\
    \ letter) in word.chars().enumerate().rev() {\n   |                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            is_consonant = false;\n        }\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' {\n            is_vowel = true;\n        } else {\n\
    \            is_consonant = true;\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp9qcfpz3r.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_index {\n  \
    \              closest_index = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if !closest_vowel.is_empty() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpcgxov71i.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpcgxov71i.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut closest_vowel\
    \ = String::from(\"\");\n    let mut closest_index = word.len();\n    for (i,\
    \ c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            if closest_index - i > 1 {\n                closest_vowel = c.to_string();\n\
    \                closest_index = i;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpx5f1ybn_.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpx5f1ybn_.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut vowel = String::new();\n\
    \    let mut is_consonant = false;\n    for c in word {\n        if is_consonant\
    \ && is_vowel(c) {\n            vowel.push(c);\n            break;\n        }\n\
    \        if !is_vowel(c) {\n            is_consonant = true;\n        }\n    }\n\
    \    vowel.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp13b03q7f.rs:20:28\n\
    \   |\n20 |         if is_consonant && is_vowel(c) {\n   |                   \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmp13b03q7f.rs:24:13\n   |\n24 |      \
    \   if !is_vowel(c) {\n   |             ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_index {\n  \
    \              closest_index = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if !closest_vowel.is_empty() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmptzda4py3.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmptzda4py3.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    for c in word.chars() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n            vowels.push(c);\n        } else\
    \ {\n            consonants.push(c);\n        }\n    }\n    if vowels.len() <\
    \ 2 {\n        return result;\n    }\n    let mut i = vowels.len() - 1;\n    let\
    \ mut j = consonants.len() - 1;\n    while i >= 0 && j >= 0 {\n        if vowels.chars().nth(i).unwrap()\
    \ == consonants.chars().nth(j).unwrap() {\n            i -= 1;\n            j\
    \ -= 1;\n        } else {\n            result.push(vowels.chars().nth(i).unwrap());\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmplw92519h.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    let mut last_consonant_index\
    \ = 0;\n    for (index, character) in word.chars().enumerate() {\n        if vowels.contains(&character)\
    \ {\n            if index > last_consonant_index && index < closest_vowel_index\
    \ {\n                closest_vowel = character.to_string();\n                closest_vowel_index\
    \ = index;\n            }\n        } else {\n            last_consonant_index\
    \ = index;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpf4mttmzj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut vowel_index = 0;\n    let mut vowel_distance = 0;\n    let mut consonant_count\
    \ = 0;\n    let mut consonant_index = 0;\n    let mut consonant_distance = 0;\n\
    \    let mut word_chars = word.chars().collect::<Vec<char>>();\n    word_chars.reverse();\n\
    \    for (index, c) in word_chars.iter().enumerate() {\n        if vowels.contains(c)\
    \ {\n            vowel_index = index;\n            vowel_distance = consonant_count;\n\
    \            consonant_count = 0;\n        } else {\n            consonant_count\
    \ += 1;\n            if consonant_count == 1 {\n                consonant_index\
    \ = index;\n                consonant_distance = vowel_distance;\n           \
    \ }\n            if consonant_count > 1 && vowel_distance < consonant_distance\
    \ {\n                closest_vowel = word_chars[vowel_index].to_string();\n  \
    \              break;\n            }\n        }\n    }\n    closest_vowel\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpyszs5sfb.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = Vec::new();\n    let mut consonants = Vec::new();\n    for c in\
    \ word.chars() {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' |\
    \ 'A' | 'E' | 'I' | 'O' | 'U' => vowels.push(c),\n            _ => consonants.push(c),\n\
    \        }\n    }\n    if vowels.len() == 0 || consonants.len() == 0 {\n     \
    \   return String::from(\"\");\n    }\n    let mut vowel_index = 0;\n    let mut\
    \ consonant_index = 0;\n    let mut min_distance = word.len();\n    while vowel_index\
    \ < vowels.len() && consonant_index < consonants.len() {\n        let vowel_distance\
    \ = word.rfind(vowels[vowel_index]).unwrap() - word.rfind(consonants[consonant_index]).unwrap();\n\
    \        if vowel_distance < min_distance {\n            min_distance = vowel_distance;\n\
    \        }\n        if word.rfind(vowels[vowel_index]).unwrap() > word.rfind(consonants[consonant_index]).unwrap()\
    \ {\n            vowel_index += 1;\n        } else {\n            consonant_index\
    \ += 1;\n        }\n    }\n    if min_distance == word.len() {\n        return\
    \ String::from(\"\");\n    }\n    let mut closest_vowel = String::new();\n   \
    \ for c in word.chars() {\n        if word.rfind(c).unwrap() - word.rfind(consonants[consonant_index]).unwrap()\
    \ == min_distance {\n            closest_vowel.push(c);\n        }\n    }\n  \
    \  closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpndiqg1op.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut word_chars = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut vowel_index = 0;\n    let mut vowel_distance = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_consonant_distance = 0;\n    for (i, c) in word_chars.iter().enumerate()\
    \ {\n        if vowels.contains(c) {\n            vowel_index = i;\n         \
    \   vowel_distance = i;\n            if last_consonant_distance > 0 {\n      \
    \          vowel_distance = i - last_consonant_index;\n            }\n       \
    \ } else {\n            last_consonant_index = i;\n            last_consonant_distance\
    \ = i;\n            if vowel_distance > 0 {\n                last_consonant_distance\
    \ = i - vowel_index;\n            }\n        }\n    }\n    if vowel_distance ==\
    \ 0 || last_consonant_distance == 0 {\n        String::from(\"\")\n    } else\
    \ {\n        word_chars[vowel_index].to_string()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpx_spb8pd.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_char != ' ' && prev_vowel != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpkpomf10g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut is_vowel = false;\n    while\
    \ index > 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap()) {\n\
    \            if is_vowel {\n                break;\n            }\n          \
    \  result = word.chars().nth(index).unwrap().to_string();\n            is_vowel\
    \ = true;\n        } else {\n            is_vowel = false;\n        }\n      \
    \  index -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpja68l4ri.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut last_consonant = false;\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if last_consonant\
    \ {\n                result.push(c);\n                found = true;\n        \
    \        break;\n            }\n        } else {\n            last_consonant =\
    \ true;\n        }\n    }\n    if found {\n        result\n    } else {\n    \
    \    String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpzgjp7c_l.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut found_vowel = false;\n    let mut found_consonant\
    \ = false;\n    let mut found_vowel_index = 0;\n    let mut found_consonant_index\
    \ = 0;\n    let mut index = 0;\n    for c in word.chars() {\n        if is_vowel(c)\
    \ {\n            if found_consonant {\n                found_vowel = true;\n \
    \               found_vowel_index = index;\n                break;\n         \
    \   }\n        } else {\n            if found_vowel {\n                found_consonant\
    \ = true;\n                found_consonant_index = index;\n            }\n   \
    \     }\n        index += 1;\n    }\n    if found_vowel && found_consonant {\n\
    \        result.push(word.chars().nth(found_vowel_index).unwrap());\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpowjvd19a.rs:23:12\n\
    \   |\n23 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_char\
    \ != ' ' && !vowels.contains(&prev_char) {\n                closest_vowel.push(c);\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpf5l0urre.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\";\n    let mut result = String::new();\n    let mut prev_is_vowel\
    \ = false;\n    let mut next_is_vowel = false;\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(c) {\n            next_is_vowel = true;\n    \
    \    } else {\n            if prev_is_vowel && next_is_vowel {\n             \
    \   result.push(c);\n                break;\n            }\n            next_is_vowel\
    \ = false;\n        }\n        prev_is_vowel = vowels.contains(c);\n    }\n  \
    \  result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmp77t5v116.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    let mut last_consonant_index\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i > last_consonant_index && i < closest_vowel_index {\n  \
    \              closest_vowel = c.to_string();\n                closest_vowel_index\
    \ = i;\n            }\n        } else {\n            last_consonant_index = i;\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpzxpmigxp.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_prev_char\
    \ = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            if prev_char != ' ' && prev_prev_char\
    \ != ' ' {\n                result.push(c);\n                break;\n        \
    \    }\n        }\n        prev_prev_char = prev_char;\n        prev_char = c;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp2ng8b6rr.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut vowel = String::new();\n\
    \    let mut is_vowel = false;\n    for c in word.iter() {\n        if is_vowel\
    \ {\n            if !is_vowel_char(*c) {\n                break;\n           \
    \ }\n        } else {\n            if is_vowel_char(*c) {\n                vowel.push(*c);\n\
    \                is_vowel = true;\n            }\n        }\n    }\n    vowel.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel_char` in this scope\n  -->\
    \ /tmp/tmpc18aahyn.rs:21:17\n   |\n21 |             if !is_vowel_char(*c) {\n\
    \   |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel_char` in this scope\n  --> /tmp/tmpc18aahyn.rs:25:16\n\
    \   |\n25 |             if is_vowel_char(*c) {\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut index_of_closest_vowel = 0;\n    let mut index_of_last_consonant\
    \ = 0;\n    let mut index_of_first_consonant = 0;\n    let mut found_first_consonant\
    \ = false;\n    let mut found_last_consonant = false;\n    let mut found_vowel\
    \ = false;\n    let mut index = 0;\n    for c in word.chars() {\n        if !vowels.contains(&c)\
    \ {\n            if !found_first_consonant {\n                index_of_first_consonant\
    \ = index;\n                found_first_consonant = true;\n            }\n   \
    \         index_of_last_consonant = index;\n        } else {\n            if found_first_consonant\
    \ && !found_last_consonant {\n                if index > index_of_closest_vowel\
    \ {\n                    index_of_closest_vowel = index;\n                   \
    \ closest_vowel = c.to_string();\n                    found_vowel = true;\n  \
    \              }\n            }\n        }\n        index += 1;\n    }\n    if\
    \ found_vowel {\n        closest_vowel\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpztqnphl9.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    let mut prev_is_consonant = false;\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if prev_is_consonant {\n                if i < closest_distance\
    \ {\n                    closest_distance = i;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n            prev_is_consonant\
    \ = false;\n        } else {\n            prev_is_consonant = true;\n        }\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpxaq07b6k.rs:20:44\n     |\n20   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpxaq07b6k.rs:20:19\n\
    \   |\n20 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_vowel != ' ' && prev_char != ' ' {\n            closest_vowel.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp8dup960t.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_char != ' ' && prev_vowel != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpy7_f7r_l.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut vowel_found = false;\n    let mut consonant_found\
    \ = false;\n    let mut vowel_index = 0;\n    let mut consonant_index = 0;\n \
    \   let mut vowel_count = 0;\n    let mut consonant_count = 0;\n    let mut vowel_index_list\
    \ = Vec::new();\n    let mut consonant_index_list = Vec::new();\n    let mut vowel_count_list\
    \ = Vec::new();\n    let mut consonant_count_list = Vec::new();\n    let mut vowel_index_list_index\
    \ = 0;\n    let mut consonant_index_list_index = 0;\n    let mut vowel_count_list_index\
    \ = 0;\n    let mut consonant_count_list_index = 0;\n    let mut vowel_index_list_index_found\
    \ = false;\n    let mut consonant_index_list_index_found = false;\n    let mut\
    \ vowel_count_list_index_found = false;\n    let mut consonant_count_list_index_found\
    \ = false;\n    let mut vowel_index_list_index_found_index = 0;\n    let mut consonant_index_list_index_found_index\
    \ = 0;\n    let mut vowel_count_list_index_found_index = 0;\n    let mut consonant_count_list_index_found_index\
    \ = 0;\n    let mut vowel_index_list_index_found_index_found = false;\n    let\
    \ mut consonant_index_list_index_found_index_found = false;\n    let mut vowel_count_list_index_found_index_found\
    \ = false;\n    let mut consonant_count_list_index_found_index_found = false;\n\
    \    let mut vowel_index_list_index_found_index_found_index = 0;\n    let mut\
    \ consonant_index_list_index_found_index_found_index = 0;\n    let mut vowel_count_list_index_found_index_found_index\
    \ = 0;\n    let mut consonant_count_list_index_found_index_found_index = 0;\n\
    \    let mut vowel_index_list_index\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppflqb1az.rs:47:35\n   |\n\
    47 |     let mut vowel_index_list_index\n   |                                \
    \   ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppflqb1az.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut last_consonant = None;\n    for c in word.chars().rev() {\n\
    \        if last_consonant.is_none() {\n            if !vowels.contains(&c) {\n\
    \                last_consonant = Some(c);\n            }\n        } else {\n\
    \            if vowels.contains(&c) {\n                closest_vowel.push(c);\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp9aopotlj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    for\
    \ c in word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n\
    \            vowels.push(c);\n        } else {\n            consonants.push(c);\n\
    \        }\n    }\n    let mut closest_vowel = String::new();\n    for c in consonants.chars().rev()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n            break;\n\
    \        } else {\n            closest_vowel.push(c);\n        }\n    }\n    closest_vowel.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ygrt\"`,\n right: `\"u\"`', /tmp/tmpcjc7drfj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\";\n    let mut closest_vowel = String::new();\n    let\
    \ mut closest_distance = word.len();\n    let mut prev_is_consonant = false;\n\
    \    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(c) {\n\
    \            if prev_is_consonant {\n                if i < closest_distance {\n\
    \                    closest_distance = i;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n            prev_is_consonant\
    \ = false;\n        } else {\n            prev_is_consonant = true;\n        }\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpy3mcp8p3.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n               \
    \ is_vowel = true;\n            }\n        }\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U' {\n            is_consonant = true;\n        }\n    }\n \
    \   result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"u\"`', /tmp/tmpz5tihjwb.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut vowel_index = 0;\n    let mut vowel_count\
    \ = 0;\n    let mut consonant_count = 0;\n    let mut vowel_found = false;\n \
    \   let mut consonant_found = false;\n    let mut vowel_found_first = false;\n\
    \    let mut consonant_found_first = false;\n    let mut vowel_found_last = false;\n\
    \    let mut consonant_found_last = false;\n    let mut vowel_found_first_index\
    \ = 0;\n    let mut consonant_found_first_index = 0;\n    let mut vowel_found_last_index\
    \ = 0;\n    let mut consonant_found_last_index = 0;\n    let mut vowel_found_first_count\
    \ = 0;\n    let mut consonant_found_first_count = 0;\n    let mut vowel_found_last_count\
    \ = 0;\n    let mut consonant_found_last_count = 0;\n    let mut vowel_found_first_index_last\
    \ = 0;\n    let mut consonant_found_first_index_last = 0;\n    let mut vowel_found_last_index_last\
    \ = 0;\n    let mut consonant_found_last_index_last = 0;\n    let mut vowel_found_first_count_last\
    \ = 0;\n    let mut consonant_found_first_count_last = 0;\n    let mut vowel_found_last_count_last\
    \ = 0;\n    let mut consonant_found_last_count_last = 0;\n    let mut vowel_found_first_index_last_last\
    \ = 0;\n    let mut consonant_found_first_index_last_last = 0;\n    let mut vowel_found_last_index_last_last\
    \ = 0;\n    let mut consonant_found_last_index_last_last = 0;\n    let mut vowel_found_first_count_last_last\
    \ = 0;\n    let mut consonant_found_first_count_last_last = 0;\n    let mut vowel_found_last_count_last_last\
    \ = 0;\n    let mut consonant_found_last_count_last_last = 0;\n    let mut\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1v6iq1sq.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    let mut found_vowel\
    \ = false;\n    let mut found_consonant = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = i;\n         \
    \   found_vowel = true;\n        } else {\n            last_consonant = i;\n \
    \           found_consonant = true;\n        }\n        if found_vowel && found_consonant\
    \ {\n            result = word[last_vowel..last_consonant].to_string();\n    \
    \        break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'begin <= end (1 <= 0) when slicing `yogurt`',\
    \ library/core/src/str/mod.rs:111:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = Vec::new();\n    let mut consonants = Vec::new();\n    let mut\
    \ result = String::new();\n    let mut vowel_index = 0;\n    let mut consonant_index\
    \ = 0;\n    let mut vowel_count = 0;\n    let mut consonant_count = 0;\n    let\
    \ mut vowel_distance = 0;\n    let mut consonant_distance = 0;\n    let mut distance\
    \ = 0;\n    let mut vowel_distance_vec = Vec::new();\n    let mut consonant_distance_vec\
    \ = Vec::new();\n    let mut distance_vec = Vec::new();\n    let mut vowel_distance_vec_index\
    \ = 0;\n    let mut consonant_distance_vec_index = 0;\n    let mut distance_vec_index\
    \ = 0;\n    let mut vowel_distance_vec_count = 0;\n    let mut consonant_distance_vec_count\
    \ = 0;\n    let mut distance_vec_count = 0;\n    let mut vowel_distance_vec_distance\
    \ = 0;\n    let mut consonant_distance_vec_distance = 0;\n    let mut distance_vec_distance\
    \ = 0;\n    let mut vowel_distance_vec_distance_index = 0;\n    let mut consonant_distance_vec_distance_index\
    \ = 0;\n    let mut distance_vec_distance_index = 0;\n    let mut vowel_distance_vec_distance_count\
    \ = 0;\n    let mut consonant_distance_vec_distance_count = 0;\n    let mut distance_vec_distance_count\
    \ = 0;\n    let mut vowel_distance_vec_distance_distance = 0;\n    let mut consonant_distance_vec_distance_distance\
    \ = 0;\n    let mut distance_vec_distance_distance = 0;\n    let mut vowel_distance_vec_distance_distance_index\
    \ = 0;\n    let mut consonant_distance_vec_distance_distance_index = 0;\n    let\
    \ mut distance_vec_distance_distance_index = 0;\n    let mut vowel_distance_vec_distance_distance_count\
    \ = 0;\n    let mut consonant_distance_vec_distance_distance_count = 0;\n    let\
    \ mut distance_vec_distance_distance_count =\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmpea43_0.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                if word.chars().nth(i - 1).unwrap().is_ascii_lowercase()\
    \ &&\n                    word.chars().nth(i + 1).unwrap().is_ascii_lowercase()\
    \ {\n                    if i < distance {\n                        distance =\
    \ i;\n                        closest_vowel = c.to_string();\n               \
    \     }\n                }\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp0m3fsicq.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwegdh53t.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut last_consonant = false;\n    let mut\
    \ last_vowel = false;\n    for c in word.chars().rev() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if last_consonant\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \            last_vowel = true;\n        } else {\n            if last_vowel {\n\
    \                last_consonant = true;\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpkr31hmju.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = ' ';\n    let mut last_consonant = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c;\n        } else {\n            last_consonant = c;\n            break;\n\
    \        }\n    }\n    if last_vowel != ' ' && last_consonant != ' ' {\n     \
    \   result.push(last_vowel);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp57jja9dp.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\n\
    \        if prev_char != ' ' && prev_vowel != ' ' {\n            closest_vowel.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp83w3wt2p.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_consonant = false;\n    for c in word.chars().rev() {\n    \
    \    if vowels.contains(&c) {\n            if last_consonant {\n             \
    \   result.push(c);\n                break;\n            }\n        } else {\n\
    \            last_consonant = true;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbo3_02l4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                if word.chars().nth(i - 1).unwrap().is_ascii_lowercase()\
    \ && word.chars().nth(i + 1).unwrap().is_ascii_lowercase() {\n               \
    \     if i < distance {\n                        distance = i;\n             \
    \           closest_vowel = c.to_string();\n                    }\n          \
    \      }\n            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpt986s4mc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel = None;\n    let mut last_consonant = None;\n    for c\
    \ in word.chars().rev() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = Some(c);\n        } else {\n            last_consonant = Some(c);\n      \
    \  }\n        if last_vowel.is_some() && last_consonant.is_some() {\n        \
    \    result.push(last_vowel.unwrap());\n            break;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpm3fube3b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            is_consonant = false;\n        }\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' {\n            is_vowel = true;\n        } else {\n\
    \            is_consonant = true;\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpwsjfcwv2.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut vowel = String::new();\n\
    \    let mut vowel_idx = 0;\n    let mut cons_idx = 0;\n    let mut vowel_found\
    \ = false;\n    let mut cons_found = false;\n    for (i, c) in word.iter().enumerate()\
    \ {\n        if is_vowel(*c) {\n            vowel_found = true;\n            vowel_idx\
    \ = i;\n            vowel.push(*c);\n        } else if vowel_found {\n       \
    \     cons_found = true;\n            cons_idx = i;\n            break;\n    \
    \    }\n    }\n    if vowel_found && cons_found {\n        vowel\n    } else {\n\
    \        String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6x1t0yfe.rs:23:12\n\
    \   |\n23 |         if is_vowel(*c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut last_consonant = String::new();\n    let mut last_vowel = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if !last_consonant.is_empty() && !last_vowel.is_empty() {\n\
    \            closest_vowel = last_vowel.clone();\n            break;\n       \
    \ }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpdm4vuq8u.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut last_consonant = String::new();\n\
    \    let mut last_vowel = String::new();\n    let mut last_char = String::new();\n\
    \    let mut is_vowel = false;\n    let mut is_consonant = false;\n    let mut\
    \ is_last_char_consonant = false;\n    let mut is_last_char_vowel = false;\n \
    \   let mut is_last_char_empty = true;\n    let mut is_last_vowel_empty = true;\n\
    \    let mut is_last_consonant_empty = true;\n    let mut is_closest_vowel_empty\
    \ = true;\n    let mut is_first_char = true;\n    let mut is_last_char = false;\n\
    \    let mut is_first_vowel = true;\n    let mut is_first_consonant = true;\n\
    \    let mut is_first_closest_vowel = true;\n    let mut is_first_last_vowel =\
    \ true;\n    let mut is_first_last_consonant = true;\n    let mut is_first_last_char\
    \ = true;\n    let mut is_first_last_char_vowel = true;\n    let mut is_first_last_char_consonant\
    \ = true;\n    let mut is_first_last_char_empty = true;\n    let mut is_first_last_vowel_empty\
    \ = true;\n    let mut is_first_last_consonant_empty = true;\n    let mut is_first_closest_vowel_empty\
    \ = true;\n    let mut is_first_is_vowel = true;\n    let mut is_first_is_consonant\
    \ = true;\n    let mut is_first_is_last_char_consonant = true;\n    let mut is_first_is_last_char_vowel\
    \ = true;\n    let mut is_first_is_last_char_empty = true;\n    let mut is_first_is_last_vowel_empty\
    \ = true;\n    let mut\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpa69p76g_.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = 0;\n    let mut closest_vowel_distance = 0;\n\
    \    let mut previous_char_is_vowel = false;\n    let mut previous_char_is_consonant\
    \ = false;\n    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            previous_char_is_vowel = true;\n            continue;\n     \
    \   }\n        if previous_char_is_vowel && previous_char_is_consonant {\n   \
    \         if closest_vowel_distance == 0 || i < closest_vowel_distance {\n   \
    \             closest_vowel_distance = i;\n                closest_vowel_index\
    \ = i;\n                closest_vowel = c.to_string();\n            }\n      \
    \  }\n        previous_char_is_vowel = false;\n        previous_char_is_consonant\
    \ = true;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp1c04f8a0.rs:22:44\n     |\n22   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp1c04f8a0.rs:22:19\n\
    \   |\n22 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            prev_vowel = c;\n        } else\
    \ if prev_vowel != ' ' && prev_char != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp_5kectxf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n        if last_vowel_index < last_consonant_index {\n    \
    \        result = c.to_string();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t\"`,\n right: `\"u\"`', /tmp/tmpun_cpdy8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut found_vowel = false;\n    let mut found_consonant\
    \ = false;\n    let mut found_vowel_index = 0;\n    let mut found_consonant_index\
    \ = 0;\n    let mut index = 0;\n    for c in word.chars() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n            if found_consonant {\n       \
    \         found_vowel = true;\n                found_vowel_index = index;\n  \
    \          }\n        } else {\n            if found_vowel {\n               \
    \ found_consonant = true;\n                found_consonant_index = index;\n  \
    \          }\n        }\n        index += 1;\n    }\n    if found_vowel && found_consonant\
    \ {\n        result = word[found_vowel_index..found_consonant_index].to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpnfs0o1e3.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_is_consonant = false;\n    let\
    \ mut prev_is_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                    if prev_is_consonant\
    \ {\n                        result.push(c);\n                        break;\n\
    \                    }\n                    prev_is_vowel = true;\n          \
    \      } else {\n                    if prev_is_vowel {\n                    \
    \    result.push(c);\n                        break;\n                    }\n\
    \                    prev_is_consonant = true;\n                }\n          \
    \  } else {\n                if c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' {\n                    if prev_is_consonant {\n                   \
    \     result.push(c);\n                        break;\n                    }\n\
    \                    prev_is_vowel = true;\n                } else {\n       \
    \             if prev_is_vowel {\n                        result.push(c);\n  \
    \                      break;\n                    }\n                    prev_is_consonant\
    \ = true;\n                }\n            }\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmplxn9xra_.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\";\n    let mut last_vowel = 0;\n    let mut last_consonant\
    \ = 0;\n    let mut last_vowel_index = 0;\n    let mut last_consonant_index =\
    \ 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(c)\
    \ {\n            last_vowel = c;\n            last_vowel_index = i;\n        }\
    \ else {\n            last_consonant = c;\n            last_consonant_index =\
    \ i;\n        }\n        if last_vowel_index > last_consonant_index {\n      \
    \      return last_vowel.to_string();\n        }\n    }\n    String::from(\"\"\
    )\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2wi4te56.rs:23:26\n   |\n\
    17 |     let mut last_vowel = 0;\n   |                          - expected due\
    \ to this value\n...\n23 |             last_vowel = c;\n   |                 \
    \         ^ expected integer, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2wi4te56.rs:26:30\n   |\n18 |     let mut last_consonant = 0;\n\
    \   |                              - expected due to this value\n...\n26 |   \
    \          last_consonant = c;\n   |                              ^ expected integer,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut found = false;\n    let\
    \ mut result = String::new();\n    let mut i = word.len() - 1;\n    while i >\
    \ 0 {\n        if vowels.contains(&word.chars().nth(i).unwrap()) {\n         \
    \   if !vowels.contains(&word.chars().nth(i - 1).unwrap()) {\n               \
    \ result.push(word.chars().nth(i).unwrap());\n                found = true;\n\
    \                break;\n            }\n        }\n        i -= 1;\n    }\n  \
    \  if found {\n        result\n    } else {\n        String::new()\n    }\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpgnfqj6zq.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut prev_is_vowel = false;\n    let mut prev_is_consonant\
    \ = false;\n    for c in word.chars().rev() {\n        if vowels.contains(&c)\
    \ {\n            if prev_is_consonant {\n                result.push(c);\n   \
    \             found = true;\n                break;\n            }\n         \
    \   prev_is_vowel = true;\n        } else {\n            if prev_is_vowel {\n\
    \                prev_is_consonant = true;\n            }\n        }\n    }\n\
    \    if found {\n        result.chars().rev().collect()\n    } else {\n      \
    \  String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp_3l3l5uk.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut vowel_index = 0;\n    let mut consonant_index\
    \ = 0;\n    let mut vowel_distance = 0;\n    let mut consonant_distance = 0;\n\
    \    let mut distance = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let\
    \ mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n   \
    \ let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll\
    \ = 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let\
    \ mut pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n\
    \    let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww\
    \ = 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let\
    \ mut aa = 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n\
    \    let mut ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2wu9t7n.rs:75:15\n   |\n\
    75 |     let mut hh\n   |               ^ help: add `;` here\n76 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2wu9t7n.rs:15:39\n \
    \  |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_vowel != ' ' && prev_char != ' ' {\n            closest_vowel.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpjgwv6t97.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = 0;\n    for i in (0..word.len()).rev() {\n        if vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            index = i;\n            break;\n        }\n    }\n    for i in\
    \ (0..index).rev() {\n        if !vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            result = word.chars().nth(index).unwrap().to_string();\n    \
    \        break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpiv6tfj02.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut vowel_index = 0;\n    let mut vowel_distance = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut last_consonant_distance = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            vowel_index = i;\n        \
    \    vowel_distance = word.len() - vowel_index;\n            if vowel_distance\
    \ > last_consonant_distance {\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \        last_consonant_distance = word.len() - last_consonant_index;\n      \
    \  }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpvgoi8x7v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if is_vowel(c) {\n                result.push(c);\n         \
    \       is_vowel = true;\n            }\n        } else {\n            if !is_vowel(c)\
    \ {\n                is_consonant = true;\n            }\n        }\n    }\n \
    \   result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp57p3jrla.rs:28:16\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n28 |             if is_vowel(c) {\n   |              \
    \  ^^^^^^^^---\n   |                |\n   |                call expression requires\
    \ function\n\nerror[E0618]: expected function, found `bool`\n  --> /tmp/tmp57p3jrla.rs:33:17\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n33 |             if !is_vowel(c) {\n   |             \
    \    ^^^^^^^^---\n   |                 |\n   |                 call expression\
    \ requires function\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut i = word.len() - 1;\n    while i >=\
    \ 0 {\n        if word.chars().nth(i).unwrap().is_alphabetic() {\n           \
    \ if is_vowel(word.chars().nth(i).unwrap()) {\n                vowels.push(word.chars().nth(i).unwrap());\n\
    \            } else {\n                consonants.push(word.chars().nth(i).unwrap());\n\
    \            }\n        }\n        if vowels.len() > 0 && consonants.len() > 0\
    \ {\n            result.push(vowels.chars().nth(vowels.len() - 1).unwrap());\n\
    \            break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpk8dc5zpr.rs:22:16\n\
    \   |\n22 |             if is_vowel(word.chars().nth(i).unwrap()) {\n   |    \
    \            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = ' ';\n    let mut last_consonant = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c;\n        } else {\n            last_consonant = c;\n            break;\n\
    \        }\n    }\n    if last_vowel != ' ' && last_consonant != ' ' {\n     \
    \   result.push(last_vowel);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpw0jgjqdn.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut previous_char = ' ';\n    let mut previous_vowel\
    \ = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            if previous_char != ' ' && previous_char\
    \ != 'a' && previous_char != 'e' && previous_char != 'i' && previous_char != 'o'\
    \ && previous_char != 'u' {\n                result.push(c);\n               \
    \ break;\n            }\n            previous_vowel = c;\n        }\n        previous_char\
    \ = c;\n    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpd3e8t9l7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    let mut prev_char = ' ';\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if prev_char != ' ' && prev_char != c {\n                if i\
    \ < closest_vowel_index {\n                    closest_vowel_index = i;\n    \
    \                closest_vowel = c.to_string();\n                }\n         \
    \   }\n        }\n        prev_char = c;\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp6inldn9b.rs:20:44\n     |\n20   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp6inldn9b.rs:20:19\n\
    \   |\n20 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut is_consonant = false;\n    while\
    \ index > 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap()) {\n\
    \            if is_consonant {\n                result.push(word.chars().nth(index).unwrap());\n\
    \                break;\n            }\n        } else {\n            is_consonant\
    \ = true;\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp20r86whz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut last_consonant = String::new();\n    let mut last_vowel = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if !last_consonant.is_empty() && !last_vowel.is_empty() {\n\
    \            closest_vowel = last_vowel.clone();\n            break;\n       \
    \ }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpb167lzjn.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n    let\
    \ mut is_consonant = false;\n    for i in 0..word.len() {\n        if vowels.contains(&word[i])\
    \ {\n            if is_consonant {\n                result.push(word[i]);\n  \
    \              break;\n            }\n        } else {\n            is_consonant\
    \ = true;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpucduizdh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (index, character) in\
    \ word.chars().enumerate().rev() {\n        if vowels.contains(&character) {\n\
    \            if index < closest_vowel_index {\n                closest_vowel_index\
    \ = index;\n                closest_vowel = character.to_string();\n         \
    \   }\n        } else {\n            if closest_vowel_index != word.len() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp592of1hz.rs:19:56\n     |\n19   |     for (index, character)\
    \ in word.chars().enumerate().rev() {\n     |                                \
    \                        ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    note: required by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n  --> /tmp/tmp592of1hz.rs:19:31\n   |\n\
    19 |     for (index, character) in word.chars().enumerate().rev() {\n   |    \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = String::new();\n    let mut last_consonant = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if last_vowel != \"\" && last_consonant != \"\" {\n      \
    \      result = last_vowel.clone();\n            break;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpqx9v43i4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut i = word.len() - 1;\n    while i > 0 {\n        if vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            if vowels.contains(&word.chars().nth(i - 1).unwrap()) {\n   \
    \             i -= 1;\n            } else {\n                result.push(word.chars().nth(i).unwrap());\n\
    \                break;\n            }\n        }\n        i -= 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp82g1a_1r.rs:28:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut vowel_index = 0;\n    let mut vowel_distance\
    \ = word.len();\n    let mut prev_is_consonant = false;\n    let mut current_is_consonant\
    \ = false;\n    for (i, c) in word.chars().enumerate().rev() {\n        current_is_consonant\
    \ = !c.is_vowel();\n        if prev_is_consonant && !current_is_consonant {\n\
    \            if i < vowel_distance {\n                vowel_distance = i;\n  \
    \              vowel_index = i;\n            }\n        }\n        prev_is_consonant\
    \ = current_is_consonant;\n    }\n    if vowel_distance < word.len() {\n     \
    \   result.push(word.chars().nth(vowel_index).unwrap());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpcf7b0yau.rs:21:44\n     |\n21   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpcf7b0yau.rs:21:19\n\
    \   |\n21 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpcf7b0yau.rs:22:35\n   |\n22 |         current_is_consonant = !c.is_vowel();\n\
    \   |                                   ^^^^^^^^ method not found in `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed e"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n   \
    \ let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    for c in word.chars() {\n        if c == 'a' {\n            a += 1;\n   \
    \     } else if c == 'e' {\n            e += 1;\n        } else if c == 'i' {\n\
    \            i += 1;\n        } else if c == 'o' {\n            o += 1;\n    \
    \    } else if c == 'u' {\n            u += 1;\n        } else if c == 'A' {\n\
    \            a += 1;\n        } else if c == 'E' {\n            e += 1;\n    \
    \    } else if c == 'I' {\n            i += 1;\n        } else if c == 'O' {\n\
    \            o += 1;\n        } else if c == 'U' {\n            u += 1;\n    \
    \    } else if c == 'b' {\n            b += 1;\n        } else if c == 'c' {\n\
    \            c += 1;\n        } else if c == 'd' {\n            d += 1;\n    \
    \    } else if c == 'f' {\n            f += 1;\n        } else if c == 'g' {\n\
    \            g += 1;\n        } else if c == '\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpr1j7m8d0.rs:76:24\n\
    \   |\n76 |         } else if c == '\n   |                        ^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut prev_is_consonant = false;\n    for c\
    \ in word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_is_consonant\
    \ {\n                result.push(c);\n                found = true;\n        \
    \        break;\n            }\n        } else {\n            prev_is_consonant\
    \ = true;\n        }\n    }\n    if found {\n        result\n    } else {\n  \
    \      String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpkdbotxz4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_is_consonant = false;\n    let\
    \ mut prev_is_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                    if prev_is_consonant\
    \ {\n                        result.push(c);\n                        break;\n\
    \                    }\n                    prev_is_vowel = true;\n          \
    \      } else {\n                    if prev_is_vowel {\n                    \
    \    result.push(c);\n                        break;\n                    }\n\
    \                    prev_is_consonant = true;\n                }\n          \
    \  } else {\n                if c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' {\n                    if prev_is_consonant {\n                   \
    \     result.push(c);\n                        break;\n                    }\n\
    \                    prev_is_vowel = true;\n                } else {\n       \
    \             if prev_is_vowel {\n                        result.push(c);\n  \
    \                      break;\n                    }\n                    prev_is_consonant\
    \ = true;\n                }\n            }\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp2smq725r.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    let mut prev_is_vowel = false;\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if prev_is_vowel {\n                break;\n            }\n \
    \           prev_is_vowel = true;\n        } else {\n            if !prev_is_vowel\
    \ {\n                continue;\n            }\n            if i < closest_distance\
    \ {\n                closest_distance = i;\n                closest_vowel = c.to_string();\n\
    \            }\n            prev_is_vowel = false;\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp5bslrf5g.rs:20:44\n     |\n20   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp5bslrf5g.rs:20:19\n\
    \   |\n20 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_is_consonant = false;\n    let\
    \ mut prev_is_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_vowel() {\n                if prev_is_consonant {\n \
    \                   result.push(c);\n                    break;\n            \
    \    }\n                prev_is_vowel = true;\n            } else {\n        \
    \        if prev_is_vowel {\n                    result.push(c);\n           \
    \         break;\n                }\n                prev_is_consonant = true;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp94kcdbns.rs:21:18\n   |\n21 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_char\
    \ != ' ' && !vowels.contains(&prev_char) {\n                result.push(c);\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpget1w__s.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if is_vowel(c) {\n                result.push(c);\n         \
    \       is_vowel = true;\n            }\n        } else {\n            if !is_vowel(c)\
    \ {\n                is_consonant = true;\n            }\n        }\n    }\n \
    \   result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp283s_s4d.rs:28:16\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n28 |             if is_vowel(c) {\n   |              \
    \  ^^^^^^^^---\n   |                |\n   |                call expression requires\
    \ function\n\nerror[E0618]: expected function, found `bool`\n  --> /tmp/tmp283s_s4d.rs:33:17\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n33 |             if !is_vowel(c) {\n   |             \
    \    ^^^^^^^^---\n   |                 |\n   |                 call expression\
    \ requires function\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            let distance = word.len() -\
    \ i;\n            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmphi6sozny.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut found_vowel = false;\n    let mut found_consonant\
    \ = false;\n    let mut vowel_index = 0;\n    let mut consonant_index = 0;\n \
    \   let mut index = 0;\n    for c in word.chars().rev() {\n        if is_vowel(c)\
    \ {\n            if found_consonant {\n                found_vowel = true;\n \
    \               vowel_index = index;\n                break;\n            }\n\
    \        } else {\n            if found_vowel {\n                found_consonant\
    \ = true;\n                consonant_index = index;\n            }\n        }\n\
    \        index += 1;\n    }\n    if found_vowel && found_consonant {\n       \
    \ let mut index = 0;\n        for c in word.chars() {\n            if index ==\
    \ vowel_index {\n                result.push(c);\n                break;\n   \
    \         }\n            index += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpllcpdil2.rs:23:12\n\
    \   |\n23 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_char\
    \ != ' ' && !vowels.contains(&prev_char) {\n                result.push(c);\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp41xxbq3x.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    let mut index = word.len() - 1;\n\
    \    while index > 0 {\n        let current_char = word.chars().nth(index).unwrap();\n\
    \        if vowels.contains(&current_char) {\n            let next_char = word.chars().nth(index\
    \ - 1).unwrap();\n            if !vowels.contains(&next_char) {\n            \
    \    if index < closest_index {\n                    closest_index = index;\n\
    \                    closest_vowel = current_char.to_string();\n             \
    \   }\n            }\n        }\n        index -= 1;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpos27bimi.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = String::new();\n    let mut last_consonant = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if last_vowel != \"\" && last_consonant != \"\" {\n      \
    \      result = last_vowel.clone();\n            break;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmphd0olzn2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_distance = word.len();\n    let mut last_consonant_index\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i - last_consonant_index > 1 && i - last_consonant_index <\
    \ closest_vowel_distance {\n                closest_vowel = c.to_string();\n \
    \               closest_vowel_distance = i - last_consonant_index;\n         \
    \   }\n        } else {\n            last_consonant_index = i;\n        }\n  \
    \  }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpl164ie6s.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut prev_char = ' ';\n    let mut\
    \ prev_vowel = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if prev_char !=\
    \ ' ' && prev_char != 'a' && prev_char != 'e' && prev_char != 'i' && prev_char\
    \ != 'o' && prev_char != 'u' {\n                closest_vowel = c.to_string();\n\
    \                break;\n            }\n            prev_vowel = c;\n        }\n\
    \        prev_char = c;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp7ts45j6p.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut found_vowel = false;\n    while\
    \ index > 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap()) {\n\
    \            if found_vowel {\n                break;\n            } else {\n\
    \                found_vowel = true;\n            }\n        } else {\n      \
    \      if found_vowel {\n                result.push(word.chars().nth(index).unwrap());\n\
    \                break;\n            }\n        }\n        index -= 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpd6wqh4ik.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_vowel > last_consonant {\n            result = word[last_vowel..last_vowel\
    \ + 1].to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpogs4ugkt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    for\
    \ c in word.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n\
    \            vowels.push(c);\n        } else {\n            consonants.push(c);\n\
    \        }\n    }\n    let mut result = String::new();\n    for c in consonants.chars().rev()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n            result.push(c);\n\
    \            break;\n        }\n    }\n    for c in vowels.chars().rev() {\n \
    \       if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n            result.push(c);\n\
    \            break;\n        }\n    }\n    if result.len() == 2 {\n        result.pop();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpsksiwc_4.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut found_consonant = false;\n \
    \   while index > 0 {\n        let ch = word.chars().nth(index).unwrap();\n  \
    \      if !vowels.contains(&ch) {\n            found_consonant = true;\n     \
    \   } else if found_consonant {\n            result.push(ch);\n            break;\n\
    \        }\n        index -= 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpo3patvpl.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                let left = word.chars().nth(i - 1).unwrap();\n      \
    \          let right = word.chars().nth(i + 1).unwrap();\n                if !vowels.contains(&left)\
    \ && !vowels.contains(&right) {\n                    if i < distance {\n     \
    \                   distance = i;\n                        closest_vowel = c.to_string();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmps3poy_1r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = ' ';\n    let mut last_consonant = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c;\n        } else {\n            last_consonant = c;\n            break;\n\
    \        }\n    }\n    if last_vowel != ' ' && last_consonant != ' ' {\n     \
    \   result.push(last_vowel);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpaj5xnw4b.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut vowel_index = 0;\n    let mut prev_char = ' ';\n    let mut prev_prev_char\
    \ = ' ';\n    for (index, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            vowel_index = index;\n        }\n        if !vowels.contains(&c)\
    \ && vowels.contains(&prev_char) && !vowels.contains(&prev_prev_char) {\n    \
    \        result = word[vowel_index..=vowel_index].to_string();\n        }\n  \
    \      prev_prev_char = prev_char;\n        prev_char = c;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"e\"`,\n right: `\"\"`', /tmp/tmpc_6emuf4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i > 0 && i < word.len() - 1 {\n                if !vowels.contains(&word.chars().rev().nth(i\
    \ - 1).unwrap()) &&\n                    !vowels.contains(&word.chars().rev().nth(i\
    \ + 1).unwrap()) {\n                    closest_vowel.push(c);\n             \
    \       break;\n                }\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_consonant = 0;\n    let mut last_vowel = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_consonant > last_vowel {\n            result = word[last_vowel..last_consonant].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmpuvb73tms.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (index, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if index < closest_index {\n\
    \                closest_index = index;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if closest_index != word.len() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmphwoqf5mz.rs:19:48\n     |\n19   |     for (index, c) in word.chars().enumerate().rev()\
    \ {\n     |                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmphwoqf5mz.rs:19:23\n\
    \   |\n19 |     for (index, c) in word.chars().enumerate().rev() {\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut prev_is_consonant = false;\n    for c\
    \ in word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_is_consonant\
    \ {\n                result.push(c);\n                found = true;\n        \
    \        break;\n            }\n        } else {\n            prev_is_consonant\
    \ = true;\n        }\n    }\n    if found {\n        result\n    } else {\n  \
    \      String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpuyuct52a.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i == 0 {\n                break;\n            }\n        \
    \    if !vowels.contains(&word.chars().rev().nth(i - 1).unwrap()) {\n        \
    \        closest_vowel = c.to_string();\n                break;\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmhxb8z4n.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_consonant = false;\n    for c in word.chars().rev() {\n    \
    \    if last_consonant {\n            if vowels.contains(&c) {\n             \
    \   result.push(c);\n                break;\n            }\n        } else {\n\
    \            if !vowels.contains(&c) {\n                last_consonant = true;\n\
    \            }\n        }\n    }\n    result.chars().rev().collect()\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpb6npexu3.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if is_vowel_char(c) {\n                is_vowel = true;\n   \
    \         }\n        } else {\n            if !is_vowel_char(c) {\n          \
    \      is_consonant = true;\n            }\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel_char` in this scope\n  -->\
    \ /tmp/tmp12gdlekn.rs:28:16\n   |\n28 |             if is_vowel_char(c) {\n  \
    \ |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel_char` in this scope\n  --> /tmp/tmp12gdlekn.rs:32:17\n\
    \   |\n32 |             if !is_vowel_char(c) {\n   |                 ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_vowel < last_consonant {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"grt\"`,\n right: `\"u\"`', /tmp/tmpg8c1cbzh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_is_vowel = false;\n    let mut prev_is_consonant = false;\n\
    \    for c in word.chars().rev() {\n        if vowels.contains(&c) {\n       \
    \     if prev_is_consonant {\n                result.push(c);\n              \
    \  break;\n            }\n            prev_is_vowel = true;\n        } else {\n\
    \            if prev_is_vowel {\n                prev_is_consonant = true;\n \
    \           }\n        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp3j5jiqwy.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (index, letter) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&letter) {\n            if index < closest_vowel_index\
    \ {\n                closest_vowel_index = index;\n                closest_vowel\
    \ = letter.to_string();\n            }\n        } else {\n            if !closest_vowel.is_empty()\
    \ {\n                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpti9rdupc.rs:19:53\n     |\n19   |     for (index, letter) in\
    \ word.chars().enumerate().rev() {\n     |                                   \
    \                  ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmpti9rdupc.rs:19:28\n   |\n19 |     for (index,\
    \ letter) in word.chars().enumerate().rev() {\n   |                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for c in word.chars().rev() {\n        if is_vowel(c) {\n      \
    \      prev_vowel = c;\n        } else if prev_char != ' ' && is_vowel(prev_char)\
    \ {\n            result.push(prev_vowel);\n            break;\n        }\n   \
    \     prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpkj6syo4i.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpkj6syo4i.rs:22:39\n   |\n22 |         } else if prev_char != ' ' &&\
    \ is_vowel(prev_char) {\n   |                                       ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_consonant = false;\n    for c in word.chars().rev() {\n    \
    \    if vowels.contains(&c) {\n            if last_consonant {\n             \
    \   result.push(c);\n                break;\n            }\n        } else {\n\
    \            last_consonant = true;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpv5gn20l6.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut found_vowel = false;\n    for c in word.chars().rev() {\n       \
    \ if vowels.contains(&c) {\n            if found_vowel {\n                result.push(c);\n\
    \                break;\n            }\n        } else {\n            found_vowel\
    \ = true;\n        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpi55n1ne7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  let mut last_vowel_char = ' ';\n    let mut last_consonant_char = ' ';\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n            last_vowel_char = c;\n       \
    \ } else {\n            last_consonant_index = i;\n            last_consonant_char\
    \ = c;\n        }\n        if last_vowel_index > last_consonant_index {\n    \
    \        result = last_vowel_char.to_string();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpxm8gg4ey.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n \
    \   let mut i = word.len() - 1;\n    let mut is_consonant = false;\n    while\
    \ i > 0 {\n        if vowels.contains(&word.chars().nth(i).unwrap()) {\n     \
    \       if is_consonant {\n                result.push(word.chars().nth(i).unwrap());\n\
    \                break;\n            }\n        } else {\n            is_consonant\
    \ = true;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpdok0rhmd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut index = 0;\n    for (i, c) in word.chars().rev().enumerate() {\n\
    \        if vowels.contains(&c) {\n            index = i;\n            closest_vowel.push(c);\n\
    \            break;\n        }\n    }\n    if index == 0 {\n        return String::new();\n\
    \    }\n    for (i, c) in word.chars().rev().enumerate() {\n        if i > index\
    \ && !vowels.contains(&c) {\n            return closest_vowel;\n        }\n  \
    \  }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpysdp9959.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n        if last_vowel_index > last_consonant_index {\n    \
    \        result = word[last_vowel_index..last_vowel_index + 1].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpnqusbhbh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut prev_char = ' ';\n    while\
    \ index >= 0 {\n        let curr_char = word.chars().nth(index).unwrap();\n  \
    \      if vowels.contains(&curr_char) {\n            if prev_char != ' ' && !vowels.contains(&prev_char)\
    \ {\n                closest_vowel.push(curr_char);\n                break;\n\
    \            }\n        }\n        prev_char = curr_char;\n        index -= 1;\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp_li_odbe.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut result =\
    \ String::new();\n    let mut is_vowel = false;\n    let mut is_consonant = false;\n\
    \    for c in word.iter() {\n        if is_vowel {\n            if !is_consonant\
    \ {\n                result.push(*c);\n                break;\n            }\n\
    \        } else {\n            if !is_consonant {\n                if is_vowel_char(*c)\
    \ {\n                    is_vowel = true;\n                }\n            } else\
    \ {\n                if is_vowel_char(*c) {\n                    result.push(*c);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     is_consonant = !is_vowel_char(*c);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel_char` in this scope\n  -->\
    \ /tmp/tmp6gzrhw_2.rs:28:20\n   |\n28 |                 if is_vowel_char(*c) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel_char` in this scope\n  --> /tmp/tmp6gzrhw_2.rs:32:20\n\
    \   |\n32 |                 if is_vowel_char(*c) {\n   |                    ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel_char`\
    \ in this scope\n  --> /tmp/tmp6gzrhw_2.rs:38:25\n   |\n38 |         is_consonant\
    \ = !is_vowel_char(*c);\n   |                         ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_prev_char\
    \ = ' ';\n    for c in word.chars().rev() {\n        if is_vowel(c) {\n      \
    \      if !is_vowel(prev_char) && !is_vowel(prev_prev_char) {\n              \
    \  result.push(c);\n                break;\n            }\n        }\n       \
    \ prev_prev_char = prev_char;\n        prev_char = c;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_11mnq_9.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp_11mnq_9.rs:21:17\n   |\n21 |             if !is_vowel(prev_char) &&\
    \ !is_vowel(prev_prev_char) {\n   |                 ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp_11mnq_9.rs:21:41\n   |\n21 |             if !is_vowel(prev_char) &&\
    \ !is_vowel(prev_prev_char) {\n   |                                         ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    let mut last_consonant_index\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i - last_consonant_index < closest_distance {\n          \
    \      closest_distance = i - last_consonant_index;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpnzziy80n.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_vowel_index\
    \ {\n                closest_vowel_index = i;\n                closest_vowel =\
    \ c.to_string();\n            }\n        } else {\n            if !closest_vowel.is_empty()\
    \ {\n                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpcxrpjs5e.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpcxrpjs5e.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut last_consonant_index = 0;\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i > last_consonant_index\
    \ {\n                closest_vowel = c.to_string();\n                break;\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \    }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpjjuhzhdu.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpjjuhzhdu.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_pos = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_vowel_pos {\n\
    \                closest_vowel_pos = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if closest_vowel_pos != word.len()\
    \ {\n                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpqony6iwu.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpqony6iwu.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut found_consonant = false;\n \
    \   while index > 0 {\n        if !vowels.contains(&word.chars().nth(index).unwrap())\
    \ {\n            found_consonant = true;\n        } else if found_consonant {\n\
    \            result = word.chars().nth(index).unwrap().to_string();\n        \
    \    break;\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpm1ysptc9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n               \
    \ is_vowel = true;\n            }\n        }\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U' {\n            is_consonant = true;\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"u\"`', /tmp/tmpv8qyorau.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if !is_vowel && is_consonant && is_vowel(c) {\n            is_vowel =\
    \ true;\n            result.push(c);\n        }\n        if !is_consonant && !is_vowel(c)\
    \ {\n            is_consonant = true;\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmpq4p85j3r.rs:24:41\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n24 |         if !is_vowel && is_consonant && is_vowel(c)\
    \ {\n   |                                         ^^^^^^^^---\n   |          \
    \                               |\n   |                                      \
    \   call expression requires function\n\nerror[E0618]: expected function, found\
    \ `bool`\n  --> /tmp/tmpq4p85j3r.rs:28:30\n   |\n18 |     let mut is_vowel = false;\n\
    \   |         ------------ `is_vowel` has type `bool`\n...\n28 |         if !is_consonant\
    \ && !is_vowel(c) {\n   |                              ^^^^^^^^---\n   |     \
    \                         |\n   |                              call expression\
    \ requires function\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    while index > 0 {\n        if vowels.contains(&word.chars().nth(index).unwrap())\
    \ {\n            if !vowels.contains(&word.chars().nth(index - 1).unwrap()) {\n\
    \                result.push(word.chars().nth(index).unwrap());\n            \
    \    break;\n            }\n        }\n        index -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp55t9zbcm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut vowel_index = 0;\n    let mut consonant_index\
    \ = 0;\n    let mut vowel_distance = 0;\n    let mut consonant_distance = 0;\n\
    \    let mut distance = 0;\n    let mut closest_distance = 0;\n    let mut closest_vowel\
    \ = String::new();\n    for c in word.chars() {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U' {\n            vowels.push(c);\n        } else {\n      \
    \      consonants.push(c);\n        }\n    }\n    if vowels.len() == 0 || consonants.len()\
    \ == 0 {\n        return result;\n    }\n    for c in vowels.chars() {\n     \
    \   vowel_index = vowels.find(c).unwrap();\n        vowel_distance = vowels.len()\
    \ - vowel_index;\n        for d in consonants.chars() {\n            consonant_index\
    \ = consonants.find(d).unwrap();\n            consonant_distance = consonants.len()\
    \ - consonant_index;\n            if consonant_distance > vowel_distance {\n \
    \               distance = consonant_distance - vowel_distance;\n            }\
    \ else {\n                distance = vowel_distance - consonant_distance;\n  \
    \          }\n            if closest_distance == 0 {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            } else\
    \ if distance < closest_distance {\n                closest_distance = distance;\n\
    \                closest_vowel = c.to_string();\n            }\n        }\n  \
    \  }\n    result = closest_vowel;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpakomusbq.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = ' ';\n    let mut last_consonant = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c;\n        } else {\n            last_consonant = c;\n            break;\n\
    \        }\n    }\n    if last_vowel != ' ' && last_consonant != ' ' {\n     \
    \   result.push(last_vowel);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpo7z312kb.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    for c in word.chars() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n            vowels.push(c);\n        } else\
    \ {\n            consonants.push(c);\n        }\n    }\n    if vowels.len() ==\
    \ 0 || consonants.len() == 0 {\n        return result;\n    }\n    let mut vowel_index\
    \ = vowels.len() - 1;\n    let mut consonant_index = consonants.len() - 1;\n \
    \   while vowel_index >= 0 && consonant_index >= 0 {\n        if vowels.chars().nth(vowel_index).unwrap()\
    \ == consonants.chars().nth(consonant_index).unwrap() {\n            vowel_index\
    \ -= 1;\n            consonant_index -= 1;\n        } else {\n            result.push(vowels.chars().nth(vowel_index).unwrap());\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpciicglk9.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut prev_char = ' ';\n    let mut\
    \ prev_vowel = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if prev_char !=\
    \ ' ' && prev_char != 'a' && prev_char != 'e' && prev_char != 'i' && prev_char\
    \ != 'o' && prev_char != 'u' {\n                closest_vowel = c.to_string();\n\
    \                break;\n            }\n            prev_vowel = c;\n        }\n\
    \        prev_char = c;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpksknv64o.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut last_vowel = String::new();\n    let\
    \ mut last_consonant = String::new();\n    let mut last_vowel_index = 0;\n   \
    \ let mut last_consonant_index = 0;\n    let mut index = 0;\n    for c in word.chars()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           vowels.push(c);\n            last_vowel = c.to_string();\n       \
    \     last_vowel_index = index;\n        } else {\n            consonants.push(c);\n\
    \            last_consonant = c.to_string();\n            last_consonant_index\
    \ = index;\n        }\n        index += 1;\n    }\n    if last_vowel_index > last_consonant_index\
    \ {\n        result = last_vowel;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp61389l7h.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (index, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if index < closest_index {\n\
    \                closest_index = index;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if closest_index != word.len() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpf97j6eyf.rs:19:48\n     |\n19   |     for (index, c) in word.chars().enumerate().rev()\
    \ {\n     |                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpf97j6eyf.rs:19:23\n\
    \   |\n19 |     for (index, c) in word.chars().enumerate().rev() {\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  let mut last_vowel_char = ' ';\n    let mut last_consonant_char = ' ';\n  \
    \  let mut last_char = ' ';\n    for (index, ch) in word.chars().enumerate() {\n\
    \        if vowels.contains(&ch) {\n            last_vowel_index = index;\n  \
    \          last_vowel_char = ch;\n        } else {\n            last_consonant_index\
    \ = index;\n            last_consonant_char = ch;\n        }\n        if last_vowel_index\
    \ > last_consonant_index {\n            result = last_vowel_char.to_string();\n\
    \        }\n        last_char = ch;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpczu6itpi.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut last_consonant = false;\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if last_consonant\
    \ {\n                result.push(c);\n                found = true;\n        \
    \        break;\n            }\n        } else {\n            last_consonant =\
    \ true;\n        }\n    }\n    if found {\n        result\n    } else {\n    \
    \    String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpgwgf2tpj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            let distance = word.len() -\
    \ i;\n            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbxhjxws1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_vowel < last_consonant {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"grt\"`,\n right: `\"u\"`', /tmp/tmpyxejnx0v.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut is_vowel = false;\n    while\
    \ index > 0 {\n        let c = word.chars().nth(index).unwrap();\n        if vowels.contains(&c)\
    \ {\n            is_vowel = true;\n        } else if is_vowel {\n            result.push(c);\n\
    \            break;\n        }\n        index -= 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpdqhqy8nc.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut flag = false;\n    let mut i = word.len() - 1;\n    while i > 0 {\n\
    \        if vowels.contains(&word.chars().nth(i).unwrap()) {\n            if !vowels.contains(&word.chars().nth(i\
    \ - 1).unwrap()) {\n                result.push(word.chars().nth(i).unwrap());\n\
    \                flag = true;\n                break;\n            }\n       \
    \ }\n        i -= 1;\n    }\n    if flag {\n        result\n    } else {\n   \
    \     String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpa2gxqu6e.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (index, letter) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&letter) {\n            if index < closest_vowel_index\
    \ {\n                closest_vowel = letter.to_string();\n                closest_vowel_index\
    \ = index;\n            }\n        } else {\n            if !closest_vowel.is_empty()\
    \ {\n                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp5tx48d48.rs:19:53\n     |\n19   |     for (index, letter) in\
    \ word.chars().enumerate().rev() {\n     |                                   \
    \                  ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmp5tx48d48.rs:19:28\n   |\n19 |     for (index,\
    \ letter) in word.chars().enumerate().rev() {\n   |                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut found_vowel = false;\n\
    \    let mut closest_vowel = String::new();\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i == 0 {\n             \
    \   break;\n            }\n            found_vowel = true;\n            closest_vowel\
    \ = c.to_string();\n            break;\n        }\n    }\n    if found_vowel {\n\
    \        closest_vowel\n    } else {\n        String::new()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpb3jlz092.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut is_consonant\
    \ = false;\n    let mut is_vowel = false;\n    for (index, ch) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&ch) {\n            vowel_index = index;\n   \
    \         is_vowel = true;\n        } else {\n            consonant_index = index;\n\
    \            is_consonant = true;\n        }\n        if is_vowel && is_consonant\
    \ {\n            result = word[vowel_index..consonant_index].to_string();\n  \
    \          break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'begin <= end (1 <= 0) when slicing `yogurt`',\
    \ library/core/src/str/mod.rs:111:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut next_char\
    \ = ' ';\n    let mut found_vowel = false;\n    let mut found_consonant = false;\n\
    \    let mut found_consonant_before_vowel = false;\n    let mut found_consonant_after_vowel\
    \ = false;\n    let mut vowel_index = 0;\n    let mut consonant_index = 0;\n \
    \   let mut consonant_before_vowel_index = 0;\n    let mut consonant_after_vowel_index\
    \ = 0;\n    let mut vowel_distance = 0;\n    let mut consonant_distance = 0;\n\
    \    let mut consonant_before_vowel_distance = 0;\n    let mut consonant_after_vowel_distance\
    \ = 0;\n    let mut word_length = word.len();\n    let mut word_chars = word.chars();\n\
    \    let mut word_chars_rev = word.chars().rev();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    let consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P',\
    \ 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_index_vec =\
    \ Vec::new();\n    let mut consonant_index_vec = Vec::new();\n    let mut consonant_before_vowel_index_vec\
    \ = Vec::new();\n    let mut consonant_after_vowel_index_vec = Vec::new();\n \
    \   let mut vowel_distance_vec = Vec::new();\n    let mut consonant_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3_9jjmgh.rs:41:23\n   |\n\
    41 |     let mut consonant_\n   |                       ^ help: add `;` here\n\
    42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_9jjmgh.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_pos = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_vowel_pos {\n\
    \                closest_vowel_pos = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if !closest_vowel.is_empty() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmprrl6d99v.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmprrl6d99v.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            let distance = word.len() -\
    \ i;\n            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpsfj3pbom.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut found_consonant = false;\n    let mut\
    \ found_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                    if found_consonant\
    \ {\n                        result.push(c);\n                        found_vowel\
    \ = true;\n                        break;\n                    }\n           \
    \     } else {\n                    found_consonant = true;\n                }\n\
    \            } else {\n                if c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U' {\n                    if found_consonant {\n         \
    \               result.push(c);\n                        found_vowel = true;\n\
    \                        break;\n                    }\n                } else\
    \ {\n                    found_consonant = true;\n                }\n        \
    \    }\n        }\n    }\n    if found_vowel {\n        result\n    } else {\n\
    \        String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpo3zbiow6.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut word_chars = word.chars().collect::<Vec<char>>();\n\
    \    word_chars.reverse();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for c in word_chars {\n        if vowels.contains(&c) {\n      \
    \      prev_vowel = c;\n        } else if prev_char != ' ' && prev_vowel != '\
    \ ' {\n            return prev_vowel.to_string();\n        }\n        prev_char\
    \ = c;\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp2g674pp5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            let mut distance = word.len()\
    \ - i;\n            if i > 0 {\n                distance -= 1;\n            }\n\
    \            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpb_fd6ecp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_char\
    \ != ' ' && !vowels.contains(&prev_char) {\n                result.push(c);\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpd03wmo_c.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    let mut last_consonant_index\
    \ = 0;\n    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            if i - last_consonant_index < closest_distance {\n          \
    \      closest_distance = i - last_consonant_index;\n                closest_vowel\
    \ = c.to_string();\n            }\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpib9c8al4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                if !vowels.contains(&word.chars().nth(i - 1).unwrap())\
    \ && !vowels.contains(&word.chars().nth(i + 1).unwrap()) {\n                 \
    \   if i < closest_distance {\n                        closest_distance = i;\n\
    \                        closest_vowel = c.to_string();\n                    }\n\
    \                }\n            }\n        }\n    }\n    closest_vowel\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpg6v7pkv5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_char != ' ' && prev_vowel != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpclcde8jh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut vowel_index = 0;\n    let mut consonant_index = 0;\n    let mut is_consonant\
    \ = false;\n    for (index, c) in word.chars().enumerate().rev() {\n        if\
    \ vowels.contains(&c) {\n            vowel_index = index;\n            if is_consonant\
    \ {\n                closest_vowel = c.to_string();\n                break;\n\
    \            }\n        } else {\n            consonant_index = index;\n     \
    \       is_consonant = true;\n        }\n    }\n    if vowel_index > consonant_index\
    \ {\n        closest_vowel\n    } else {\n        String::new()\n    }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpvobl5env.rs:21:48\n     |\n21   |     for (index, c) in word.chars().enumerate().rev()\
    \ {\n     |                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpvobl5env.rs:21:23\n\
    \   |\n21 |     for (index, c) in word.chars().enumerate().rev() {\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            if is_vowel(c) {\n                result.push(c);\n         \
    \       is_vowel = true;\n            }\n        } else {\n            if !is_vowel(c)\
    \ {\n                is_consonant = true;\n            }\n        }\n    }\n \
    \   result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp0knw5hpa.rs:28:16\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n28 |             if is_vowel(c) {\n   |              \
    \  ^^^^^^^^---\n   |                |\n   |                call expression requires\
    \ function\n\nerror[E0618]: expected function, found `bool`\n  --> /tmp/tmp0knw5hpa.rs:33:17\n\
    \   |\n18 |     let mut is_vowel = false;\n   |         ------------ `is_vowel`\
    \ has type `bool`\n...\n33 |             if !is_vowel(c) {\n   |             \
    \    ^^^^^^^^---\n   |                 |\n   |                 call expression\
    \ requires function\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  let mut vowel_found = false;\n    let mut consonant_found = false;\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n   \
    \         last_vowel_index = i;\n            vowel_found = true;\n        } else\
    \ {\n            if vowel_found {\n                last_consonant_index = i;\n\
    \                consonant_found = true;\n            }\n        }\n    }\n  \
    \  if vowel_found && consonant_found {\n        result.push(word.chars().nth(last_vowel_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpfkgo1qqb.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (index, character) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&character) {\n            if index < closest_index\
    \ {\n                closest_index = index;\n                closest_vowel = character.to_string();\n\
    \            }\n        } else {\n            if closest_index != word.len() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmppq_uqd0h.rs:19:56\n     |\n19   |     for (index, character)\
    \ in word.chars().enumerate().rev() {\n     |                                \
    \                        ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    note: required by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n  --> /tmp/tmppq_uqd0h.rs:19:31\n   |\n\
    19 |     for (index, character) in word.chars().enumerate().rev() {\n   |    \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut vowels = String::from(\"aeiouAEIOU\"\
    );\n    let mut consonants = String::from(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    );\n    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c\
    \ in word.chars() {\n        if vowels.contains(c) {\n            if consonants.contains(prev_char)\
    \ && consonants.contains(prev_prev_char) {\n                result = c.to_string();\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp02r7xa23.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut prev_char = ' ';\n    let mut\
    \ prev_vowel = ' ';\n    let mut prev_consonant = ' ';\n    while index >= 0 {\n\
    \        let curr_char = word.chars().nth(index).unwrap();\n        if vowels.contains(&curr_char)\
    \ {\n            prev_vowel = curr_char;\n        } else {\n            prev_consonant\
    \ = curr_char;\n        }\n        if prev_vowel != ' ' && prev_consonant != '\
    \ ' {\n            result.push(prev_vowel);\n            break;\n        }\n \
    \       index -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpko_cpj6q.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    let mut i = word.len() - 1;\n    while i >\
    \ 0 {\n        let ch = word.chars().nth(i).unwrap();\n        if ch == 'a' ||\
    \ ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n            vowels.push(ch);\n\
    \        } else {\n            consonants.push(ch);\n        }\n        if vowels.len()\
    \ > 0 && consonants.len() > 0 {\n            result = vowels.clone();\n      \
    \      break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqmbws1o_.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut last_consonant = false;\n    let mut\
    \ last_vowel = false;\n    for c in word.chars().rev() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n            if last_consonant {\n        \
    \        result.push(c);\n                break;\n            }\n            last_vowel\
    \ = true;\n        } else {\n            if last_vowel {\n                last_consonant\
    \ = true;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp3f3_jfn0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_idx = word.len();\n    for (idx, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if idx < closest_vowel_idx\
    \ {\n                closest_vowel_idx = idx;\n                closest_vowel =\
    \ c.to_string();\n            }\n        } else {\n            if closest_vowel_idx\
    \ != word.len() {\n                break;\n            }\n        }\n    }\n \
    \   closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp9p1k2p9a.rs:19:46\n     |\n19   |     for (idx, c) in word.chars().enumerate().rev()\
    \ {\n     |                                              ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp9p1k2p9a.rs:19:21\n\
    \   |\n19 |     for (idx, c) in word.chars().enumerate().rev() {\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut prev_char = ' ';\n    let mut\
    \ prev_vowel = ' ';\n    for c in word.chars().rev() {\n        if is_vowel(c)\
    \ {\n            if prev_char != ' ' && !is_vowel(prev_char) {\n             \
    \   closest_vowel.push(c);\n                break;\n            } else {\n   \
    \             prev_vowel = c;\n            }\n        } else {\n            if\
    \ prev_vowel != ' ' {\n                closest_vowel.push(prev_vowel);\n     \
    \           break;\n            }\n        }\n        prev_char = c;\n    }\n\
    \    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp73i2ia_8.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp73i2ia_8.rs:21:37\n   |\n21 |             if prev_char != ' ' && !is_vowel(prev_char)\
    \ {\n   |                                     ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && i < word.len()\
    \ - 1 {\n                let left_char = word.chars().nth(i - 1).unwrap();\n \
    \               let right_char = word.chars().nth(i + 1).unwrap();\n         \
    \       if !vowels.contains(&left_char) && !vowels.contains(&right_char) {\n \
    \                   let distance = word.len() - i;\n                    if distance\
    \ < closest_distance {\n                        closest_distance = distance;\n\
    \                        closest_vowel = c.to_string();\n                    }\n\
    \                }\n            }\n        }\n    }\n    closest_vowel\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut prev_char = ' ';\n    let\
    \ mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n        if vowels.contains(&c)\
    \ {\n            prev_vowel = c;\n        } else if prev_vowel != ' ' {\n    \
    \        return prev_vowel.to_string();\n        }\n        prev_char = c;\n \
    \   }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp__3nf6jb.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    for c in word.chars() {\n        if is_vowel(c)\
    \ {\n            vowels.push(c);\n        } else {\n            consonants.push(c);\n\
    \        }\n    }\n    if vowels.len() == 0 || consonants.len() == 0 {\n     \
    \   return result;\n    }\n    let mut i = vowels.len() - 1;\n    let mut j =\
    \ consonants.len() - 1;\n    while i >= 0 && j >= 0 {\n        if is_vowel(consonants.chars().nth(j).unwrap())\
    \ {\n            j -= 1;\n        } else {\n            result.push(vowels.chars().nth(i).unwrap());\n\
    \            break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpk1aa55y2.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpk1aa55y2.rs:32:12\n   |\n32 |         if is_vowel(consonants.chars().nth(j).unwrap())\
    \ {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut consonants = String::new();\n    let\
    \ mut result = String::new();\n    for c in word.chars() {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowels.push(c);\n\
    \        } else {\n            consonants.push(c);\n        }\n    }\n    if vowels.len()\
    \ == 0 || consonants.len() == 0 {\n        return result;\n    }\n    let mut\
    \ i = vowels.len() - 1;\n    let mut j = consonants.len() - 1;\n    loop {\n \
    \       if i < 0 || j < 0 {\n            break;\n        }\n        if vowels.chars().nth(i).unwrap()\
    \ == consonants.chars().nth(j).unwrap() {\n            i -= 1;\n            j\
    \ -= 1;\n        } else {\n            result.push(vowels.chars().nth(i).unwrap());\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpp5vna_bl.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for c in word.chars().rev() {\n        if is_vowel(c) {\n      \
    \      prev_vowel = c;\n        } else if prev_char != ' ' && is_vowel(prev_char)\
    \ {\n            result.push(prev_vowel);\n            break;\n        }\n   \
    \     prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5yplivpg.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp5yplivpg.rs:22:39\n   |\n22 |         } else if prev_char != ' ' &&\
    \ is_vowel(prev_char) {\n   |                                       ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_is_consonant = false;\n    let\
    \ mut is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel\
    \ {\n            if prev_is_consonant {\n                result.push(c);\n   \
    \             break;\n            }\n        } else {\n            if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n                is_vowel = true;\n       \
    \     }\n        }\n        prev_is_consonant = !is_vowel;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpeqhbdou0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut last_consonant = false;\n    let mut\
    \ last_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                    if last_consonant\
    \ {\n                        result.push(c);\n                        break;\n\
    \                    }\n                    last_vowel = true;\n             \
    \   } else {\n                    last_consonant = true;\n                }\n\
    \            } else {\n                if c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U' {\n                    if last_consonant {\n          \
    \              result.push(c);\n                        break;\n             \
    \       }\n                    last_vowel = true;\n                } else {\n\
    \                    last_consonant = true;\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpzr7ta29d.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut last_consonant = false;\n    let mut\
    \ last_vowel = false;\n    for c in word.chars().rev() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                    if last_consonant\
    \ {\n                        result.push(c);\n                        break;\n\
    \                    }\n                    last_vowel = true;\n             \
    \   } else {\n                    last_consonant = true;\n                }\n\
    \            } else {\n                if c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U' {\n                    if last_consonant {\n          \
    \              result.push(c);\n                        break;\n             \
    \       }\n                    last_vowel = true;\n                } else {\n\
    \                    last_consonant = true;\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpk5d5wqdu.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            let distance = word.len() -\
    \ i;\n            if distance < closest_distance {\n                closest_distance\
    \ = distance;\n                closest_vowel = c.to_string();\n            }\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpp4gpi4x_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    let mut index = word.len() - 1;\n\
    \    while index > 0 {\n        let char = word.chars().nth(index).unwrap();\n\
    \        if vowels.contains(&char) {\n            if index < closest_index {\n\
    \                closest_vowel = char.to_string();\n                closest_index\
    \ = index;\n            }\n        } else {\n            if closest_index != word.len()\
    \ {\n                return closest_vowel;\n            }\n        }\n       \
    \ index -= 1;\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp_ohz5p8w.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut vowel_found = false;\n    let\
    \ mut prev_char_is_consonant = false;\n    let mut next_char_is_consonant = false;\n\
    \    let mut prev_char = ' ';\n    let mut next_char = ' ';\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_count = 0;\n    let mut vowel_pos = 0;\n    let mut\
    \ vowel_pos_count = 0;\n    let mut vowel_pos_index = 0;\n    let mut vowel_pos_index_count\
    \ = 0;\n    let mut vowel_pos_index_count_count = 0;\n    let mut vowel_pos_index_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count = 0;\n    let mut\
    \ vowel_pos_index_count_count_count_count_count = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut vowel_pos_index_count_count_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0;\n   \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp28fg169n.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_prev_char\
    \ = ' ';\n    for c in word.chars().rev() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            if prev_char != ' ' && prev_prev_char\
    \ != ' ' {\n                result.push(c);\n                break;\n        \
    \    }\n        }\n        prev_prev_char = prev_char;\n        prev_char = c;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp8o8n05xt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            last_vowel_index = i;\n        } else {\n            last_consonant_index\
    \ = i;\n        }\n        if last_vowel_index > last_consonant_index {\n    \
    \        result = c.to_string();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp8ps4t58v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut prev_char = ' ';\n    let\
    \ mut prev_vowel = ' ';\n    for c in word.chars().rev() {\n        if vowels.contains(&c)\
    \ {\n            prev_vowel = c;\n        } else if prev_vowel != ' ' {\n    \
    \        return prev_vowel.to_string();\n        }\n        prev_char = c;\n \
    \   }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp29dsd586.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel && !is_consonant {\n            is_vowel = false;\n     \
    \   }\n        if is_consonant && !is_vowel {\n            is_consonant = false;\n\
    \        }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n            is_vowel = true;\n        } else {\n            is_consonant\
    \ = true;\n        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp497kok09.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word_vec: Vec<char> = word.chars().collect();\n    let mut vowel_vec: Vec<char>\
    \ = Vec::new();\n    let mut vowel_index: Vec<usize> = Vec::new();\n    let mut\
    \ vowel_distance: Vec<usize> = Vec::new();\n    let mut vowel_distance_index:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_distance_min: usize = word.len();\n\
    \    let mut vowel_distance_min_index: usize = word.len();\n    let mut vowel_distance_min_index_vec:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_distance_min_index_vec_index: usize\
    \ = 0;\n    let mut vowel_distance_min_index_vec_index_vec: Vec<usize> = Vec::new();\n\
    \    let mut vowel_distance_min_index_vec_index_vec_index: usize = 0;\n    let\
    \ mut vowel_distance_min_index_vec_index_vec_index_vec: Vec<usize> = Vec::new();\n\
    \    let mut vowel_distance_min_index_vec_index_vec_index_vec_index: usize = 0;\n\
    \    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec: Vec<usize>\
    \ = Vec::new();\n    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index:\
    \ usize = 0;\n    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index_vec:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index_vec_index:\
    \ usize = 0;\n    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index_vec_index_vec:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index_vec_index_vec_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx2napswu.rs:34:92\n   |\n\
    34 |     let mut vowel_distance_min_index_vec_index_vec_index_vec_index_vec_index_vec_index_vec_\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n35 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx2napswu.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(&c) {\n            if i < closest_index {\n  \
    \              closest_index = i;\n                closest_vowel = c.to_string();\n\
    \            }\n        } else {\n            if closest_index != word.len() {\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpa2vgk1n6.rs:19:44\n     |\n19   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpa2vgk1n6.rs:19:19\n\
    \   |\n19 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut is_consonant = false;\n    let mut\
    \ is_vowel = false;\n    for c in word.chars().rev() {\n        if is_vowel &&\
    \ is_consonant {\n            result.push(c);\n            break;\n        }\n\
    \        if is_vowel {\n            is_vowel = false;\n        }\n        if is_consonant\
    \ {\n            is_consonant = false;\n        }\n        if is_vowel_char(c)\
    \ {\n            is_vowel = true;\n        } else {\n            is_consonant\
    \ = true;\n        }\n    }\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel_char` in this scope\n  -->\
    \ /tmp/tmpjqe023qh.rs:30:12\n   |\n30 |         if is_vowel_char(c) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut found_consonant = false;\n    for c in word.chars().rev() {\n   \
    \     if vowels.contains(&c) {\n            if found_consonant {\n           \
    \     result.push(c);\n                break;\n            }\n        } else {\n\
    \            found_consonant = true;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp418fswz5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut found_consonant = false;\n \
    \   while index > 0 {\n        let c = word.chars().nth(index).unwrap();\n   \
    \     if !vowels.contains(&c) {\n            found_consonant = true;\n       \
    \ } else if found_consonant {\n            closest_vowel = c.to_string();\n  \
    \          break;\n        }\n        index -= 1;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp71038v_i.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel_index = 0;\n    let mut last_consonant_index = 0;\n  \
    \  let mut is_first_vowel = true;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if !is_first_vowel {\n    \
    \            last_vowel_index = i;\n            }\n            is_first_vowel\
    \ = false;\n        } else {\n            if !is_first_vowel {\n             \
    \   last_consonant_index = i;\n            }\n        }\n    }\n    if last_vowel_index\
    \ > last_consonant_index {\n        result.push(word.chars().nth(last_vowel_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpv8yuwdth.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_distance = word.len();\n    let mut consonant_count = 0;\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            if consonant_count >= 2 {\n                if i < closest_distance\
    \ {\n                    closest_distance = i;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            }\n            consonant_count\
    \ = 0;\n        } else {\n            consonant_count += 1;\n        }\n    }\n\
    \    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpl9tdbzwa.rs:20:44\n     |\n20   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpl9tdbzwa.rs:20:19\n\
    \   |\n20 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_vowel_index = word.len();\n    for (index, character) in\
    \ word.chars().enumerate().rev() {\n        if vowels.contains(&character) {\n\
    \            if index < closest_vowel_index {\n                closest_vowel_index\
    \ = index;\n                closest_vowel = character.to_string();\n         \
    \   }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpifc315_j.rs:19:56\n     |\n19   |     for (index, character)\
    \ in word.chars().enumerate().rev() {\n     |                                \
    \                        ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    note: required by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n  --> /tmp/tmpifc315_j.rs:19:31\n   |\n\
    19 |     for (index, character) in word.chars().enumerate().rev() {\n   |    \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word_vec: Vec<char> = word.chars().collect();\n    let mut vowel_vec: Vec<char>\
    \ = Vec::new();\n    let mut vowel_index: Vec<usize> = Vec::new();\n    let mut\
    \ vowel_index_left: Vec<usize> = Vec::new();\n    let mut vowel_index_right: Vec<usize>\
    \ = Vec::new();\n    let mut vowel_index_left_right: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_right_left: Vec<usize> = Vec::new();\n    let mut vowel_index_left_right_left:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_index_right_left_right: Vec<usize>\
    \ = Vec::new();\n    let mut vowel_index_left_right_left_right: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_right_left_right_left: Vec<usize> = Vec::new();\n   \
    \ let mut vowel_index_left_right_left_right_left: Vec<usize> = Vec::new();\n \
    \   let mut vowel_index_right_left_right_left_right: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_left_right_left_right_left_right: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_right_left_right_left_right_left: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_left_right_left_right_left_right_left: Vec<usize> = Vec::new();\n\
    \    let mut vowel_index_right_left_right_left_right_left_right: Vec<usize> =\
    \ Vec::new();\n    let mut vowel_index_left_right_left_right_left_right_left_right:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_index_right_left_right_left_right_left_right_left:\
    \ Vec<usize> = Vec::new();\n    let mut vowel_index_left_right_left_right_left_right_left_right_left\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0l6bl9p3.rs:35:73\n   |\n\
    35 |     let mut vowel_index_left_right_left_right_left_right_left_right_left\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0l6bl9p3.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut closest_vowel = String::new();\n    let mut last_consonant = String::new();\n\
    \    let mut last_vowel = String::new();\n    let mut is_last_vowel = false;\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in word.chars() {\n\
    \        if vowels.contains(&c) {\n            if is_last_vowel {\n          \
    \      last_vowel = c.to_string();\n            } else {\n                closest_vowel\
    \ = c.to_string();\n                last_consonant = String::new();\n        \
    \        is_last_vowel = true;\n            }\n        } else {\n            if\
    \ is_last_vowel {\n                last_consonant = c.to_string();\n         \
    \       is_last_vowel = false;\n            }\n        }\n    }\n    if last_consonant.is_empty()\
    \ {\n        String::new()\n    } else {\n        closest_vowel\n    }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"e\"`,\n right: `\"\"`', /tmp/tmp0wtl1_de.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if prev_char != ' ' && vowels.contains(&prev_char)\
    \ && !vowels.contains(&prev_prev_char) {\n            result.push(prev_char);\n\
    \            break;\n        }\n        prev_prev_char = prev_char;\n        prev_char\
    \ = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmtx6zyz1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![];\n    let mut consonants = vec![];\n    let mut result =\
    \ String::new();\n    let mut vowel_index = 0;\n    let mut consonant_index =\
    \ 0;\n    let mut last_consonant_index = 0;\n    let mut last_vowel_index = 0;\n\
    \    let mut last_consonant = String::new();\n    let mut last_vowel = String::new();\n\
    \    let mut vowel_distance = 0;\n    let mut consonant_distance = 0;\n    let\
    \ mut distance = 0;\n    let mut word_vec: Vec<char> = word.chars().collect();\n\
    \    let mut word_len = word_vec.len();\n    let mut vowel_len = 0;\n    let mut\
    \ consonant_len = 0;\n    let mut last_consonant_len = 0;\n    let mut last_vowel_len\
    \ = 0;\n    let mut vowel_flag = false;\n    let mut consonant_flag = false;\n\
    \    let mut last_consonant_flag = false;\n    let mut last_vowel_flag = false;\n\
    \    let mut vowel_count = 0;\n    let mut consonant_count = 0;\n    let mut last_consonant_count\
    \ = 0;\n    let mut last_vowel_count = 0;\n    let mut vowel_distance_count =\
    \ 0;\n    let mut consonant_distance_count = 0;\n    let mut last_consonant_distance_count\
    \ = 0;\n    let mut last_vowel_distance_count = 0;\n    let mut vowel_distance_flag\
    \ = false;\n    let mut consonant_distance_flag = false;\n    let mut last_consonant_distance_flag\
    \ = false;\n    let mut last_vowel_distance_flag = false;\n    let mut vowel_distance_len\
    \ = 0;\n    let mut consonant_distance_len = 0;\n    let mut last_consonant_distance_len\
    \ = 0;\n    let mut last_vowel_distance_len = 0;\n    let mut vowel_distance_index\
    \ = 0;\n    let mut consonant_distance_index\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphw0yja3h.rs:55:37\n   |\n\
    55 |     let mut consonant_distance_index\n   |                              \
    \       ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphw0yja3h.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut word = word.chars().rev().collect::<Vec<char>>();\n    let mut result =\
    \ String::new();\n    let mut is_consonant = false;\n    for c in word {\n   \
    \     if is_consonant && is_vowel(c) {\n            result.push(c);\n        \
    \    break;\n        }\n        if !is_vowel(c) {\n            is_consonant =\
    \ true;\n        }\n    }\n    result.chars().rev().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpialywq94.rs:20:28\n\
    \   |\n20 |         if is_consonant && is_vowel(c) {\n   |                   \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmpialywq94.rs:24:13\n   |\n24 |      \
    \   if !is_vowel(c) {\n   |             ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_char != ' ' && prev_vowel != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpkebbo48v.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut last_consonant = String::new();\n    let mut last_vowel = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if !last_consonant.is_empty() && !last_vowel.is_empty() {\n\
    \            closest_vowel = last_vowel.clone();\n            break;\n       \
    \ }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp6g8ed7n9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplqvpwmiv.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut last_vowel = String::new();\n    let mut last_consonant = String::new();\n\
    \    for c in word.chars() {\n        if vowels.contains(&c) {\n            last_vowel\
    \ = c.to_string();\n        } else {\n            last_consonant = c.to_string();\n\
    \        }\n        if last_vowel != \"\" && last_consonant != \"\" {\n      \
    \      result = last_vowel.clone();\n            break;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpda17hayz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut last_consonant = 0;\n    for (i, c) in\
    \ word.chars().enumerate().rev() {\n        if vowels.contains(&c) {\n       \
    \     if found {\n                result.push(c);\n                break;\n  \
    \          }\n        } else {\n            if i != last_consonant {\n       \
    \         found = true;\n            }\n            last_consonant = i;\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp14_bnhu4.rs:20:44\n     |\n20   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp14_bnhu4.rs:20:19\n\
    \   |\n20 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_prev_char = ' ';\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            if prev_char\
    \ != ' ' && !vowels.contains(&prev_char) {\n                closest_vowel.push(c);\n\
    \                break;\n            }\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = c;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmj031oux.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut last_vowel = 0;\n    let mut last_consonant = 0;\n    for (i, c)\
    \ in word.chars().enumerate() {\n        if vowels.contains(&c) {\n          \
    \  last_vowel = i;\n        } else {\n            last_consonant = i;\n      \
    \  }\n        if last_vowel > last_consonant {\n            result = word[last_vowel..last_vowel\
    \ + 1].to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpz_bo6vib.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut is_consonant = false;\n    while\
    \ index > 0 {\n        let ch = word.chars().nth(index).unwrap();\n        if\
    \ vowels.contains(&ch) {\n            if is_consonant {\n                result.push(ch);\n\
    \                break;\n            }\n        } else {\n            is_consonant\
    \ = true;\n        }\n        index -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpm1yzfnuv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    let mut found_vowel = false;\n    let mut found_consonant\
    \ = false;\n    for c in word.chars().rev() {\n        if vowels.contains(&c)\
    \ {\n            if found_consonant {\n                found = true;\n       \
    \         result.push(c);\n                break;\n            } else {\n    \
    \            found_vowel = true;\n            }\n        } else {\n          \
    \  if found_vowel {\n                found_consonant = true;\n            }\n\
    \        }\n    }\n    if found {\n        result\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp5ffl6jqb.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut index = word.len() - 1;\n    let mut found_consonant = false;\n \
    \   while index > 0 {\n        let c = word.chars().nth(index).unwrap();\n   \
    \     if vowels.contains(&c) {\n            if found_consonant {\n           \
    \     result.push(c);\n                break;\n            }\n        } else {\n\
    \            found_consonant = true;\n        }\n        index -= 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpz7nkl4nc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = String::from(\"aeiouAEIOU\");\n    let mut result = String::from(\"\
    \");\n    let mut index = 0;\n    let mut found = false;\n    let mut last_vowel\
    \ = 0;\n    let mut last_consonant = 0;\n    let mut last_vowel_index = 0;\n \
    \   let mut last_consonant_index = 0;\n    for c in word.chars() {\n        if\
    \ vowels.contains(c) {\n            last_vowel = c as u8;\n            last_vowel_index\
    \ = index;\n        } else {\n            last_consonant = c as u8;\n        \
    \    last_consonant_index = index;\n        }\n        if last_vowel_index > last_consonant_index\
    \ {\n            result = String::from(last_vowel as char);\n            found\
    \ = true;\n        }\n        index += 1;\n    }\n    if !found {\n        result\
    \ = String::from(\"\");\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpe31dh1zv.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for c in word.chars().rev() {\n        if is_vowel(c) {\n      \
    \      prev_vowel = c;\n        } else if prev_char != ' ' && is_vowel(prev_char)\
    \ {\n            result.push(prev_vowel);\n            break;\n        }\n   \
    \     prev_char = c;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5jry7hj8.rs:20:12\n\
    \   |\n20 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp5jry7hj8.rs:22:39\n   |\n22 |         } else if prev_char != ' ' &&\
    \ is_vowel(prev_char) {\n   |                                       ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut prev_char = ' ';\n    let mut prev_vowel = ' ';\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(&c) {\n            prev_vowel = c;\n        }\
    \ else if prev_char != ' ' && prev_vowel != ' ' {\n            result.push(prev_vowel);\n\
    \            break;\n        }\n        prev_char = c;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp9758_zfb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    let mut found = false;\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            if i > 0 && !vowels.contains(&word.chars().rev().nth(i\
    \ - 1).unwrap()) {\n                result.push(c);\n                found = true;\n\
    \                break;\n            }\n        }\n    }\n    if !found {\n  \
    \      result.push_str(\"\");\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpe74lpyhp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut closest_vowel = String::new();\n\
    \    let mut index = 0;\n    for (i, c) in word.chars().rev().enumerate() {\n\
    \        if vowels.contains(&c) {\n            index = i;\n            closest_vowel.push(c);\n\
    \            break;\n        }\n    }\n    if index == 0 {\n        return String::new();\n\
    \    }\n    for (i, c) in word.chars().rev().enumerate() {\n        if i > index\
    \ && !vowels.contains(&c) {\n            return closest_vowel;\n        }\n  \
    \  }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp_4pkwcks.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
