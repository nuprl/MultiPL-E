name: HumanEval_126_is_sorted
language: rs
results:
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpnk6j6jbz.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = std::isize::MIN;\n    for i in lst {\n        if i < prev {\n       \
    \     sorted = false;\n            break;\n        }\n        prev = i;\n    }\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5xf9dkou.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppjqkvbms.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc9swbkup.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmppdy7xhdw.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for n in\
    \ lst {\n        match prev {\n            Some(p) if p >= n => return false,\n\
    \            _ => prev = Some(n),\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpges3ftdr.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8s2pzrna.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(prev) = last {\n            if i < prev {\n     \
    \           return false;\n            }\n        }\n        last = Some(i);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6rbglcwj.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfgkylpte.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for n in lst {\n        match last {\n            None =>\
    \ {\n                last = Some(n);\n            }\n            Some(last_n)\
    \ => {\n                if n < last_n {\n                    sorted = false;\n\
    \                    break;\n                }\n                last = Some(n);\n\
    \            }\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnf1ybms2.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ (),\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp20i928vx.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for n in\
    \ lst {\n        match prev {\n            Some(p) if p >= n => return false,\n\
    \            _ => prev = Some(n),\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpda85fdz7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprm6f065p.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(x)\
    \ => {\n                if i < x {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ (),\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7mvohccz.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_h1ou9tk.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn8973k8s.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(p) => {\n                if p >= x {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2r_0_3xg.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy_7j3a04.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in lst {\n        if i < last {\n            sorted\
    \ = false;\n        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpdzc7otsd.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= prev {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpsogdmyll.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp31rsf2n0.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2jeoo1b2.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in lst {\n        if i < last {\n            sorted\
    \ = false;\n        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp9r8fq2jg.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        if let Some(p) = prev {\n      \
    \      if num < p {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcexyzm07.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpybdpxfl_.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1ubdqe5j.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = 0;\n    for i in lst {\n        if i < last {\n            sorted = false;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpocqhgbke.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps9rxv5kt.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ (),\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpskwxslwd.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i < p {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplarlh51z.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2u1pffsf.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm3odxppi.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8dkcfp77.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd2dovixp.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd3ocxgc_.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = 0;\n    for i in lst {\n        if i < prev {\n            sorted = false;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0glww_f0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ i = 0;\n    while i < lst.len() - 1 {\n        if lst[i] >= lst[i + 1] {\n \
    \           sorted = false;\n            break;\n        }\n        i += 1;\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfkk2hd3_.rs:24:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxnqkio8e.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnfnv1dt3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if prev >= lst[i] {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp1ccxfuhf.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i <= p {\n                    sorted = false;\n   \
    \                 break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplrl8u6z2.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(y) => {\n                if x < y {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpok9usxlf.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpvn49hf6a.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(x)\
    \ => {\n                if num < x {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => {}\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjut6s1qh.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt3hh5wbh.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i < p {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb4p_z1zz.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = 0;\n    for i in lst {\n        if i < prev {\n            sorted = false;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpashwbaws.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpndj3o4qe.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p == i {\n          \
    \      return false;\n            }\n            if p > i {\n                return\
    \ false;\n            }\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_rkloklq.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpitnn14zp.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i < j {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz2zdta49.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9pdjqbo4.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbs0oq6qn.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(j) = last {\n            if i <= j {\n          \
    \      return false;\n            }\n        }\n        last = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7ltsz8yi.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpx6ld9uew.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuc26mww3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= last {\n \
    \           sorted = false;\n            break;\n        }\n        last = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp48v8cesf.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(p) => {\n                if p >= x {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp86t3ysm5.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= prev {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmps3ne96lo.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i < p {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3v5u0sz0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp34eygu9f.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: Implement me!\n    false\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsjwqhi1k.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprp1ajw18.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp229o7crh.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            return false;\n        }\n    \
    \    last = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp8mhs6ax8.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(x) => {\n                if i\
    \ <= x {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ygnvbe4.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbuilvsvy.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = 0;\n    for i in lst {\n        if i < prev {\n            sorted = false;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptv67qoq8.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnch9skuf.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if num < p {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => (),\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy29owek7.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] <= prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmptvpj0ur_.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] < prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwxf9i_h_.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(x)\
    \ => {\n                if i < x {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxfdivm73.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = -1;\n    for i in lst {\n        if i <= last {\n            sorted =\
    \ false;\n            break;\n        }\n        last = i;\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf_eg2u1m.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i <= p {\n                    sorted = false;\n   \
    \                 break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkxkql5hj.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp_gc69kt1.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] <= prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp2hvz1nbx.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        if let Some(prev_num) = prev {\n\
    \            if num <= prev_num {\n                sorted = false;\n         \
    \       break;\n            }\n        }\n        prev = Some(num);\n    }\n \
    \   sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp__t7nph4.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe_ifx8lc.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp0y6yxg2z.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpoqzwxtkl.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpmwzr0l9b.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbkis4ds2.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy9il_of4.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplsrhueda.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if num < p {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => {}\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpscr1cx8x.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(y) => {\n                if x < y {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplsa46kv7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjk0vgrza.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = 0;\n    for i in lst {\n        if i < prev {\n            sorted = false;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgzwrnvh8.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for i in\
    \ lst {\n        match last {\n            None => last = Some(i),\n         \
    \   Some(x) => {\n                if i < x {\n                    return false;\n\
    \                }\n                last = Some(i);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptg0v7qrd.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if num < p {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => {}\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphfbsbl2b.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqy8mrudf.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpxzrfjeml.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwv1_fisl.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpev5r0105.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= prev {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpcjuozky1.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpenqyxbrn.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] < prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpr86eaxnx.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ previous = None;\n    for i in lst {\n        match previous {\n           \
    \ Some(p) => {\n                if i < p {\n                    sorted = false;\n\
    \                    break;\n                }\n            }\n            None\
    \ => (),\n        }\n        previous = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1zphc5t3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => (),\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjadbfo91.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p == i {\n          \
    \      return false;\n            }\n            if p > i {\n                return\
    \ false;\n            }\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiiirll_a.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if prev >= lst[i] {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprxr8bcuu.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpleycfhav.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i <= j {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpritjfwj_.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjacvbbyy.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(prev_i) = prev {\n   \
    \         if i <= prev_i {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcrx9734j.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpkv60il4e.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpklt7hz3j.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1i9c2wbw.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmptegalqqg.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i < j {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvnz5qig0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp9hc436ze.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst_iter = lst.iter();\n\
    \    let mut prev = lst_iter.next();\n    for num in lst_iter {\n        if prev.is_none()\
    \ {\n            return false;\n        }\n        if num <= prev.unwrap() {\n\
    \            return false;\n        }\n        prev = Some(num);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnfzg04wk.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5zs7suiy.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < last {\n  \
    \          sorted = false;\n            break;\n        }\n        last = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmphoa9v1xy.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpo8cyxtrc.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph5wpjwhh.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxoj8c5l5.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if prev > lst[i] {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpereyib5c.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo8w8r14f.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        if let Some(p) = prev {\n      \
    \      if num <= p {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3p8oowos.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            return false;\n        }\n    \
    \    last = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpeiof87ni.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ (),\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2lxs8tf3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk5motui6.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for num in lst {\n        if let Some(last_num) = last {\n\
    \            if num <= last_num {\n                sorted = false;\n         \
    \       break;\n            }\n        }\n        last = Some(num);\n    }\n \
    \   sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfuada5zn.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for x in lst {\n        match prev {\n            None =>\
    \ prev = Some(x),\n            Some(y) => {\n                if x < y {\n    \
    \                sorted = false;\n                    break;\n               \
    \ }\n                prev = Some(x);\n            }\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf187_z3e.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if num < p {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => (),\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa4zjtm2u.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpcekuyg1r.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] <= prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpg8xwgrxa.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i < p {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp56ao4nm3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpybj1gs_2.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwt_9vhqg.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: Implement me!\n    false\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqfyrnjua.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p == i {\n          \
    \      return false;\n            }\n            if p > i {\n                return\
    \ false;\n            }\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprnlh5sb3.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n  \
    \      if lst[i] < prev {\n            return false;\n        }\n        prev\
    \ = lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpt3x1wf5k.rs:26:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp54ayvn1d.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < last {\n  \
    \          sorted = false;\n            break;\n        }\n        last = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpcz_smscx.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqcw0frfj.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i <= j {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk_bkspi3.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpl3sxje19.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpa1nc338o.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg12kcsvx.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpuft9aqu7.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpah5u5j3a.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            return false;\n        }\n    \
    \    last = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpq9b5vgxs.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpe8p2mna1.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph3l2c75s.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for item\
    \ in lst {\n        match prev {\n            None => prev = Some(item),\n   \
    \         Some(prev_item) => {\n                if item < prev_item {\n      \
    \              return false;\n                }\n                prev = Some(item);\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiwgj0gca.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuf85jibt.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < last {\n  \
    \          sorted = false;\n            break;\n        }\n        last = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpm1hh38t7.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpanni0py4.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6564_4ys.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp0t36ek1l.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptluc5vfl.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdece_wub.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if num < p {\n                    sorted = false;\n  \
    \                  break;\n                }\n            }\n            None\
    \ => {}\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphwl0jflm.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpknuz2b53.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(x)\
    \ => {\n                if i < x {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgs0z0yqz.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpavipeikf.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqge_gleo.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            return false;\n        }\n    \
    \    prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpomvl167l.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(y) => {\n                if x < y {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3f9i6hjq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0bgg1uyf.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        match prev {\n            None => prev = Some(x),\n         \
    \   Some(y) => {\n                if x < y {\n                    return false;\n\
    \                }\n                prev = Some(x);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp83c4rd4t.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i < j {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphtzymxc8.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        match last {\n            None =>\
    \ last = Some(i),\n            Some(j) => {\n                if i < j {\n    \
    \                sorted = false;\n                    break;\n               \
    \ }\n                last = Some(i);\n            }\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpim81wt8_.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7si7a5ig.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p == i {\n          \
    \      return false;\n            }\n            if p > i {\n                return\
    \ false;\n            }\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx8wrhdmk.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= prev {\n \
    \           sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpx55k7tgk.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        if let Some(p) = prev {\n      \
    \      if num < p {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprqo0nz19.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    lst.dedup();\n    lst == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplypao8od.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for x in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= x {\n          \
    \      return false;\n            }\n        }\n        prev = Some(x);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwe1fg6u3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for num in lst {\n        if let Some(p) = prev {\n      \
    \      if num <= p {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(num);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp014f_j_s.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for n in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= n {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(n);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6e784cqd.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7s96a_m4.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpx5tbpgpt.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] <= prev {\n            return false;\n        }\n        prev =\
    \ lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpw7yfw55f.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i <= p {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkx_cil2f.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for i in\
    \ lst {\n        match last {\n            None => last = Some(i),\n         \
    \   Some(j) => {\n                if i < j {\n                    return false;\n\
    \                }\n                last = Some(i);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpugcbmyix.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmphyrhl41w.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr_p5o7pu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(j) = last {\n        \
    \    if i <= j {\n                sorted = false;\n                break;\n  \
    \          }\n        }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplc8lj9v3.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: Implement me!\n    false\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvyb1msql.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(x) => {\n                if i\
    \ <= x {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9is5sw1a.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp66zudzyy.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            return false;\n        }\n    \
    \    last = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpx2dlerxq.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpev7lh7tb.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqt2ro_wq.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        if let Some(p) = prev {\n        \
    \    if i < p {\n                sorted = false;\n                break;\n   \
    \         }\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl8zwjqap.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for n in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if n < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpex1hjg5g.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(x)\
    \ => {\n                if x >= i {\n                    sorted = false;\n   \
    \                 break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa_f6xcx6.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = 0;\n    for i in lst {\n        if i < prev {\n            sorted = false;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjt2urehd.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          sorted = false;\n            break;\n        }\n        prev = lst[i];\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpzhk4s01t.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpjfi5um70.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if p\
    \ >= i {\n                    return false;\n                }\n            }\n\
    \            None => {}\n        }\n        prev = Some(i);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpynyxpgmd.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for n in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= n {\n          \
    \      return false;\n            }\n        }\n        prev = Some(n);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp53oravef.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for x in\
    \ lst {\n        if let Some(y) = last {\n            if x <= y {\n          \
    \      return false;\n            }\n        }\n        last = Some(x);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpop7t9ou3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(p)\
    \ => {\n                if i < p {\n                    sorted = false;\n    \
    \                break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbcmcrf4q.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmph3bsefij.rs:23:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= i {\n          \
    \      return false;\n            }\n        }\n        prev = Some(i);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqawjwvlc.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
