name: HumanEval_77_iscube
language: rs
results:
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg9pjcuxx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd_dl8evx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwpplweb9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplj45v68f.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcmf31j58.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8a_6i6kr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdrmrz562.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i*i*i <= a {\n        if i*i*i\
    \ == a {\n            return true;\n        }\n        i += 1;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6y59fyub.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7cb3i564.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp274gjmqq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmaw33hfa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    let mut cube = i * i * i;\n    while\
    \ cube < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvd003q2e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxk5pnctp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu707qumi.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpritwekk8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == -1 || (a > 0 && (a as f64).powf(1.0/3.0).floor()\
    \ == (a as f64).powf(1.0/3.0))\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpee5xfalh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvpygp772.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl65w3vqy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnisr8wt2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpon0voe4q.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp66zq3z90.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx5fa0q8h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfzanob0g.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6a7cexu1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ b = a.abs();\n    while b % 3 == 0 {\n        b /= 3;\n    }\n    b == 1\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7ry4269k.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i <= a.abs() {\n        if i * i * i == a.abs() {\n\
    \            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i <= a.abs() {\n        if i * i * i == a.abs() {\n\
    \            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4y12741m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1hq_hvd0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsbtzj61d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpb9jgal.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvs3iz37u.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp201epv36.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphummnz37.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd7uc9s_s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i*i*i <= a {\n        if i*i*i\
    \ == a {\n            return true;\n        }\n        i += 1;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxkjl7tki.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcneh_ckj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4mpe8fp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6fg95cyb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp44ozi3il.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    while i * i * i <= a {\n        if i * i * i == a {\n          \
    \  return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgc8zzxlj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphmz1e25q.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp87ni8nkb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpagv7m6hm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return iscube(-a);\n    }\n    if\
    \ a == 0 {\n        return true;\n    }\n    let mut i = 1;\n    while i * i *\
    \ i <= a {\n        if i * i * i == a {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpugg3m958.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i*i*i < a {\n        i += 1;\n\
    \    }\n    i*i*i == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1yzetpq7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_k_kjkzp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp39edvp7a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    while i * i * i <= a {\n        if i * i * i == a {\n          \
    \  return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp44rzq1pe.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpezqsmhne.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjo9poobl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwdj_ktju.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1m4mi3q_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let b = (a as f64).cbrt() as isize;\n    b * b * b ==\
    \ a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeiq6hrl5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaesj06iv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb96o885b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjrptt00n.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbxeobkfo.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_xuxx5vo.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return iscube(-a);\n    }\n    let\
    \ mut i = 0;\n    while i * i * i <= a {\n        if i * i * i == a {\n      \
    \      return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    if i * i * i == a {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjwa1shu2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxuywegy9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpklxrj1ff.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0f5hmufj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyo5wj2fy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfrorg6rt.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq_3c7ydb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw5c1yp9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i*i*i < a {\n        i += 1;\n\
    \    }\n    i*i*i == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9pm9jv_y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc63izs4y.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps_xlitf4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl58qhc2h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptvxpb2h4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6t99mfyc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return iscube(-a);\n    }\n    let\
    \ mut i = 0;\n    while i * i * i <= a {\n        if i * i * i == a {\n      \
    \      return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4dq9ma8s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkd5jtq05.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi2b0y7ka.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpynxjmox4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwfyxetf5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3m5ledtc.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpshausqin.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjq711g0b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprvz67eyi.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8b8siv9b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdi3v2z5t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj7wm_bz0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i <= a.abs() {\n        if i * i * i == a.abs() {\n\
    \            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i*i*i < a {\n        i += 1;\n\
    \    }\n    i*i*i == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9j6raild.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp18l37sjl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl3gwinsa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphuayfnjq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd38w0o5s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0o_rpepq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpszfoiia_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb8rcyf4z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzxm00nxk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyewospqq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    if i *\
    \ i * i == a.abs() {\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_bip6iys.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplem7xlfu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv5z8muno.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl52qr5mm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpys8r22ry.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut result = false;\n    while\
    \ i * i * i <= a {\n        if i * i * i == a {\n            result = true;\n\
    \            break;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw_ruzo_f.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_7zo0sft.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbx_mlm55.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcskkl_ct.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp76gd_6v_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp90c5pjy7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    let mut cube = 0;\n    while cube\
    \ < a {\n        i += 1;\n        cube = i * i * i;\n    }\n    cube == a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp48tfdlni.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i*i*i < a {\n        i += 1;\n\
    \    }\n    i*i*i == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3oe1urcx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqw3lcox3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaq50x75u.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiqctx6ga.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvse88avf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf2xhf6g7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu1tfl4em.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy2dogdy4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd5eaq6zm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpltzf2wih.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw68tiky4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg0e_baa7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzdbv9dj5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxry4vw4c.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6jecd6mp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbztw2m0w.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph_ch2o8b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1n9kydf4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppql5cyt1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk7_z2c1b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4wnshjo.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9miek_m6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i*i*i < a.abs() {\n        i += 1;\n    }\n    if i*i*i ==\
    \ a.abs() {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplh1q7ad_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkpwjcov0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_snb7rbn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnhg5ow3i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgsdob3bq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx4bcyqxe.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsdpk0xc2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnlx7hj8n.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy1exa5ia.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdym6wk61.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf46uwt_1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp22zieyt.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2789d9zl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy3mlq685.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgwzupvr9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpabllpcb8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpszh_bsn4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let b = a.abs();\n    let c = (b as f64).cbrt();\n   \
    \ c.fract() == 0.0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i <= a.abs() {\n        if i * i * i == a.abs() {\n\
    \            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsoptgybb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvwjttk1g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_5f0c37f.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    while i * i * i < a.abs() {\n        i += 1;\n    }\n    i * i *\
    \ i == a.abs()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprxwsswz6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9sbz26e4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9_c47ohs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv_1ckaqw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i*i*i < a {\n        i += 1;\n\
    \    }\n    i*i*i == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzzs5dydf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb50ydr41.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphcp4mmr_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjy0agtjp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_my63p1e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphopdtqyt.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwg5xognw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpher9yub7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4m0bbwdb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprcbzwk6z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return iscube(-a);\n    }\n    let\
    \ mut i = 0;\n    while i * i * i <= a {\n        if i * i * i == a {\n      \
    \      return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph4n2f8qm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps61c9hek.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7vf_thod.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaovdloce.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv09d1rwf.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf2_125fb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2zl34ik.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr4q18f68.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqyxdf7vp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpypytlkym.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpa24xqi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    if i * i * i == a {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph_waaciq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplxquhc_g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg85ccd_y.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 0;\n    while i * i * i <= a {\n        if\
    \ i * i * i == a {\n            return true;\n        }\n        i += 1;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgl7z2b0l.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i * i * i < a {\n        i +=\
    \ 1;\n    }\n    i * i * i == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps24at354.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
