language: rs
name: HumanEval_87_get_row
results:
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, e) in row.iter().enumerate() {\n            if *e == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp2vq47wx1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &val) in row.iter().enumerate() {\n            if val ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &col) in row.iter().enumerate() {\n            if col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &col) in row.iter().enumerate() {\n            if col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        let (a_row, a_col) = *a;\n\
    \        let (b_row, b_col) = *b;\n        if a_row == b_row {\n            b_col.cmp(&a_col)\n\
    \        } else {\n            a_row.cmp(&b_row)\n        }\n    });\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, val) in row.iter().enumerate() {\n            if *val ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpgl4avtb0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, cell) in row.iter().enumerate() {\n            if *cell ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x, &val) in row.iter().enumerate() {\n            if val ==\
    \ x {\n                res.push((y as isize, x as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu7pganc9.rs:20:23\n   |\n\
    20 |             if val == x {\n   |                       ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |             if val == x.try_into().unwrap()\
    \ {\n   |                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749599
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (row, row_vec) in lst.iter().enumerate()\
    \ {\n        for (col, elem) in row_vec.iter().enumerate() {\n            if *elem\
    \ == x {\n                result.push((row as isize, col as isize));\n       \
    \     }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 < b.0 {\n          \
    \  Ordering::Less\n        } else if a.0 > b.0 {\n            Ordering::Greater\n\
    \        } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpobirfk1u.rs:27:13\n   |\n27 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpobirfk1u.rs:29:13\n\
    \   |\n29 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659749599
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpcsy18l9t.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &col) in row.iter().enumerate() {\n            if col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 < b.0 {\n     \
    \       Ordering::Less\n        } else if a.0 > b.0 {\n            Ordering::Greater\n\
    \        } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpaivu8lko.rs:27:13\n   |\n27 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpaivu8lko.rs:29:13\n\
    \   |\n29 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659749599
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (row, row_vec) in lst.iter().enumerate()\
    \ {\n        for (col, val) in row_vec.iter().enumerate() {\n            if *val\
    \ == x {\n                result.push((row as isize, col as isize));\n       \
    \     }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|&(i1, j1), &(i2, j2)| {\n        if i1 < i2\
    \ {\n            std::cmp::Ordering::Less\n        } else if i1 > i2 {\n     \
    \       std::cmp::Ordering::Greater\n        } else {\n            j2.cmp(&j1)\n\
    \        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (row, row_vec) in lst.iter().enumerate()\
    \ {\n        for (col, item) in row_vec.iter().enumerate() {\n            if *item\
    \ == x {\n                result.push((row as isize, col as isize));\n       \
    \     }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 != b.0 {\n         \
    \   a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 != b.0 {\n    \
    \        a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &item) in row.iter().enumerate() {\n            if item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &col) in row.iter().enumerate() {\n            if col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 != b.0 {\n    \
    \        a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749600
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &elem) in row.iter().enumerate() {\n            if elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
