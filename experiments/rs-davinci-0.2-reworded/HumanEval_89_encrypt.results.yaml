name: HumanEval_89_encrypt
language: rs
results:
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpkhr1_mxw.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpgulztv6t.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_int = c as u8;\n        let c_int_encrypted = c_int + (2 *\
    \ 2);\n        let c_encrypted = c_int_encrypted as char;\n        result.push(c_encrypted);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5ouuombs.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ if new_char > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        encrypted.push(new_char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp47kerbqk.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 'z'\
    \ as u8 {\n            c = c - 26;\n        }\n        result.push(c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpwmqrrhz8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        if c >= 97 && c <= 122 {\n            let\
    \ c = c + 4;\n            if c > 122 {\n                let c = c - 26;\n    \
    \            result.push(c as char);\n            } else {\n                result.push(c\
    \ as char);\n            }\n        } else {\n            result.push(c as char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_int = c as u8;\n        c_int += 2 * 2;\n        encrypted.push(c_int\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpm7lruhoy.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpfp6_9pc_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpyh9ip4tw.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| {\n        let c = c as u8;\n   \
    \     if c >= 97 && c <= 122 {\n            let c = c + 2 * 2;\n            if\
    \ c > 122 {\n                (c - 26) as char\n            } else {\n        \
    \        c as char\n            }\n        } else {\n            c as char\n \
    \       }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = if c >= 97 && c <= 122 {\n    \
    \        (c + 2 * 2) % 122\n        } else if c >= 65 && c <= 90 {\n         \
    \   (c + 2 * 2) % 90\n        } else {\n            c\n        };\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei\\u{1}je\\u{1}ijei\\u{1}k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpt9y1e3yi.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp6zp1o3se.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmplcq84_2f.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = (c - 97 + 2 * 2) % 26 + 97;\n \
    \       result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp3w_ql08m.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num -= 97;\n        c_num = (c_num\
    \ + 2) % 26;\n        c_num += 97;\n        result.push(c_num as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_6rx_h35.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x = x + 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp6mpy9s6i.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::from(\"\");\n  \
    \  for c in s.chars() {\n        let mut encrypted_char = c as u8 + 2 * 2;\n \
    \       if encrypted_char > 122 {\n            encrypted_char = (encrypted_char\
    \ - 122) + 96;\n        }\n        encrypted_string.push(encrypted_char as char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5he_uqka.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmptiaehoob.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpyj_tpvz5.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8 + 4;\n        if\
    \ encrypted_char > 122 {\n            encrypted_char = encrypted_char - 26;\n\
    \        }\n        encrypted_string.push(encrypted_char as char);\n    }\n  \
    \  encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmped4hvs2i.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.to_ascii_lowercase());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmps2n6ek61.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        encrypted.push(c as char);\n    }\n\
    \    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 'z' as\
    \ u8 {\n            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        new_string.push(new_char as char);\n    }\n    new_string\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpff1li1rs.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = (c + 2 * 2) as char;\n        result.push(c);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpu54zp0cw.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpngtrirfz.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7cgdof2n.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp4jovpwm4.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpy28y7do8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ result.push(new_char as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpfoqjua7z.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(shift_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n  --> /tmp/tmp927za0zi.rs:17:21\n\
    \   |\n17 |         result.push(shift_char(c, 2 * 2));\n   |                 \
    \    ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        encrypted.push(c\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpw99qsi76.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpcvrndqdn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpti4wrttb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp7mlow6d9.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp6vv5fooj.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpuodpnl77.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpu8f14h0v.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8 - 97;\n        i = (i + 2) % 26;\n        result.push((i\
    \ + 97) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp1y_q_63q.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp49nu26o1.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut encrypted_char = c as u8 + 2 * 2;\n        if encrypted_char\
    \ > 122 {\n            encrypted_char = encrypted_char - 26;\n        }\n    \
    \    encrypted.push(encrypted_char as char);\n    }\n    encrypted\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x += 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpi2lz4ga9.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpdyxkygbf.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpda9did6j.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpobqv7xv1.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        let c = c as\
    \ char;\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpep_0n3ki.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ for c in s.iter_mut() {\n        *c = match *c {\n            'a' => 'c',\n\
    \            'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n \
    \           'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n  \
    \          'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n   \
    \         'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n    \
    \        'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n     \
    \       'q' => 's',\n            'r' => 't',\n            's' => 'u',\n      \
    \      't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n       \
    \     'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n        \
    \    'z' => 'b',\n            _ => *c,\n        };\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp5e7hpv1q.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9aiuh5oc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i = i + 2 * 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpf2te9dy7.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        res.push(c as\
    \ char);\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp0ogncom_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpxq5c8izd.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8 + 2 * 2;\n        if new_c > 'z' as u8 {\n\
    \            new_c = new_c - 26;\n        }\n        result.push(new_c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8 + 2 * 2;\n        if new_c > 'z' as u8 {\n\
    \            new_c = new_c - 26;\n        }\n        result.push(new_c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = if c >= 97 && c <= 122 {\n    \
    \        (c + 2 * 2) % 122\n        } else if c >= 65 && c <= 90 {\n         \
    \   (c + 2 * 2) % 90\n        } else {\n            c\n        };\n        encrypted.push(c\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei\\u{1}je\\u{1}ijei\\u{1}k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjdjd7n3o.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpyjxm_n_8.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp506tm9uu.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpgax8jk8g.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp85pqu35y.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x = x + 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpr4s9p_o7.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let encrypted_num = c_num + 2 * 2;\n\
    \        let encrypted_char = encrypted_num as char;\n        encrypted.push(encrypted_char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjhu8dmrk.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut code = c as u8;\n        code += 2 * 2;\n        result.push(code\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpgl0hxtqj.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = (new_char - 122) + 96;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1yt0az5w.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpy2nx0ky0.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpe4hjwjl_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpw_n72z1y.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        encrypted.push(c as char);\n    }\n   \
    \ encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2 * 2;\n        if i > 122 {\n\
    \            i -= 26;\n        }\n        result.push(i as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpdljtyz8f.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = (new_char - 122) + 96;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        if c >= 97 && c <= 122 {\n            let\
    \ c = c + 2;\n            if c > 122 {\n                let c = c - 26;\n    \
    \            result.push(c as char);\n            } else {\n                result.push(c\
    \ as char);\n            }\n        } else {\n            result.push(c as char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp0n9wf1wn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp3jholo6y.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        c *= 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpkqb0n2dw.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpsyyhe03s.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2*2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpd1n_c5tz.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let n = c as u8;\n        let n = n + 2 * 2;\n        let c = n as\
    \ char;\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp9ka44usm.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpy0dx2hhi.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp44r_x3pt.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x += 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmplflrw4ot.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        res.push(rotate_char(c, 2 * 2));\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpbuyht9f5.rs:17:18\n\
    \   |\n17 |         res.push(rotate_char(c, 2 * 2));\n   |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpr1f_7j25.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        if encrypted_char\
    \ >= 97 && encrypted_char <= 122 {\n            if encrypted_char + 2 > 122 {\n\
    \                encrypted_char = (encrypted_char + 2) - 26;\n            } else\
    \ {\n                encrypted_char += 2;\n            }\n        }\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpwdem648p.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8 + 4;\n        if new_c > 122 {\n        \
    \    new_c = new_c - 26;\n        }\n        result.push(new_c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        encrypted.push(c\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp921mq3j7.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp71j2a4dn.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1n3diuoh.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp86q50vin.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpi2rgytww.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpj5bpi9sk.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5hovj_c4.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num = c_num + 2 * 2;\n      \
    \  if c_num > 122 {\n            c_num = c_num - 26;\n        }\n        result.push(c_num\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpeyywau9k.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8 + 2 * 2;\n      \
    \  if encrypted_char > 122 {\n            encrypted_char = (encrypted_char - 122)\
    \ + 96;\n        }\n        encrypted_string.push(encrypted_char as char);\n \
    \   }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpwqwatrp8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmphbidnb7w.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpx_boyac6.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2 * 2;\n        if i > 122 {\n\
    \            i -= 26;\n        }\n        result.push(i as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num += 2 * 2;\n        if c_num\
    \ > 122 {\n            c_num -= 26;\n        }\n        result.push(c_num as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp9whnjir6.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        encrypted.push(rotate_char(c, 2 * 2));\n    }\n    encrypted\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp5kyy164x.rs:17:24\n\
    \   |\n17 |         encrypted.push(rotate_char(c, 2 * 2));\n   |             \
    \           ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3aq3ww__.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp7vcslrix.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpr_so0ht2.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpoy0lecba.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        res.push(c as\
    \ char);\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmprhkzxqxe.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpe1t5o4nq.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmphvy0r4ah.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpi7eer486.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    for c in s.chars()\
    \ {\n        new_string.push(c.to_ascii_lowercase());\n    }\n    let mut new_string\
    \ = new_string.chars().map(|c| {\n        let mut new_char = c as u8;\n      \
    \  new_char += 2;\n        if new_char > 122 {\n            new_char -= 26;\n\
    \        }\n        new_char as char\n    }).collect::<String>();\n    new_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpe1ngahhu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            let mut new_char = c as u8 +\
    \ 2;\n            if new_char > 122 {\n                new_char = new_char - 26;\n\
    \            }\n            result.push(new_char as char);\n        } else {\n\
    \            result.push(c);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp06y8y7ug.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let encrypted_char = match c {\n            'a' =>\
    \ 'c',\n            'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n\
    \            'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n \
    \           'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n  \
    \          'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n   \
    \         'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n    \
    \        'q' => 's',\n            'r' => 't',\n            's' => 'u',\n     \
    \       't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n      \
    \      'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n       \
    \     'z' => 'b',\n            _ => c,\n        };\n        encrypted_string.push(encrypted_char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpsnlc3q07.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut new_char = c as u8;\n        new_char += 2\
    \ * 2;\n        encrypted_string.push(new_char as char);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp447vte44.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpkag6f2gm.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ if new_char > 122 {\n            new_char -= 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        encrypted_char\
    \ += 2 * 2;\n        encrypted_string.push(encrypted_char as char);\n    }\n \
    \   encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1mtqb95z.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjl45fdj5.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpk6yhtf34.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpc17sedeq.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut shifted = c as u8 + 2 * 2;\n        if shifted > 122 {\n\
    \            shifted -= 26;\n        }\n        encrypted.push(shifted as char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp3ke_640b.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char = new_char + (2 * 2);\n\
    \        result.push(new_char as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_hktgl_y.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 'z' as\
    \ u8 {\n            new_char = new_char - 'z' as u8 + 'a' as u8 - 1;\n       \
    \ }\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpt7fkspn2.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        encrypted_char\
    \ += 2 * 2;\n        encrypted_string.push(encrypted_char as char);\n    }\n \
    \   encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvp93sliz.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ for c in s.iter_mut() {\n        *c = match *c {\n            'a' => 'c',\n\
    \            'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n \
    \           'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n  \
    \          'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n   \
    \         'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n    \
    \        'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n     \
    \       'q' => 's',\n            'r' => 't',\n            's' => 'u',\n      \
    \      't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n       \
    \     'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n        \
    \    'z' => 'b',\n            _ => *c,\n        };\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplvicrd5a.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.wrapping_add(2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbuxdtwyi.rs:17:23\n   |\n17 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        c *= 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmphe9aq51v.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_c = ((c as u8) + 2 * 2) as char;\n        result.push(new_c);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp45w6hk9t.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for i in s.chars()\
    \ {\n        let mut x = i as u8;\n        x += 2 * 2;\n        if x > 122 {\n\
    \            x -= 26;\n        }\n        result.push(x as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate(c, 2));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpan5w5ork.rs:17:21\n\
    \   |\n17 |         result.push(rotate(c, 2));\n   |                     ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x += 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1_j9jpzr.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2;\n        i *= 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpej6hyucz.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        encrypted_char\
    \ += 2;\n        encrypted_char *= 2;\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpemwi5j91.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpmozrobm2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        encrypted.push(c as char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_hhddhz1.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_nvsomt3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2;\n        i *= 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpvkhtvs5_.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptd47z52q.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        c *= 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpfac52zw2.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpdrk_d2f0.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_shifted = c_num + 2 * 2;\n\
    \        let c_shifted = c_num_shifted as char;\n        result.push(c_shifted);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpsu0y73b8.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpx5zj8myg.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmphpja6hti.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        if c >= 97 && c <= 122 {\n            let\
    \ c = c + 2;\n            if c > 122 {\n                let c = c - 26;\n    \
    \            result.push(c as char);\n            } else {\n                result.push(c\
    \ as char);\n            }\n        } else {\n            result.push(c as char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpoenpoz2l.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
