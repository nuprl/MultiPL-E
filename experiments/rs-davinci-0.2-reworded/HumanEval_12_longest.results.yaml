name: HumanEval_12_longest
language: rs
results:
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => {\n  \
    \              if s.len() > l.len() {\n                    longest = Some(s);\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    for string in strings {\n       \
    \ match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpb945u9gp.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n    \
    \        None => Some(s),\n            Some(acc_s) => {\n                if acc_s.len()\
    \ < s.len() {\n                    Some(s)\n                } else {\n       \
    \             Some(acc_s)\n                }\n            }\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpniq1fequ.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_len_str = Some(s);\n        }\n    }\n    max_len_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpqychgdbg.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_len_str = Some(s);\n        }\n    }\n    max_len_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp9aygpgv2.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n    \
    \        None => Some(s),\n            Some(acc_s) => if acc_s.len() < s.len()\
    \ { Some(s) } else { Some(acc_s) },\n        }\n    })\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            max_string = Some(string);\n        }\n    }\n\
    \    max_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = None;\n    for s in strings {\n        if let Some(ref\
    \ max_s) = max {\n            if s.len() > max_s.len() {\n                max\
    \ = Some(s);\n            }\n        } else {\n            max = Some(s);\n  \
    \      }\n    }\n    max\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpbrk_ahtr.rs:12:16\n\
    \   |\n10 |     let mut max = None;\n   |         ------- consider giving `max`\
    \ the explicit type `Option<T>`, where the type parameter `T` is specified\n11\
    \ |     for s in strings {\n12 |         if let Some(ref max_s) = max {\n   |\
    \                ^^^^^^^^^^^^^^^ cannot infer type for type parameter `T` declared\
    \ on the enum `Option`\n   |\n   = note: type must be known at this point\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut max_index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_index = i;\n        }\n    }\n    Some(strings[max_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        longest\
    \ = match longest {\n            None => Some(string),\n            Some(ref mut\
    \ l) => {\n                if l.len() < string.len() {\n                    *l\
    \ = string;\n                }\n                Some(l.clone())\n            }\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmppo7vvgh_.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_length {\n            max_length = s.len();\n\
    \            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpuz58fpgk.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut max_str = &strings[0];\n    for string in strings {\n    \
    \    if string.len() > max_len {\n            max_len = string.len();\n      \
    \      max_str = &string;\n        }\n    }\n    Some(max_str.to_string())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `strings` because it is borrowed\n  -->\
    \ /tmp/tmpbucojzpc.rs:15:19\n   |\n14 |     let mut max_str = &strings[0];\n \
    \  |                        ------- borrow of `strings` occurs here\n15 |    \
    \ for string in strings {\n   |                   ^^^^^^^ move out of `strings`\
    \ occurs here\n...\n21 |     Some(max_str.to_string())\n   |          -------------------\
    \ borrow later used here\n\nerror[E0597]: `string` does not live long enough\n\
    \  --> /tmp/tmpbucojzpc.rs:18:23\n   |\n18 |             max_str = &string;\n\
    \   |                       ^^^^^^^ borrowed value does not live long enough\n\
    19 |         }\n20 |     }\n   |     - `string` dropped here while still borrowed\n\
    21 |     Some(max_str.to_string())\n   |          ------------------- borrow later\
    \ used here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0505, E0597.\nFor more information about an error, try `rustc\
    \ --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut longest_string)\
    \ => {\n                if string.len() > longest_string.len() {\n           \
    \         *longest_string = string;\n                }\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    for string in strings {\n       \
    \ match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpr4rwn6wd.rs:12:41\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < s.len() {\n   |                                         ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for s in strings {\n        match result\
    \ {\n            None => result = Some(s),\n            Some(r) => {\n       \
    \         if s.len() > r.len() {\n                    result = Some(s);\n    \
    \            }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmplgxa1vo1.rs:14:18\n   |\n\
    14 |             Some(r) => {\n   |                  ^ value moved here, in previous\
    \ iteration of loop\n   |\nnote: these 2 reinitializations might get skipped\n\
    \  --> /tmp/tmplgxa1vo1.rs:13:21\n   |\n13 |             None => result = Some(s),\n\
    \   |                     ^^^^^^\n...\n16 |                     result = Some(s);\n\
    \   |                     ^^^^^^\n   = note: move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    let mut longest_length = 0;\n   \
    \ for string in strings {\n        if string.len() > longest_length {\n      \
    \      longest_length = string.len();\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    for string in strings {\n       \
    \ match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_length {\n            max_length = s.len();\n\
    \            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_length {\n            max_length = s.len();\n\
    \            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpu4nh2lkx.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    for string in strings {\n       \
    \ match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut s) => {\n                if s.len() < string.len() {\n\
    \                    *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => {\n  \
    \              if s.len() > l.len() {\n                    longest = Some(s);\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpyw8zn8cx.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || string.len() > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpi7zlzso9.rs:12:56\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n   |                                  \
    \                      ^^^^^^ cannot infer type for type parameter `T`\n   |\n\
    \   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            max_string = Some(string);\n        }\n    }\n\
    \    max_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut longest_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpoun1wnkn.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_length {\n            max_length = s.len();\n\
    \            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = 0;\n    let mut longest_string = None;\n    for\
    \ string in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            longest_string = Some(string);\n        }\n   \
    \ }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = None;\n    for s in strings {\n        match result\
    \ {\n            None => result = Some(s),\n            Some(r) => {\n       \
    \         if s.len() > r.len() {\n                    result = Some(s);\n    \
    \            }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpavu0lj3t.rs:14:18\n   |\n\
    14 |             Some(r) => {\n   |                  ^ value moved here, in previous\
    \ iteration of loop\n   |\nnote: these 2 reinitializations might get skipped\n\
    \  --> /tmp/tmpavu0lj3t.rs:13:21\n   |\n13 |             None => result = Some(s),\n\
    \   |                     ^^^^^^\n...\n16 |                     result = Some(s);\n\
    \   |                     ^^^^^^\n   = note: move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = Some(string);\n        }\n    }\n    max_string\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || s.len() > longest.as_ref().unwrap().len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmps4b7t0ty.rs:12:51\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if longest.is_none() || s.len() > longest.as_ref().unwrap().len()\
    \ {\n   |                                                   ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp_p5dyftq.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut l)\
    \ => {\n                if l.len() < string.len() {\n                    *l =\
    \ string;\n                }\n            }\n        }\n    }\n    longest\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    let mut max_len_string = None;\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_string = Some(s);\n        }\n    }\n    max_len_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref mut l) => {\n\
    \                if s.len() > l.len() {\n                    *l = s;\n       \
    \         }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
