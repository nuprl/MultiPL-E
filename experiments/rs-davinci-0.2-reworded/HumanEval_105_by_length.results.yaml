name: HumanEval_105_by_length
language: rs
results:
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted_arr\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    let mut\
    \ result = Vec::new();\n    for i in sorted_arr {\n        match i {\n       \
    \     1 => result.push(String::from(\"One\")),\n            2 => result.push(String::from(\"\
    Two\")),\n            3 => result.push(String::from(\"Three\")),\n           \
    \ 4 => result.push(String::from(\"Four\")),\n            5 => result.push(String::from(\"\
    Five\")),\n            6 => result.push(String::from(\"Six\")),\n            7\
    \ => result.push(String::from(\"Seven\")),\n            8 => result.push(String::from(\"\
    Eight\")),\n            9 => result.push(String::from(\"Nine\")),\n          \
    \  _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => unreachable!(),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ })\n    .map(|x| x.to_string())\n    .collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|&x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"Unexpected number\"\
    ),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n    res.sort();\n\
    \    res.reverse();\n    res.iter().map(|x| match x.as_str() {\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    result.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    })\n    .map(|x| String::from(x))\n    .collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.parse::<isize>().unwrap()\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ > 0 && **x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n\
    \        match i {\n            1 => result.push(String::from(\"One\")),\n   \
    \         2 => result.push(String::from(\"Two\")),\n            3 => result.push(String::from(\"\
    Three\")),\n            4 => result.push(String::from(\"Four\")),\n          \
    \  5 => result.push(String::from(\"Five\")),\n            6 => result.push(String::from(\"\
    Six\")),\n            7 => result.push(String::from(\"Seven\")),\n           \
    \ 8 => result.push(String::from(\"Eight\")),\n            9 => result.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<_>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    })\n    .map(|x|\
    \ String::from(x))\n    .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result.sort();\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp9z15f77k.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_ref()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ > 0 && **x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n\
    \        result.push(match i {\n            1 => \"One\",\n            2 => \"\
    Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n            5\
    \ => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n     \
    \       8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n\
    \        }.to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i > 0 && i < 10 {\n            match i {\n          \
    \      1 => result.push(String::from(\"One\")),\n                2 => result.push(String::from(\"\
    Two\")),\n                3 => result.push(String::from(\"Three\")),\n       \
    \         4 => result.push(String::from(\"Four\")),\n                5 => result.push(String::from(\"\
    Five\")),\n                6 => result.push(String::from(\"Six\")),\n        \
    \        7 => result.push(String::from(\"Seven\")),\n                8 => result.push(String::from(\"\
    Eight\")),\n                9 => result.push(String::from(\"Nine\")),\n      \
    \          _ => (),\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted =\
    \ arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in sorted {\n        if i > 0 && i < 10 {\n       \
    \     match i {\n                1 => result.push(String::from(\"One\")),\n  \
    \              2 => result.push(String::from(\"Two\")),\n                3 =>\
    \ result.push(String::from(\"Three\")),\n                4 => result.push(String::from(\"\
    Four\")),\n                5 => result.push(String::from(\"Five\")),\n       \
    \         6 => result.push(String::from(\"Six\")),\n                7 => result.push(String::from(\"\
    Seven\")),\n                8 => result.push(String::from(\"Eight\")),\n     \
    \           9 => result.push(String::from(\"Nine\")),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|x|\
    \ *x > 0 && *x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ >= 1 && **x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n \
    \           2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|x|\
    \ *x >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr\n        .into_iter()\n        .filter(|x| *x > 0 && *x < 10)\n      \
    \  .collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n   \
    \     .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        })\n        .map(|x| String::from(x))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n\
    \        result.push(match i {\n            1 => \"One\",\n            2 => \"\
    Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n            5\
    \ => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n     \
    \       8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n\
    \        }.to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_ref()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr\n        .into_iter()\n        .filter(|x| x > &0 && x < &10)\n        .collect::<Vec<isize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.into_iter()\n        .map(|x|\
    \ match x {\n            1 => \"One\",\n            2 => \"Two\",\n          \
    \  3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n \
    \           6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => \"\",\n        })\n        .map(|x|\
    \ String::from(x))\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ })\n    .map(|x| x.to_string())\n    .collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ >= 1 && **x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n \
    \           2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| x > &0 && x < &10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| *x >=\
    \ &1 && *x <= &9)\n        .map(|x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result.sort();\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpar9wq95g.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.iter().filter(|&x|\
    \ x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n    res.sort();\n\
    \    res.reverse();\n    res.iter().map(|x| match x.as_str() {\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|x|\
    \ x > &0 && x < &10)\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ > 0 && **x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.iter().filter(|&x| x > &0 && x < &10).cloned().collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.iter().map(|x| match x {\n        1 => \"One\",\n\
    \        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n    \
    \    5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n        8\
    \ => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i > 0 && i < 10 {\n            match i {\n          \
    \      1 => result.push(String::from(\"One\")),\n                2 => result.push(String::from(\"\
    Two\")),\n                3 => result.push(String::from(\"Three\")),\n       \
    \         4 => result.push(String::from(\"Four\")),\n                5 => result.push(String::from(\"\
    Five\")),\n                6 => result.push(String::from(\"Six\")),\n        \
    \        7 => result.push(String::from(\"Seven\")),\n                8 => result.push(String::from(\"\
    Eight\")),\n                9 => result.push(String::from(\"Nine\")),\n      \
    \          _ => (),\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ > 0 && **x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| x > &0 && x < &10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| x >=\
    \ &&1 && x <= &&9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n\
    \        match i {\n            1 => result.push(String::from(\"One\")),\n   \
    \         2 => result.push(String::from(\"Two\")),\n            3 => result.push(String::from(\"\
    Three\")),\n            4 => result.push(String::from(\"Four\")),\n          \
    \  5 => result.push(String::from(\"Five\")),\n            6 => result.push(String::from(\"\
    Six\")),\n            7 => result.push(String::from(\"Seven\")),\n           \
    \ 8 => result.push(String::from(\"Eight\")),\n            9 => result.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result.sort();\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpbq8zfz_p.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|x|\
    \ *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    let mut res: Vec<String> = Vec::new();\n    for i in\
    \ arr {\n        match i {\n            1 => res.push(String::from(\"One\")),\n\
    \            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i == 1 {\n            result.push(String::from(\"One\"\
    ));\n        } else if i == 2 {\n            result.push(String::from(\"Two\"\
    ));\n        } else if i == 3 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if i == 4 {\n            result.push(String::from(\"Four\"\
    ));\n        } else if i == 5 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if i == 6 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if i == 7 {\n            result.push(String::from(\"Seven\"\
    ));\n        } else if i == 8 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if i == 9 {\n            result.push(String::from(\"Nine\"\
    ));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for i in arr {\n        if i > 0 && i < 10 {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    let mut result_str\
    \ = vec![];\n    for i in result {\n        match i {\n            1 => result_str.push(String::from(\"\
    One\")),\n            2 => result_str.push(String::from(\"Two\")),\n         \
    \   3 => result_str.push(String::from(\"Three\")),\n            4 => result_str.push(String::from(\"\
    Four\")),\n            5 => result_str.push(String::from(\"Five\")),\n       \
    \     6 => result_str.push(String::from(\"Six\")),\n            7 => result_str.push(String::from(\"\
    Seven\")),\n            8 => result_str.push(String::from(\"Eight\")),\n     \
    \       9 => result_str.push(String::from(\"Nine\")),\n            _ => (),\n\
    \        }\n    }\n    result_str\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    let mut result_string\
    \ = Vec::new();\n    for i in result {\n        result_string.push(match i {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        }.to_string());\n    }\n   \
    \ result_string\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >\
    \ &0 && x < &10)\n        .map(|x| match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| x > &0 && x < &10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_ref()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ > 0 && **x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| **x\
    \ >= 1 && **x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n \
    \           2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n  \
    \      match i {\n            1 => res.push(String::from(\"One\")),\n        \
    \    2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ >= 1 && *x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n  \
    \          2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"Unexpected value\"\
    ),\n    })\n    .map(|x| String::from(x))\n    .collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|x|\
    \ *x > 0 && *x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.iter().filter(|&x|\
    \ x >= &1 && x <= &9).map(|x| x.to_string()).collect::<Vec<String>>();\n    res.sort();\n\
    \    res.reverse();\n    res.iter().map(|x| match x.as_str() {\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr\n        .into_iter()\n        .filter(|x| *x >= 1 && *x <= 9)\n       \
    \ .map(|x| x.to_string())\n        .collect::<Vec<String>>();\n    result.sort();\n\
    \    result.reverse();\n    result.iter()\n        .map(|x| match x.as_str() {\n\
    \            \"1\" => \"One\",\n            \"2\" => \"Two\",\n            \"\
    3\" => \"Three\",\n            \"4\" => \"Four\",\n            \"5\" => \"Five\"\
    ,\n            \"6\" => \"Six\",\n            \"7\" => \"Seven\",\n          \
    \  \"8\" => \"Eight\",\n            \"9\" => \"Nine\",\n            _ => \"\"\
    ,\n        })\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr\n        .into_iter()\n        .filter(|x| x >= &1 && x <= &9)\n       \
    \ .collect::<Vec<isize>>();\n    result.sort();\n    result.reverse();\n    result.into_iter()\n\
    \        .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n        })\n\
    \        .map(|x| String::from(x))\n        .collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted =\
    \ arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in sorted {\n        if i >= 1 && i <= 9 {\n      \
    \      match i {\n                1 => result.push(String::from(\"One\")),\n \
    \               2 => result.push(String::from(\"Two\")),\n                3 =>\
    \ result.push(String::from(\"Three\")),\n                4 => result.push(String::from(\"\
    Four\")),\n                5 => result.push(String::from(\"Five\")),\n       \
    \         6 => result.push(String::from(\"Six\")),\n                7 => result.push(String::from(\"\
    Seven\")),\n                8 => result.push(String::from(\"Eight\")),\n     \
    \           9 => result.push(String::from(\"Nine\")),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<_>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    })\n    .map(|x|\
    \ String::from(x))\n    .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr\n        .into_iter()\n        .filter(|x| *x > 0 && *x < 10)\n      \
    \  .collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n   \
    \     .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n        })\n\
    \        .map(|x| String::from(x))\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|x| match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => unreachable!(),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted_arr\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    let mut\
    \ result: Vec<String> = Vec::new();\n    for i in sorted_arr {\n        if i >=\
    \ 1 && i <= 9 {\n            match i {\n                1 => result.push(String::from(\"\
    One\")),\n                2 => result.push(String::from(\"Two\")),\n         \
    \       3 => result.push(String::from(\"Three\")),\n                4 => result.push(String::from(\"\
    Four\")),\n                5 => result.push(String::from(\"Five\")),\n       \
    \         6 => result.push(String::from(\"Six\")),\n                7 => result.push(String::from(\"\
    Seven\")),\n                8 => result.push(String::from(\"Eight\")),\n     \
    \           9 => result.push(String::from(\"Nine\")),\n                _ => (),\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|&x|\
    \ x >= 1 && x <= 9)\n        .map(|x| match x {\n            1 => \"One\",\n \
    \           2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted =\
    \ arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    sorted.sort();\n    sorted.reverse();\n    sorted.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.iter().filter(|x|\
    \ *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n    res.sort();\n\
    \    res.reverse();\n    res.iter().map(|x| match x.as_str() {\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptcvgf5i2.rs:14:46\n   |\n\
    14 |     let mut res = arr.iter().filter(|x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \   |                                              ^\n   |                   \
    \                           |\n   |                                          \
    \    expected `&isize`, found integer\n   |                                  \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptcvgf5i2.rs:14:56\n   |\n14 |     let mut res = arr.iter().filter(|x|\
    \ *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n   |  \
    \                                                      ^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&isize`, found integer\n   |         \
    \                                               help: consider borrowing here:\
    \ `&10`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ })\n    .map(|x| x.to_string())\n    .collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >\
    \ &0 && x < &10)\n        .map(|&x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter()\n        .filter(|x|\
    \ *x > 0 && *x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i >= 1 && i <= 9 {\n            result.push(match i {\n\
    \                1 => \"One\",\n                2 => \"Two\",\n              \
    \  3 => \"Three\",\n                4 => \"Four\",\n                5 => \"Five\"\
    ,\n                6 => \"Six\",\n                7 => \"Seven\",\n          \
    \      8 => \"Eight\",\n                9 => \"Nine\",\n                _ => \"\
    \",\n            }.to_string());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >\
    \ &0 && x < &10)\n        .map(|&x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.iter().filter(|&x|\
    \ x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n    res.sort();\n\
    \    res.reverse();\n    res.iter().map(|x| match x.as_str() {\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    res.sort();\n    res.reverse();\n\
    \    res.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| *x >\
    \ &0 && *x < &10)\n        .map(|x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|&x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted_arr\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    let mut\
    \ result: Vec<String> = Vec::new();\n    for i in sorted_arr {\n        if i >\
    \ 0 && i < 10 {\n            result.push(match i {\n                1 => String::from(\"\
    One\"),\n                2 => String::from(\"Two\"),\n                3 => String::from(\"\
    Three\"),\n                4 => String::from(\"Four\"),\n                5 =>\
    \ String::from(\"Five\"),\n                6 => String::from(\"Six\"),\n     \
    \           7 => String::from(\"Seven\"),\n                8 => String::from(\"\
    Eight\"),\n                9 => String::from(\"Nine\"),\n                _ =>\
    \ String::from(\"\"),\n            });\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|x| match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => continue,\n  \
    \      }\n    }\n    result.sort();\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpoapnal27.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted =\
    \ arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in sorted {\n        if i > 0 && i < 10 {\n       \
    \     result.push(match i {\n                1 => \"One\",\n                2\
    \ => \"Two\",\n                3 => \"Three\",\n                4 => \"Four\"\
    ,\n                5 => \"Five\",\n                6 => \"Six\",\n           \
    \     7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => \"\",\n            }.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|&x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n    for i\
    \ in arr {\n        match i {\n            1 => res.push(String::from(\"One\"\
    )),\n            2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => continue,\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|x| *x >=\
    \ &1 && *x <= &9)\n        .map(|x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        if i > 0 && i < 10 {\n            match i {\n          \
    \      1 => result.push(String::from(\"One\")),\n                2 => result.push(String::from(\"\
    Two\")),\n                3 => result.push(String::from(\"Three\")),\n       \
    \         4 => result.push(String::from(\"Four\")),\n                5 => result.push(String::from(\"\
    Five\")),\n                6 => result.push(String::from(\"Six\")),\n        \
    \        7 => result.push(String::from(\"Seven\")),\n                8 => result.push(String::from(\"\
    Eight\")),\n                9 => result.push(String::from(\"Nine\")),\n      \
    \          _ => println!(\"Strange number\"),\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n  \
    \  result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| *x\
    \ > 0 && *x < 10)\n        .map(|x| match x {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter()\n        .filter(|&x| x >=\
    \ &1 && x <= &9)\n        .map(|x| match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| String::from(x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| x > &0 && x < &10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x.as_str()\
    \ {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"\
    Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\"\
    \ => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n    \
    \    \"9\" => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr: Vec<_>\
    \ = arr.into_iter().filter(|x| x >= &1 && x <= &9).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!(),\n   \
    \ })\n    .map(|x| x.to_string())\n    .collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<isize>>();\n   \
    \ result.sort();\n    result.reverse();\n    result.into_iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in arr {\n        match i {\n            1 => result.push(String::from(\"\
    One\")),\n            2 => result.push(String::from(\"Two\")),\n            3\
    \ => result.push(String::from(\"Three\")),\n            4 => result.push(String::from(\"\
    Four\")),\n            5 => result.push(String::from(\"Five\")),\n           \
    \ 6 => result.push(String::from(\"Six\")),\n            7 => result.push(String::from(\"\
    Seven\")),\n            8 => result.push(String::from(\"Eight\")),\n         \
    \   9 => result.push(String::from(\"Nine\")),\n            _ => (),\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
