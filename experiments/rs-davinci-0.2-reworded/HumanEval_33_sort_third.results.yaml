name: HumanEval_33_sort_third
language: rs
results:
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpclrblnqc.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.split_off(i);\n        sub_l.sort();\n        l.append(&mut sub_l);\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqjdd1d71.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpraz4v887.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpz8epfg7g.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmplpbw9mwj.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1abxlxoi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1abq_h3c.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j >= 3 && l_prime[j - 3] > l_prime[j] {\n\
    \            l_prime.swap(j - 3, j);\n            j -= 3;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 3, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp6szfuulo.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            l_prime[i] = l[i];\n            l_prime[i\
    \ + 1] = l[i + 1];\n            l_prime[i + 2] = l[i + 2];\n            l_prime[i..i\
    \ + 3].sort();\n        }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmptvfgqojm.rs:14:30\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (2..l.len()).step_by(3) {\n        let mut j =\
    \ i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1, j);\n\
    \            j -= 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmph40ni1ok.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpeerao4oe.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmplldr3edj.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i - 2;\n        while j >= 0 && l_prime[j] > l_prime[i] {\n\
    \            j -= 3;\n        }\n        j += 3;\n        let mut k = i;\n   \
    \     while k > j {\n            l_prime.swap(k, k - 1);\n            k -= 1;\n\
    \        }\n        i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpa9tommob.rs:14:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l_prime[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        l_prime[i..i + 3].copy_from_slice(&sub_vec);\n    }\n    l_prime\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            let mut j = i;\n            while j < l.len() {\n    \
    \            if j % 3 == 0 {\n                    if l[j] < l[i] {\n         \
    \               let temp = l[i];\n                        l[i] = l[j];\n     \
    \                   l[j] = temp;\n                    }\n                }\n \
    \               j += 1;\n            }\n        }\n        i += 1;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps6974udi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4875bbnw.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sub_l.sort();\n\
    \        l[i] = sub_l[0];\n        l[i + 1] = sub_l[1];\n        l[i + 2] = sub_l[2];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpzs2xpbm2.rs:14:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2ioq35w9.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmphmjl7ru7.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp63wqwaoi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2saw8on3.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqlrivs5g.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i - 2;\n        while j >= 0 && l_prime[j] > l_prime[i] {\n\
    \            j -= 3;\n        }\n        l_prime.insert(j + 3, l_prime.remove(i));\n\
    \        i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0499]: cannot borrow `l_prime` as mutable more than once at a time\n\
    \  --> /tmp/tmpfgq6tqng.rs:16:31\n   |\n16 |         l_prime.insert(j + 3, l_prime.remove(i));\n\
    \   |         ----------------------^^^^^^^^^^^^^^^^^-\n   |         |       |\
    \             |\n   |         |       |             second mutable borrow occurs\
    \ here\n   |         |       first borrow later used by call\n   |         first\
    \ mutable borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmpfgq6tqng.rs:16:31\n   |\n16 |         l_prime.insert(j + 3, l_prime.remove(i));\n\
    \   |                               ^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpfgq6tqng.rs:16:9\n  \
    \ |\n16 |         l_prime.insert(j + 3, l_prime.remove(i));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwrvxn37x.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut l_prime_iter = l_prime.iter_mut();\n\
    \    let mut l_iter = l.iter();\n    let mut l_iter_clone = l.iter();\n    let\
    \ mut l_iter_clone_clone = l.iter();\n    let mut l_iter_clone_clone_clone = l.iter();\n\
    \    let mut l_iter_clone_clone_clone_clone = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone = l.iter();\n\
    \    let mut l_iter_clone_clone_clone_clone_clone_clone_clone = l.iter();\n  \
    \  let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone = l.iter();\n\
    \    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone = l.iter();\n\
    \    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = l.iter();\n    let mut l_\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk4p2fl2c.rs:28:15\n   |\n\
    28 |     let mut l_\n   |               ^ help: add `;` here\n29 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk4p2fl2c.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 1] > l_prime[j] {\n\
    \            l_prime.swap(j - 1, j);\n            j -= 1;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpuk4a2uba.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut v = l.clone();\n    let mut i = 2;\n    while i < v.len() {\n     \
    \   let mut j = i - 2;\n        while j < i {\n            if v[j] > v[i] {\n\
    \                let temp = v[j];\n                v[j] = v[i];\n            \
    \    v[i] = temp;\n            }\n            j += 1;\n        }\n        i +=\
    \ 3;\n    }\n    v\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpq2mtuldg.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpd9nutb_z.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            let mut j = i;\n            while j < l.len() {\n    \
    \            if j % 3 == 0 {\n                    if l[j] < l[i] {\n         \
    \               let temp = l[i];\n                        l[i] = l[j];\n     \
    \                   l[j] = temp;\n                    }\n                }\n \
    \               j += 1;\n            }\n        }\n        i += 1;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpacfjd4o0.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut l_slice = l_prime.split_off(i);\n\
    \            l_slice.sort();\n            l_prime.append(&mut l_slice);\n    \
    \    }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp76axx790.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j] < l[j - 1] {\n            l.swap(j, j -\
    \ 1);\n            j -= 1;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpgj1dwd_w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            l[i..i + 3].sort();\n        }\n        i += 1;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpw_16nafg.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2w_91_of.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            l[i] = l[i + 1];\n            l[i + 1] = l[i + 2];\n \
    \           l[i + 2] = l[i];\n        }\n        i += 1;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpwk34unlx.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut sub_vec = l_prime.split_off(i);\n\
    \            sub_vec.sort();\n            l_prime.append(&mut sub_vec);\n    \
    \    }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpt2t49j4w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp5af73n5w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9o06z6gv.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l_prime[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        l_prime[i..i + 3].copy_from_slice(&sub_vec);\n    }\n    l_prime\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut l_slice\
    \ = l.split_off(i + 3);\n        let mut l_slice_2 = l.split_off(i);\n       \
    \ l_slice_2.sort();\n        l_slice_2.append(&mut l_slice);\n        l = l_slice_2;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at '`at` split index (is 9) should be <= len (is\
    \ 4)', library/alloc/src/vec/mod.rs:1960:13\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8r4pu4ci.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4e8qq4w1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            l[i..i + 3].sort();\n        }\n        i += 1;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut sub_vec = l[i..i + 3].to_vec();\n\
    \            sub_vec.sort();\n            l_prime[i] = sub_vec[0];\n         \
    \   l_prime[i + 1] = sub_vec[1];\n            l_prime[i + 2] = sub_vec[2];\n \
    \       }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut new_vec = l.clone();\n    let mut i = 2;\n    while i < new_vec.len()\
    \ {\n        let mut j = i;\n        while j > 0 && new_vec[j - 2] > new_vec[j]\
    \ {\n            new_vec.swap(j - 2, j);\n            j -= 2;\n        }\n   \
    \     i += 3;\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpn694l3xv.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut result = l.clone();\n    let mut i = 2;\n    while i < result.len()\
    \ {\n        let mut j = i;\n        while j > 0 && result[j - 2] > result[j]\
    \ {\n            result.swap(j - 2, j);\n            j -= 2;\n        }\n    \
    \    i += 3;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpmqr5qjrx.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (2..l.len()).step_by(3) {\n        l[i - 2..i\
    \ + 1].sort();\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpn9ohcs7p.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwte5w2v8.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 1] > l_prime[j] {\n\
    \            l_prime.swap(j - 1, j);\n            j -= 1;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4w1ppzqb.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut j = i;\n            while j < l.len()\
    \ {\n                if j % 3 == 0 {\n                    if l[j] < l[i] {\n \
    \                       l_prime[i] = l[j];\n                        l_prime[j]\
    \ = l[i];\n                    }\n                }\n                j += 1;\n\
    \            }\n        }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 6, 3, 2, 8, 9, 4]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2lxfvwxh.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sublist\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sublist.sort();\n\
    \        l.splice(i..i + 3, sublist.into_iter());\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmprkzshsj2.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut l_prime_sorted = l.clone();\n   \
    \ for i in (0..l.len()).step_by(3) {\n        l_prime_sorted[i] = l[i];\n    \
    \    l_prime_sorted[i + 1] = l[i + 1];\n        l_prime_sorted[i + 2] = l[i +\
    \ 2];\n        l_prime_sorted[i..i + 3].sort();\n        l_prime[i] = l_prime_sorted[i];\n\
    \        l_prime[i + 1] = l_prime_sorted[i + 1];\n        l_prime[i + 2] = l_prime_sorted[i\
    \ + 2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpbewo8ra4.rs:13:33\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.clone();\n        sub_l.sort();\n        l[i] = sub_l[0];\n        l[i +\
    \ 1] = sub_l[1];\n        l[i + 2] = sub_l[2];\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpm999oot8.rs:14:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sublist\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sublist.sort();\n\
    \        l.splice(i..i + 3, sublist.into_iter());\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..(i + 3)].to_vec();\n        sub_vec.sort();\n    \
    \    l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpso4uzxk0.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 1] > l_prime[j] {\n\
    \            let temp = l_prime[j];\n            l_prime[j] = l_prime[j - 1];\n\
    \            l_prime[j - 1] = temp;\n            j -= 1;\n        }\n        i\
    \ += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp50xcy7f2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (2..l.len()).step_by(3) {\n        let mut j =\
    \ i;\n        while j > 0 && l[j - 3] > l[j] {\n            l.swap(j - 3, j);\n\
    \            j -= 3;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpaqukw33g.rs:12:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    l_prime[i..i+3].sort();\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1s338uaa.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpta0pd3p0.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmptlzso_gv.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8x0lg4dx.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    l_prime[i..i+3].sort();\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (2..l.len()).step_by(3) {\n        l[i] = l[i\
    \ - 2];\n    }\n    l.sort();\n    for i in (2..l.len()).step_by(3) {\n      \
    \  l[i - 2] = l[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4, 4, 6, 5, 6, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpg7gxt5u0.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpnboxh2ql.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpjj56o6mi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpebt9xh_q.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp87rm79g5.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9u59slad.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwr70k02k.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpuvfnrbbq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpt6bc58rp.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (2..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i - 2..i + 1].to_vec();\n        sub_vec.sort();\n  \
    \      l_prime[i - 2..i + 1].clone_from_slice(&sub_vec);\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpumzzpsg6.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3mlce7u5.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sub_l.sort();\n\
    \        for j in 0..3 {\n            l[i + j] = sub_l[j];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmphpq3oknj.rs:14:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1,\
    \ j);\n            j -= 1;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4y59979o.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp00x58pr7.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpxpbk7yuo.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1,\
    \ j);\n            j -= 1;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpvyu7llyy.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpryvnapkf.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpvbsxw1b_.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9ki3oy_k.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        let mut j = i + 3;\n        while j < l.len() {\n            if l[i]\
    \ > l[j] {\n                l_prime[i] = l[j];\n                l_prime[j] = l[i];\n\
    \            }\n            j += 3;\n        }\n        i += 3;\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 6, 3, 2, 8, 9, 4]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpo6xpjz1h.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.split_off(i);\n        sub_l.sort();\n        l.append(&mut sub_l);\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpaq6jo1v3.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpps3jdbwm.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9co3xokc.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8mzsrn2v.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqss03_67.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpj1fl75ps.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpitk5sa2w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    l_prime[i..i+3].sort();\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            let mut j = i;\n            while j < l.len() {\n    \
    \            if j % 3 == 0 {\n                    if l[j] < l[i] {\n         \
    \               let temp = l[i];\n                        l[i] = l[j];\n     \
    \                   l[j] = temp;\n                    }\n                }\n \
    \               j += 1;\n            }\n        }\n        i += 1;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpf2gw9wis.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l_prime[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        l_prime[i..i + 3].copy_from_slice(&sub_vec);\n    }\n    l_prime\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (2..l.len()).step_by(3) {\n    \
    \    let mut slice = l_prime.split_off(i);\n        slice.sort();\n        l_prime.append(&mut\
    \ slice);\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 2, 3, 4, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyjh71hbc.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdlfg6_6v.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdnktksyt.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2odx3abr.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (2..l.len()).step_by(3) {\n        let mut j =\
    \ i;\n        while j > 0 && l[j - 3] > l[j] {\n            l.swap(j - 3, j);\n\
    \            j -= 3;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdkj__dl5.rs:12:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4s5e076t.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            l[i..i + 3].sort();\n        }\n        i += 1;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut new_l = l.clone();\n    for i in (2..new_l.len()).step_by(3) {\n  \
    \      new_l[i] = l[i];\n        new_l[i - 1] = l[i - 1];\n        new_l[i - 2]\
    \ = l[i - 2];\n        new_l[i - 2..i + 1].sort();\n    }\n    new_l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8n8gvciy.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpakqo6eac.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut new_l = l.clone();\n    let mut i = 0;\n    while i < new_l.len() {\n\
    \        if i % 3 == 0 {\n            let mut j = i;\n            while j < new_l.len()\
    \ {\n                if j % 3 == 0 {\n                    if new_l[i] > new_l[j]\
    \ {\n                        let temp = new_l[i];\n                        new_l[i]\
    \ = new_l[j];\n                        new_l[j] = temp;\n                    }\n\
    \                }\n                j += 1;\n            }\n        }\n      \
    \  i += 1;\n    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sorted\
    \ = l[i..i + 3].to_vec();\n        sorted.sort();\n        l[i..i + 3].copy_from_slice(&sorted);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j >= 3 && l_prime[j - 3] > l_prime[j] {\n\
    \            l_prime.swap(j - 3, j);\n            j -= 3;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 3, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7eu3po0g.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwwbrbsd2.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            let tmp = l[j];\n\
    \            l[j] = l[j - 1];\n            l[j - 1] = tmp;\n            j -= 1;\n\
    \        }\n        i += 3;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpk3vc1g99.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3kljgq5f.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1,\
    \ j);\n            j -= 1;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp_lgsjehl.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe720wig6.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            l_prime[i] = l[i];\n            l_prime[i\
    \ + 1] = l[i + 1];\n            l_prime[i + 2] = l[i + 2];\n            l_prime[i..i\
    \ + 3].sort();\n        }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpjcvdioij.rs:14:30\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps9p10men.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpts2qw4wt.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2ikf9jp1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpmsbuhfe5.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmppaqp9b52.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8fb_akeu.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1,\
    \ j);\n            j -= 1;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9wcq5_w5.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 1] > l_prime[j] {\n\
    \            l_prime.swap(j - 1, j);\n            j -= 1;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8etz57tw.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut j = i;\n            while j < i\
    \ + 3 {\n                let mut k = j + 1;\n                while k < i + 3 {\n\
    \                    if l_prime[j] > l_prime[k] {\n                        let\
    \ temp = l_prime[j];\n                        l_prime[j] = l_prime[k];\n     \
    \                   l_prime[k] = temp;\n                    }\n              \
    \      k += 1;\n                }\n                j += 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpvasbnf_q.rs:17:37\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpalx43mb8.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.clone();\n        sub_l.sort();\n        l[i] = sub_l[0];\n        l[i +\
    \ 1] = sub_l[1];\n        l[i + 2] = sub_l[2];\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmp7jo9a9rp.rs:14:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sub_l.sort();\n\
    \        l[i] = sub_l[0];\n        l[i + 1] = sub_l[1];\n        l[i + 2] = sub_l[2];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpq6u223ss.rs:14:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            let mut sub_vec = Vec::new();\n        \
    \    let mut j = i;\n            while j < i + 3 {\n                sub_vec.push(l[j]);\n\
    \                j += 1;\n            }\n            sub_vec.sort();\n       \
    \     let mut k = i;\n            while k < i + 3 {\n                l_prime[k]\
    \ = sub_vec[k - i];\n                k += 1;\n            }\n        }\n     \
    \   i += 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpu26jh4c2.rs:16:30\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            l[i] = l[i + 1];\n            l[i + 1] = l[i + 2];\n \
    \           l[i + 2] = l[i];\n        }\n        i += 1;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmp41mhvpjg.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcqgbumvd.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (2..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i - 2..i + 1].to_vec();\n        sub_vec.sort();\n  \
    \      l_prime[i - 2] = sub_vec[0];\n        l_prime[i - 1] = sub_vec[1];\n  \
    \      l_prime[i] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpz3gb9k6z.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp_wbll88v.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9h41fted.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpmddm40h5.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpq2ew5e68.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp132tglpl.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut new_vec = l.clone();\n    for i in (0..new_vec.len()).step_by(3) {\n\
    \        new_vec[i..i+3].sort();\n    }\n    new_vec\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    for i in (0..l.len()).step_by(3) {\n        l2[i..i+3].sort();\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpjqrei20m.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut result = l.clone();\n    for i in (0..result.len()).step_by(3) {\n\
    \        let mut sub_vec = result[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        result[i..i + 3].clone_from_slice(&sub_vec);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpx3w9pgsr.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdu9zyf_r.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_l\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sub_l.sort();\n\
    \        for j in 0..3 {\n            l[i + j] = sub_l[j];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpa4k2fngl.rs:14:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpznfseavg.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp_3f55uy1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpq0a90trg.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut slice = l_prime.get_mut(i..i + 3).unwrap();\n        slice.sort();\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp4rr370px.rs:11:51\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        if i %\
    \ 3 == 0 {\n            let mut j = i;\n            while j < l.len() {\n    \
    \            if j % 3 == 0 {\n                    if l[j] < l[i] {\n         \
    \               let temp = l[i];\n                        l[i] = l[j];\n     \
    \                   l[j] = temp;\n                    }\n                }\n \
    \               j += 1;\n            }\n        }\n        i += 1;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 0;\n    while i < l.len() {\n\
    \        if i % 3 == 0 {\n            l_prime[i] = l[i + 1];\n            l_prime[i\
    \ + 1] = l[i + 2];\n            l_prime[i + 2] = l[i];\n        }\n        i +=\
    \ 1;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpoyk6wxoa.rs:13:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqcfx59r0.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbk5u_zg9.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l_prime[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        l_prime[i..i + 3].copy_from_slice(&sub_vec);\n    }\n    l_prime\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut l_third = l.clone();\n    l_third.retain(|x|\
    \ l.iter().position(|&y| y == *x).unwrap() % 3 == 0);\n    l_third.sort();\n \
    \   for i in 0..l_prime.len() {\n        if i % 3 == 0 {\n            l_prime[i]\
    \ = l_third[i / 3];\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2sjo54xt.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpuxsr0gdi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpkgz89zgg.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3rtm06rd.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l[i..i + 3].to_vec();\n        sub_vec.sort();\n      \
    \  l_prime[i] = sub_vec[0];\n        l_prime[i + 1] = sub_vec[1];\n        l_prime[i\
    \ + 2] = sub_vec[2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwuxgihuu.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        l[i..i + 3].sort();\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            l_prime.swap(j - 2, j);\n            j -= 2;\n        }\n       \
    \ i += 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpvkzckq1u.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpl9ijb1ok.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    for i in (0..l.len()).step_by(3) {\n    \
    \    let mut sub_vec = l_prime[i..i + 3].to_vec();\n        sub_vec.sort();\n\
    \        l_prime[i..i + 3].copy_from_slice(&sub_vec);\n    }\n    l_prime\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.split_off(i);\n        sub_vec.sort();\n        l.append(&mut sub_vec);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpgmm5qepy.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut new_l = l.clone();\n    let mut i = 2;\n    while i < new_l.len() {\n\
    \        let mut j = i;\n        while j > 0 && new_l[j - 2] > new_l[j] {\n  \
    \          let temp = new_l[j];\n            new_l[j] = new_l[j - 2];\n      \
    \      new_l[j - 2] = temp;\n            j -= 2;\n        }\n        i += 3;\n\
    \    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwghey4md.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut i = 2;\n    while i < l.len() {\n\
    \        let mut j = i;\n        while j > 0 && l_prime[j - 2] > l_prime[j] {\n\
    \            let temp = l_prime[j - 2];\n            l_prime[j - 2] = l_prime[j];\n\
    \            l_prime[j] = temp;\n            j -= 2;\n        }\n        i +=\
    \ 3;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpw52o2fi0.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    for i in (0..l.len()).step_by(3) {\n        let mut sub_vec\
    \ = l.iter().skip(i).take(3).cloned().collect::<Vec<isize>>();\n        sub_vec.sort();\n\
    \        for j in 0..3 {\n            l[i + j] = sub_vec[j];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmphfxxhe1t.rs:14:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut i = 2;\n    while i < l.len() {\n        let mut\
    \ j = i;\n        while j > 0 && l[j - 2] > l[j] {\n            l.swap(j - 2,\
    \ j);\n            j -= 2;\n        }\n        i += 3;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 5, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdgi2yf76.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_prime = l.clone();\n    let mut l_prime_sorted = l.clone();\n   \
    \ for i in (0..l.len()).step_by(3) {\n        l_prime_sorted[i] = l[i];\n    \
    \    l_prime_sorted[i + 1] = l[i + 1];\n        l_prime_sorted[i + 2] = l[i +\
    \ 2];\n        l_prime_sorted[i..i + 3].sort();\n        l_prime[i] = l_prime_sorted[i];\n\
    \        l_prime[i + 1] = l_prime_sorted[i + 1];\n        l_prime[i + 2] = l_prime_sorted[i\
    \ + 2];\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmp5lh6bxod.rs:13:33\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l_new = l.clone();\n    for i in (0..l.len()).step_by(3) {\n      \
    \  let mut l_temp = l[i..i + 3].to_vec();\n        l_temp.sort();\n        l_new[i]\
    \ = l_temp[0];\n        l_new[i + 1] = l_temp[1];\n        l_new[i + 2] = l_temp[2];\n\
    \    }\n    l_new\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 9 out of range for slice of\
    \ length 7', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
