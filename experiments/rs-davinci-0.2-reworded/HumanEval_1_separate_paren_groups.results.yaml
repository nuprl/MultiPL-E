name: HumanEval_1_separate_paren_groups
language: rs
results:
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate the groups of parentheses in {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented: Separate the groups of parentheses\
    \ in (()()) ((())) () ((())()())', /tmp/tmpsip6u0nr.rs:8:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     result.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_group.push(c);\n            if open_paren_count == 0 {\n          \
    \      result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: Implement this function\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpijbc9ahy.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppk1ivw_d.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmphocb9kbz.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_string.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Unexpected character in input string\");\n        }\n       \
    \ if paren_count == 0 {\n            groups.push(current_group.clone());\n   \
    \         current_group.clear();\n        }\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut temp = String::new();\n    let\
    \ mut open_count = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            open_count += 1;\n            temp.push(c);\n        } else if\
    \ c == ')' {\n            open_count -= 1;\n            temp.push(c);\n      \
    \      if open_count == 0 {\n                result.push(temp);\n            \
    \    temp = String::new();\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     paren_groups.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_string.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            paren_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            paren_group.push(c);\n\
    \        }\n        if paren_count == 0 && paren_group.len() > 0 {\n         \
    \   paren_groups.push(paren_group);\n            paren_group = String::new();\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut current_depth: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_depth -= 1;\n                current_group.push(c);\n\
    \                if current_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmps61ay0md.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     result.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8qawsdf4.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     result.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut current_depth: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_depth -= 1;\n                current_group.push(c);\n\
    \                if current_depth == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_paren_count: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_group.push(c);\n            if open_paren_count == 0 {\n          \
    \      result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        }\n        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp1vgwfnru.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpspcx8zox.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_paren_count: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_group.push(c);\n            if open_paren_count == 0 {\n          \
    \      result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut group: String = String::new();\n\
    \    let mut open_parens: u32 = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_parens += 1;\n            group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(group);\n    \
    \            group = String::new();\n            }\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_group.push(c);\n            if open_paren_count == 0 {\n          \
    \      result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut stack = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n \
    \           if stack.is_empty() {\n                panic!(\"Unbalanced parentheses\"\
    );\n            }\n            stack.pop();\n            if stack.is_empty() {\n\
    \                result.push(current_group);\n                current_group =\
    \ String::new();\n            }\n        } else if c != ' ' {\n            current_group.push(c);\n\
    \        }\n    }\n    if !stack.is_empty() {\n        panic!(\"Unbalanced parentheses\"\
    );\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpbmn4kuas.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    let mut curr_str = String::new();\n    let\
    \ mut open_count = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            open_count += 1;\n            curr_str.push(c);\n        } else\
    \ if c == ')' {\n            open_count -= 1;\n            curr_str.push(c);\n\
    \            if open_count == 0 {\n                res.push(curr_str);\n     \
    \           curr_str = String::new();\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_group.push(c);\n            if open_paren_count == 0 {\n          \
    \      result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_string.push(c);\n            if open_paren_count == 0 {\n         \
    \       result.push(current_string);\n                current_string = String::new();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp39izfck3.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        }\n        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgtr3m9tq.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxqfqk_rk.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_group_open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_group_open_parens += 1;\n    \
    \        current_group.push(c);\n        } else if c == ')' {\n            current_group_open_parens\
    \ -= 1;\n            current_group.push(c);\n            if current_group_open_parens\
    \ == 0 {\n                result.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp28dpjvf4.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ current_string = String::new();\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            stack.push(c);\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            stack.pop();\n            current_string.push(c);\n\
    \            if stack.is_empty() {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        }\n        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpnx0flpek.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpoah5__x7.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut current_group_open: usize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_group_open += 1;\n           \
    \ current_group.push(c);\n        } else if c == ')' {\n            current_group_open\
    \ -= 1;\n            current_group.push(c);\n            if current_group_open\
    \ == 0 {\n                result.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0hyu9v2o.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut group = String::new();\n    let\
    \ mut open_parens = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            open_parens += 1;\n            group.push(c);\n        } else\
    \ if c == ')' {\n            open_parens -= 1;\n            group.push(c);\n \
    \           if open_parens == 0 {\n                result.push(group);\n     \
    \           group = String::new();\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_string.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     result.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            if paren_count == 0 {\n           \
    \     result.push(current_group);\n                current_group = String::new();\n\
    \            }\n        }\n    }\n    result.push(current_group);\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Unexpected character in paren string: {}\", c);\n        }\n\
    \        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1urk4cl7.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Unexpected character in paren string: {}\", c);\n        }\n\
    \        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            panic!(\"Invalid character in input string: {}\"\
    , c);\n        }\n    }\n    if open_parens != 0 {\n        panic!(\"Unbalanced\
    \ parentheses in input string\");\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp89ms6xof.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0ize_s9n.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph_y4k959.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            if open_parens == 0 {\n           \
    \     panic!(\"Unbalanced parentheses\");\n            }\n            open_parens\
    \ -= 1;\n            current_group.push(c);\n            if open_parens == 0 {\n\
    \                paren_groups.push(current_group);\n                current_group\
    \ = String::new();\n            }\n        }\n    }\n    if open_parens != 0 {\n\
    \        panic!(\"Unbalanced parentheses\");\n    }\n    paren_groups\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \        }\n        if open_parens == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpj35if518.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Unexpected character: {}\", c);\n        }\n        if paren_count\
    \ == 0 {\n            result.push(current_group);\n            current_group =\
    \ String::new();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Unexpected character in input string: {}\", c);\n        }\n\
    \        if paren_count == 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        }\n        if paren_count == 0 && current_group.len() > 0 {\n       \
    \     paren_groups.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       panic!(\"Invalid character in paren string\");\n        }\n        if\
    \ paren_count == 0 {\n            groups.push(current_group.clone());\n      \
    \      current_group.clear();\n        }\n    }\n    groups\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
