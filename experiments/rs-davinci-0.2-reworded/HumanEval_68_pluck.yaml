name: HumanEval_68_pluck
language: rs
prompt: "/// \"Given a vector representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
  \ its index ],\n/// If there are no even values or the given vector is empty, return\
  \ [].\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// >>> pluck(vec![1, 2, 3])\n\
  /// vec![2, 1]\n/// >>> pluck(vec![])\n/// vec![]\n/// >>> pluck(vec![5, 0, 3, 0,\
  \ 4, 2])\n/// vec![0, 1]\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n///\
  \ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
  \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
  \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]),\
  \ vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n  \
  \  assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
  \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
completions: ["    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes:\
    \ Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n     \
    \   if v % 2 == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let mut min_even_index =\
    \ 0;\n    for (i, v) in evens.iter().enumerate() {\n        if v == min_even {\n\
    \            min_even_index = i;\n            break;\n        }\n    }\n    vec![*min_even,\
    \ even_indexes[min_even_index] as isize]", "    let mut evens: Vec<isize> = arr\n\
    \        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n\
    \        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n    evens.sort();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens[0].clone()",
  "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n        .collect();\n    evens.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let (i, x) = evens[0];\n    vec![x, i as isize]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2\
    \ == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n  \
    \  evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n    } else\
    \ {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n  \
    \  let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_index = 0;\n   \
    \ for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n < min_even\
    \ {\n            min_even = *n;\n            min_even_index = i;\n        }\n\
    \    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else {\n \
    \       vec![min_even, min_even_index as isize]\n    }", "    let mut even_nums:\
    \ Vec<isize> = Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n\
    \    for (i, num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n   \
    \         even_nums.push(*num);\n            even_nums_index.push(i);\n      \
    \  }\n    }\n    if even_nums.len() == 0 {\n        return vec![];\n    }\n  \
    \  let min_even_num = even_nums.iter().min().unwrap();\n    let min_even_num_index\
    \ = even_nums_index[even_nums.iter().position(|&r| r == *min_even_num).unwrap()];\n\
    \    vec![*min_even_num, min_even_num_index as isize]", "    let mut even_nums:\
    \ Vec<isize> = Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n\
    \    for (index, num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n\
    \            even_nums.push(*num);\n            even_nums_index.push(index);\n\
    \        }\n    }\n    if even_nums.len() == 0 {\n        return vec![];\n   \
    \ }\n    let min_even_num = even_nums.iter().min().unwrap();\n    let min_even_num_index\
    \ = even_nums_index[even_nums.iter().position(|&x| x == *min_even_num).unwrap()];\n\
    \    vec![*min_even_num, min_even_num_index as isize]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2\
    \ == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n  \
    \  evens.sort();\n    if evens.len() == 0 {\n        vec![]\n    } else {\n  \
    \      evens[0].clone()\n    }", "    let mut evens: Vec<isize> = arr\n      \
    \  .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n     \
    \   .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n    evens.sort();\n\
    \    if evens.len() == 0 {\n        vec![]\n    } else {\n        evens[0].clone()\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_idx: Vec<usize>\
    \ = Vec::new();\n    for (idx, val) in arr.iter().enumerate() {\n        if val\
    \ % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min = evens[0];\n    let mut min_idx = even_idx[0];\n    for (idx,\
    \ val) in evens.iter().enumerate() {\n        if val < &min {\n            min\
    \ = *val;\n            min_idx = even_idx[idx];\n        }\n    }\n    vec![min,\
    \ min_idx as isize]", "    let mut evens: Vec<isize> = Vec::new();\n    let mut\
    \ even_indexes: Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut even_nodes: Vec<(isize, usize)> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| (*x, i))\n      \
    \  .collect();\n    even_nodes.sort();\n    if even_nodes.is_empty() {\n     \
    \   vec![]\n    } else {\n        vec![even_nodes[0].0, even_nodes[0].1 as isize]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n     \
    \   .collect();\n    evens.sort_by(|a, b| a.1.cmp(&b.1));\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    vec![evens[0].1, evens[0].0 as isize]",
  "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indices: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indices.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indices[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n        .collect();\n    evens.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    vec![evens[0].1, evens[0].0 as isize]", "    let mut evens: Vec<isize> =\
    \ Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2 ==\
    \ 0 {\n            evens.push(i as isize);\n        }\n    }\n    if evens.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut min = evens[0];\n    for\
    \ i in evens {\n        if arr[i as usize] < arr[min as usize] {\n           \
    \ min = i;\n        }\n    }\n    vec![arr[min as usize], min]", "    let mut\
    \ evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n    }\
    \ else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indices: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indices.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min_even = evens[0];\n    let mut min_even_index = even_indices[0];\n\
    \    for (i, n) in evens.iter().enumerate() {\n        if n < &min_even {\n  \
    \          min_even = *n;\n            min_even_index = even_indices[i];\n   \
    \     }\n    }\n    vec![min_even, min_even_index as isize]", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n      \
    \      evens.push(x);\n            even_indexes.push(i);\n        }\n    }\n \
    \   if evens.len() == 0 {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let mut min_even_index = 0;\n    for (i, &x) in evens.iter().enumerate()\
    \ {\n        if x == *min_even {\n            min_even_index = i;\n          \
    \  break;\n        }\n    }\n    vec![*min_even, even_indexes[min_even_index]\
    \ as isize]", "    let mut min_even = None;\n    let mut min_even_idx = None;\n\
    \    for (idx, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n     \
    \       if min_even.is_none() || n < min_even.unwrap() {\n                min_even\
    \ = Some(*n);\n                min_even_idx = Some(idx as isize);\n          \
    \  }\n        }\n    }\n    match (min_even, min_even_idx) {\n        (Some(n),\
    \ Some(idx)) => vec![n, idx],\n        _ => vec![],\n    }", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n    }\
    \ else {\n        vec![]\n    }", "    let mut even_nums: Vec<isize> = Vec::new();\n\
    \    let mut even_nums_index: Vec<usize> = Vec::new();\n    for (i, num) in arr.iter().enumerate()\
    \ {\n        if num % 2 == 0 {\n            even_nums.push(*num);\n          \
    \  even_nums_index.push(i);\n        }\n    }\n    if even_nums.len() == 0 {\n\
    \        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_index[even_nums.iter().position(|&r| r\
    \ == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    for (i, &x) in arr.iter().enumerate() {\n        if x % 2\
    \ == 0 {\n            evens.push(x);\n            evens.push(i as isize);\n  \
    \      }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n  \
    \  let mut min = evens[0];\n    let mut min_index = 0;\n    for (i, &x) in evens.iter().enumerate()\
    \ {\n        if i % 2 == 0 && x < min {\n            min = x;\n            min_index\
    \ = i;\n        }\n    }\n    vec![min, evens[min_index + 1]]", "    let mut min\
    \ = isize::max_value();\n    let mut idx = isize::max_value();\n    for (i, v)\
    \ in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min {\n         \
    \   min = *v;\n            idx = i as isize;\n        }\n    }\n    if min ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min, idx]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut result = vec![];\n    let\
    \ mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even != std::isize::MAX {\n        result.push(min_even);\n\
    \        result.push(min_even_idx);\n    }\n    result", "    let mut result =\
    \ vec![];\n    let mut min = isize::max_value();\n    let mut index = 0;\n   \
    \ for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min {\n\
    \            min = *v;\n            index = i;\n        }\n    }\n    if min !=\
    \ isize::max_value() {\n        result.push(min);\n        result.push(index as\
    \ isize);\n    }\n    result", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n       \
    \     evens.push(i as isize);\n        }\n    }\n    if evens.len() == 0 {\n \
    \       return vec![];\n    }\n    let mut min_index = evens[0];\n    for i in\
    \ evens {\n        if arr[i as usize] < arr[min_index as usize] {\n          \
    \  min_index = i;\n        }\n    }\n    vec![arr[min_index as usize], min_index]",
  "    let mut min_even = None;\n    let mut min_even_index = None;\n    for (i, v)\
    \ in arr.iter().enumerate() {\n        if v % 2 == 0 {\n            if min_even.is_none()\
    \ || v < min_even.unwrap() {\n                min_even = Some(*v);\n         \
    \       min_even_index = Some(i as isize);\n            }\n        }\n    }\n\
    \    match (min_even, min_even_index) {\n        (Some(min_even), Some(min_even_index))\
    \ => vec![min_even, min_even_index],\n        _ => vec![],\n    }", "    let mut\
    \ min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 ==\
    \ 0 && value < min_even {\n            min_even = value;\n            min_even_index\
    \ = index as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n\
    \        return vec![];\n    }\n    vec![min_even, min_even_index]", "    let\
    \ mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n       \
    \ .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let min_index\
    \ = evens.iter().min().unwrap();\n    let min_value = arr[*min_index as usize];\n\
    \    vec![min_value, *min_index]", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_idx: Vec<usize> = Vec::new();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let mut min_even_idx = 0;\n\
    \    for (idx, val) in evens.iter().enumerate() {\n        if val == min_even\
    \ {\n            min_even_idx = idx;\n            break;\n        }\n    }\n \
    \   vec![*min_even, even_idx[min_even_idx] as isize]", "    let mut min_even =\
    \ std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n    for (i,\
    \ &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even {\n \
    \           min_even = x;\n            min_even_index = i as isize;\n        }\n\
    \    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else {\n \
    \       vec![min_even, min_even_index]\n    }", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            evens.push(*n);\n\
    \            even_indexes.push(i);\n        }\n    }\n    if evens.len() == 0\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }", "    let mut min_even = std::isize::MAX;\n    let mut min_even_index =\
    \ std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate() {\n        if x\
    \ % 2 == 0 && x < min_even {\n            min_even = x;\n            min_even_index\
    \ = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n    \
    \    return vec![];\n    }\n    vec![min_even, min_even_index]", "    let mut\
    \ evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]",
  "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_idx: Vec<usize> =\
    \ Vec::new();\n    for (idx, val) in arr.iter().enumerate() {\n        if val\
    \ % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = even_idx[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut index: Vec<usize> = Vec::new();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(*x);\n            index.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min = evens[0];\n    let mut min_index = index[0];\n    for (i, x)\
    \ in evens.iter().enumerate() {\n        if x < &min {\n            min = *x;\n\
    \            min_index = index[i];\n        }\n    }\n    vec![min, min_index\
    \ as isize]", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx\
    \ = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate() {\n      \
    \  if val % 2 == 0 && val < min_even {\n            min_even = val;\n        \
    \    min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }",
  "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n  \
    \      .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i,\
    \ v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n            evens.push(*v);\n\
    \            even_indexes.push(i);\n        }\n    }\n    if evens.len() == 0\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut min_even = None;\n\
    \    let mut min_even_index = None;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 {\n            if min_even.is_none() || value <\
    \ min_even.unwrap() {\n                min_even = Some(*value);\n            \
    \    min_even_index = Some(index as isize);\n            }\n        }\n    }\n\
    \    match (min_even, min_even_index) {\n        (Some(min_even), Some(min_even_index))\
    \ => vec![min_even, min_even_index],\n        _ => vec![],\n    }", "    let mut\
    \ min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_index: Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(*v);\n            even_index.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_idx = 0;\n    for\
    \ (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val < &min_even\
    \ {\n            min_even = *val;\n            min_even_idx = idx;\n        }\n\
    \    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else {\n \
    \       vec![min_even, min_even_idx as isize]\n    }", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    evens[0].clone()", "    let mut evens: Vec<isize> = Vec::new();\n    let\
    \ mut even_indices: Vec<usize> = Vec::new();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(*x);\n            even_indices.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indices[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    let mut index: Vec<usize> = Vec::new();\n    for\
    \ (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n            evens.push(*x);\n\
    \            index.push(i);\n        }\n    }\n    if evens.len() == 0 {\n   \
    \     return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_index = index[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_index as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut indices: Vec<usize>\
    \ = Vec::new();\n    for (i, x) in arr.iter().enumerate() {\n        if x % 2\
    \ == 0 {\n            evens.push(*x);\n            indices.push(i);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min = evens[0];\n    let mut min_index = indices[0];\n    for (i, x) in evens.iter().enumerate()\
    \ {\n        if x < &min {\n            min = *x;\n            min_index = indices[i];\n\
    \        }\n    }\n    vec![min, min_index as isize]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]",
  "    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if *val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n      \
    \      evens.push(x);\n            even_indexes.push(i);\n        }\n    }\n \
    \   if evens.len() == 0 {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut even_nodes: Vec<(isize, usize)> = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n        .collect();\n\
    \    even_nodes.sort_by(|a, b| a.0.cmp(&b.0));\n    if even_nodes.is_empty() {\n\
    \        return vec![];\n    }\n    let (value, index) = even_nodes[0];\n    vec![value,\
    \ index as isize]", "    let mut evens: Vec<isize> = Vec::new();\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            evens.push(arr[i]);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min = evens[0];\n    let mut min_index = 0;\n    for i in 0..evens.len()\
    \ {\n        if evens[i] < min {\n            min = evens[i];\n            min_index\
    \ = i;\n        }\n    }\n    return vec![min, min_index as isize];", "    let\
    \ mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> =\
    \ Vec::new();\n    for (i, &n) in arr.iter().enumerate() {\n        if n % 2 ==\
    \ 0 {\n            evens.push(n);\n            even_indexes.push(i);\n       \
    \ }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n    let\
    \ min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]", "    let mut even_nums: Vec<isize>\
    \ = Vec::new();\n    let mut even_nums_indexes: Vec<usize> = Vec::new();\n   \
    \ for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n          \
    \  even_nums.push(*n);\n            even_nums_indexes.push(i);\n        }\n  \
    \  }\n    if even_nums.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min_even_num = even_nums[0];\n    let mut min_even_num_index = even_nums_indexes[0];\n\
    \    for (i, n) in even_nums.iter().enumerate() {\n        if n < &min_even_num\
    \ {\n            min_even_num = *n;\n            min_even_num_index = even_nums_indexes[i];\n\
    \        }\n    }\n    vec![min_even_num, min_even_num_index as isize]", "   \
    \ let mut evens: Vec<isize> = Vec::new();\n    let mut even_indices: Vec<usize>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2\
    \ == 0 {\n            evens.push(*n);\n            even_indices.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indices[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_idx: Vec<usize>\
    \ = Vec::new();\n    for (idx, val) in arr.iter().enumerate() {\n        if val\
    \ % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = even_idx[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() == 0 {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2\
    \ == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n  \
    \  evens.sort();\n    if evens.len() == 0 {\n        vec![]\n    } else {\n  \
    \      evens[0].clone()\n    }", "    let mut evens: Vec<isize> = arr\n      \
    \  .iter()\n        .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n    \
    \    .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n    evens.sort();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens[0].clone()",
  "    let mut evens: Vec<isize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let min_index\
    \ = evens.iter().min().unwrap();\n    let min_value = arr[*min_index as usize];\n\
    \    vec![min_value, *min_index]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut result = vec![];\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even !=\
    \ std::isize::MAX {\n        result.push(min_even);\n        result.push(min_even_index);\n\
    \    }\n    result", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx\
    \ = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n       \
    \ if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n       \
    \     min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]", "    let\
    \ mut evens: Vec<isize> = Vec::new();\n    let mut even_indices: Vec<usize> =\
    \ Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2 ==\
    \ 0 {\n            evens.push(*v);\n            even_indices.push(i);\n      \
    \  }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut min_even = evens[0];\n    let mut min_even_index = even_indices[0];\n  \
    \  for (i, v) in evens.iter().enumerate() {\n        if v < &min_even {\n    \
    \        min_even = *v;\n            min_even_index = even_indices[i];\n     \
    \   }\n    }\n    vec![min_even, min_even_index as isize]", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut evens: Vec<isize> = arr\n    \
    \    .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n   \
    \     .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n    evens.sort();\n\
    \    if evens.len() > 0 {\n        evens[0].clone()\n    } else {\n        vec![]\n\
    \    }", "    let mut even_nodes: Vec<(isize, usize)> = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i,\
    \ x)| (*x, i))\n        .collect();\n    even_nodes.sort();\n    if even_nodes.is_empty()\
    \ {\n        vec![]\n    } else {\n        vec![even_nodes[0].0, even_nodes[0].1\
    \ as isize]\n    }", "    let mut min_even = isize::max_value();\n    let mut\
    \ min_even_index = isize::max_value();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes:\
    \ Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n     \
    \   if v % 2 == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let mut min_even_indexes:\
    \ Vec<usize> = Vec::new();\n    for (i, v) in evens.iter().enumerate() {\n   \
    \     if v == min_even {\n            min_even_indexes.push(even_indexes[i]);\n\
    \        }\n    }\n    let min_even_index = min_even_indexes.iter().min().unwrap();\n\
    \    vec![*min_even, *min_even_index as isize]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i,\
    \ x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n            evens.push(*x);\n\
    \            even_indexes.push(i);\n        }\n    }\n    if evens.len() > 0 {\n\
    \        let min_even = evens.iter().min().unwrap();\n        let min_even_index\
    \ = evens.iter().position(|&x| x == *min_even).unwrap();\n        vec![*min_even,\
    \ even_indexes[min_even_index] as isize]\n    } else {\n        vec![]\n    }",
  "    let mut result = vec![];\n    let mut min_even = isize::max_value();\n    let\
    \ mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even !=\
    \ isize::max_value() {\n        result.push(min_even);\n        result.push(min_even_idx);\n\
    \    }\n    result", "    let mut evens: Vec<isize> = Vec::new();\n    let mut\
    \ even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]",
  "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n  \
    \      .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min_index = evens[0];\n    for i in evens {\n        if arr[i as usize] < arr[min_index\
    \ as usize] {\n            min_index = i;\n        }\n    }\n    vec![arr[min_index\
    \ as usize], min_index]", "    let mut min_even = std::isize::MAX;\n    let mut\
    \ min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]",
  "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]", "   \
    \ let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n   \
    \     .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min = evens[0];\n    for i in evens {\n        if arr[i as usize] < arr[min\
    \ as usize] {\n            min = i;\n        }\n    }\n    vec![arr[min as usize],\
    \ min]", "    let mut min_even = std::isize::MAX;\n    let mut min_even_index\
    \ = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate() {\n        if v\
    \ % 2 == 0 && v < &min_even {\n            min_even = *v;\n            min_even_index\
    \ = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n    \
    \    vec![]\n    } else {\n        vec![min_even, min_even_index]\n    }", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n     \
    \   if v % 2 == 0 {\n            evens.push(i as isize);\n        }\n    }\n \
    \   if evens.len() == 0 {\n        return vec![];\n    }\n    let min_index =\
    \ evens.iter().min().unwrap();\n    vec![arr[*min_index as usize], *min_index]",
  "    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == isize::max_value() {\n     \
    \   return vec![];\n    }\n    vec![min_even, min_even_idx]", "    let mut even_nums:\
    \ Vec<isize> = Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n\
    \    for (i, num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n   \
    \         even_nums.push(*num);\n            even_nums_index.push(i);\n      \
    \  }\n    }\n    if even_nums.len() == 0 {\n        return vec![];\n    }\n  \
    \  let min_even_num = even_nums.iter().min().unwrap();\n    let min_even_num_index\
    \ = even_nums_index[even_nums.iter().position(|&x| x == *min_even_num).unwrap()];\n\
    \    vec![*min_even_num, min_even_num_index as isize]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            evens.push(*n);\n\
    \            even_indexes.push(i);\n        }\n    }\n    if evens.len() == 0\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let mut min_index = 0;\n    for (i, n) in evens.iter().enumerate() {\n  \
    \      if n == min_even {\n            min_index = i;\n            break;\n  \
    \      }\n    }\n    vec![*min_even, even_indexes[min_index] as isize]", "   \
    \ let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, &x) in arr.iter().enumerate() {\n        if x % 2\
    \ == 0 {\n            evens.push(x);\n            even_indexes.push(i);\n    \
    \    }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let\
    \ min_even = evens.iter().min().unwrap();\n    let mut min_even_index = 0;\n \
    \   for (i, &x) in evens.iter().enumerate() {\n        if x == *min_even {\n \
    \           min_even_index = i;\n            break;\n        }\n    }\n    vec![*min_even,\
    \ even_indexes[min_even_index] as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|&(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut min_even = None;\n\
    \    let mut min_even_idx = None;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            match min_even {\n               \
    \ None => {\n                    min_even = Some(*val);\n                    min_even_idx\
    \ = Some(idx);\n                }\n                Some(min) => {\n          \
    \          if *val < min {\n                        min_even = Some(*val);\n \
    \                       min_even_idx = Some(idx);\n                    }\n   \
    \             }\n            }\n        }\n    }\n    match (min_even, min_even_idx)\
    \ {\n        (Some(min), Some(idx)) => vec![min, idx as isize],\n        _ =>\
    \ vec![],\n    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n   \
    \     .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)|\
    \ vec![*x, i as isize])\n        .collect();\n    evens.sort();\n    if evens.len()\
    \ > 0 {\n        evens[0].clone()\n    } else {\n        vec![]\n    }", "   \
    \ let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let mut min_index = 0;\n  \
    \  for (i, v) in evens.iter().enumerate() {\n        if v == min_even {\n    \
    \        min_index = i;\n            break;\n        }\n    }\n    vec![*min_even,\
    \ even_indexes[min_index] as isize]", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n    }\
    \ else {\n        vec![]\n    }", "    let mut even_nums: Vec<isize> = Vec::new();\n\
    \    let mut even_nums_indexes: Vec<usize> = Vec::new();\n    for (i, num) in\
    \ arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(*num);\n\
    \            even_nums_indexes.push(i);\n        }\n    }\n    if even_nums.len()\
    \ == 0 {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_indexes[even_nums.iter().position(|&x|\
    \ x == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(*x);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2\
    \ == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    evens.sort_by(|a, b| a[0].cmp(&b[0]));\n    evens[0].clone()", "    let mut\
    \ evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n       \
    \     evens.push(*x);\n            even_indexes.push(i);\n        }\n    }\n \
    \   if evens.len() == 0 {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(i as isize);\n        }\n    }\n    if evens.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut min_index = evens[0];\n \
    \   for i in evens {\n        if arr[i as usize] < arr[min_index as usize] {\n\
    \            min_index = i;\n        }\n    }\n    vec![arr[min_index as usize],\
    \ min_index]", "    let mut even = None;\n    let mut index = None;\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            if even.is_none()\
    \ || n < &even.unwrap() {\n                even = Some(*n);\n                index\
    \ = Some(i as isize);\n            }\n        }\n    }\n    match (even, index)\
    \ {\n        (Some(e), Some(i)) => vec![e, i],\n        _ => vec![],\n    }",
  "    let mut even_nums: Vec<isize> = Vec::new();\n    let mut even_nums_idx: Vec<usize>\
    \ = Vec::new();\n    for (idx, num) in arr.iter().enumerate() {\n        if num\
    \ % 2 == 0 {\n            even_nums.push(*num);\n            even_nums_idx.push(idx);\n\
    \        }\n    }\n    if even_nums.len() == 0 {\n        return vec![];\n   \
    \ }\n    let min_even_num = even_nums.iter().min().unwrap();\n    let min_even_num_idx\
    \ = even_nums_idx[even_nums.iter().position(|&r| r == *min_even_num).unwrap()];\n\
    \    vec![*min_even_num, min_even_num_idx as isize]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| (i, x))\n        .collect();\n    evens.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    vec![evens[0].1, evens[0].0 as isize]", "    let mut even_nums: Vec<isize>\
    \ = vec![];\n    let mut even_idx: Vec<usize> = vec![];\n    for (idx, num) in\
    \ arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(*num);\n\
    \            even_idx.push(idx);\n        }\n    }\n    if even_nums.len() ==\
    \ 0 {\n        return vec![];\n    }\n    let mut min_idx = 0;\n    let mut min_num\
    \ = even_nums[0];\n    for (idx, num) in even_nums.iter().enumerate() {\n    \
    \    if num < &min_num {\n            min_num = *num;\n            min_idx = idx;\n\
    \        }\n    }\n    vec![min_num, even_idx[min_idx] as isize]", "    let mut\
    \ evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut min_even_value = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even_value {\n            min_even_value\
    \ = x;\n            min_even_index = i as isize;\n        }\n    }\n    if min_even_value\
    \ == isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even_value,\
    \ min_even_index]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n    let\
    \ mut even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n   \
    \ let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n      \
    \  .collect();\n    evens.sort_by(|a, b| a.1.cmp(&b.1));\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let (i, x) = evens[0];\n    vec![x, i\
    \ as isize]", "    let mut min_even = std::isize::MAX;\n    let mut min_even_index\
    \ = -1;\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 &&\
    \ n < &min_even {\n            min_even = *n;\n            min_even_index = i\
    \ as isize;\n        }\n    }\n    if min_even_index == -1 {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_index]\n    }", "    let mut min_even\
    \ = None;\n    let mut min_even_idx = None;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            if min_even.is_none() || val < min_even.unwrap()\
    \ {\n                min_even = Some(*val);\n                min_even_idx = Some(idx\
    \ as isize);\n            }\n        }\n    }\n    match (min_even, min_even_idx)\
    \ {\n        (Some(min_even), Some(min_even_idx)) => vec![min_even, min_even_idx],\n\
    \        _ => vec![],\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| (i, x))\n        .collect();\n    evens.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    vec![evens[0].1, evens[0].0 as isize]", "    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n     \
    \   .collect();\n    evens.sort_by(|a, b| a.1.cmp(&b.1));\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    vec![evens[0].1, evens[0].0 as isize]",
  "    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min\
    \ {\n            min = *n;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n       \
    \ vec![min, min_index]\n    }", "    let mut min_even = std::isize::MAX;\n   \
    \ let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]", "   \
    \ let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even_idx == isize::max_value() {\n \
    \       vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }", " \
    \   let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }", "    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx =\
    \ std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n        if\
    \ val % 2 == 0 && val < &min_even {\n            min_even = *val;\n          \
    \  min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }",
  "    let mut evens: Vec<isize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ min_index = evens[0];\n    for i in evens {\n        if arr[i as usize] < arr[min_index\
    \ as usize] {\n            min_index = i;\n        }\n    }\n    vec![arr[min_index\
    \ as usize], min_index]", "    let mut evens: Vec<isize> = Vec::new();\n    let\
    \ mut even_idx: Vec<usize> = Vec::new();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let mut min_idx = 0;\n \
    \   for (idx, val) in evens.iter().enumerate() {\n        if val == min_even {\n\
    \            min_idx = idx;\n            break;\n        }\n    }\n    vec![*min_even,\
    \ even_idx[min_idx] as isize]", "    let mut even_nums: Vec<isize> = Vec::new();\n\
    \    let mut even_nums_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            even_nums.push(*n);\n            even_nums_index.push(i);\n\
    \        }\n    }\n    if even_nums.len() == 0 {\n        return vec![];\n   \
    \ }\n    let min_even_num = even_nums.iter().min().unwrap();\n    let min_even_num_index\
    \ = even_nums_index[even_nums.iter().position(|&r| r == *min_even_num).unwrap()];\n\
    \    vec![*min_even_num, min_even_num_index as isize]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut evens: Vec<isize> = arr\n    \
    \    .iter()\n        .enumerate()\n        .filter(|&(_, x)| x % 2 == 0)\n  \
    \      .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n    evens.sort();\n\
    \    if evens.is_empty() {\n        vec![]\n    } else {\n        evens[0].clone()\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(i as isize);\n        }\n\
    \    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let min_index\
    \ = evens.iter().min().unwrap();\n    vec![arr[*min_index as usize], *min_index]",
  "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n  \
    \      .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indices: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indices.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indices[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n      \
    \  .collect();\n    evens.sort_by(|a, b| a.1.cmp(&b.1));\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    vec![evens[0].1, evens[0].0 as isize]",
  "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n  \
    \      .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n       \
    \     evens.push(i as isize);\n        }\n    }\n    if evens.len() == 0 {\n \
    \       return vec![];\n    }\n    let mut min = evens[0];\n    for i in evens\
    \ {\n        if arr[i as usize] < arr[min as usize] {\n            min = i;\n\
    \        }\n    }\n    vec![arr[min as usize], min]", "    let mut smallest_even\
    \ = None;\n    let mut smallest_even_index = None;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            if smallest_even.is_none() || v < smallest_even.unwrap()\
    \ {\n                smallest_even = Some(v);\n                smallest_even_index\
    \ = Some(i as isize);\n            }\n        }\n    }\n    match (smallest_even,\
    \ smallest_even_index) {\n        (Some(v), Some(i)) => vec![v, i],\n        _\
    \ => vec![],\n    }", "    let mut min = std::isize::MAX;\n    let mut min_idx\
    \ = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate() {\n      \
    \  if val % 2 == 0 && val < min {\n            min = val;\n            min_idx\
    \ = idx as isize;\n        }\n    }\n    if min == std::isize::MAX {\n       \
    \ return vec![];\n    }\n    vec![min, min_idx]", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2\
    \ == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n  \
    \  evens.sort();\n    evens.first().unwrap_or(&vec![]).to_vec()", "    let mut\
    \ evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.len() == 0 {\n        vec![]\n    } else {\n\
    \        evens[0].clone()\n    }", "    let mut evens: Vec<isize> = arr\n    \
    \    .iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n   \
    \     .map(|(i, x)| (i, x))\n        .collect();\n    evens.sort_by(|a, b| a.1.cmp(b.1));\n\
    \    match evens.first() {\n        Some(x) => vec![*x.1, x.0 as isize],\n   \
    \     None => vec![],\n    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i,\
    \ &x)| vec![x, i as isize])\n        .collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    evens[0].clone()", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n      \
    \      evens.push(x);\n            even_indexes.push(i);\n        }\n    }\n \
    \   if evens.len() == 0 {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&r| r == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i,\
    \ &x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n            evens.push(x);\n\
    \            even_indexes.push(i);\n        }\n    }\n    if evens.len() == 0\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = even_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && item < &min_even {\n            min_even = *item;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut min_even = isize::max_value();\n    let mut min_even_idx\
    \ = isize::max_value();\n    for (idx, val) in arr.iter().enumerate() {\n    \
    \    if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n    \
    \        min_even_idx = idx as isize;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }",
  "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut even_values:\
    \ Vec<isize> = vec![];\n    let mut even_indexes: Vec<usize> = vec![];\n    for\
    \ (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n  \
    \          even_values.push(*value);\n            even_indexes.push(index);\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let min_value = even_values.iter().min().unwrap();\n    let min_index\
    \ = even_indexes[even_values.iter().position(|&x| x == *min_value).unwrap()];\n\
    \    vec![*min_value, min_index as isize]", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_idx: Vec<usize>\
    \ = Vec::new();\n    for (idx, val) in arr.iter().enumerate() {\n        if val\
    \ % 2 == 0 {\n            evens.push(*val);\n            even_idx.push(idx);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min_even = evens[0];\n    let mut min_even_idx = even_idx[0];\n \
    \   for (idx, val) in evens.iter().enumerate() {\n        if val < &min_even {\n\
    \            min_even = *val;\n            min_even_idx = even_idx[idx];\n   \
    \     }\n    }\n    vec![min_even, min_even_idx as isize]", "    let mut evens:\
    \ Vec<isize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ v)| v % 2 == 0)\n        .map(|(i, v)| vec![*v, i as isize])\n        .collect();\n\
    \    evens.sort();\n    evens.first().unwrap_or(&vec![]).to_vec()", "    let mut\
    \ min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min_even\
    \ {\n            min_even = *x;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|&(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut evens: Vec<isize>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_, &x)| x %\
    \ 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n        .collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    evens[0].clone()", "    let mut evens: Vec<isize> = Vec::new();\n    let\
    \ mut even_indexes: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, &x) in arr.iter().enumerate() {\n        if x % 2\
    \ == 0 {\n            evens.push(x);\n            even_indexes.push(i);\n    \
    \    }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let\
    \ min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    evens.first().unwrap_or(&vec![]).to_vec()",
  "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n  \
    \      .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| (i, x))\n       \
    \ .collect();\n    evens.sort_by(|a, b| a.1.cmp(&b.1));\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let (i, x) = evens[0];\n    vec![x, i\
    \ as isize]", "    let mut even_nodes: Vec<(isize, usize)> = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, n)| n % 2 == 0)\n        .map(|(i,\
    \ n)| (*n, i))\n        .collect();\n    even_nodes.sort();\n    if even_nodes.is_empty()\
    \ {\n        return vec![];\n    }\n    let (n, i) = even_nodes[0];\n    vec![n,\
    \ i as isize]", "    let mut evens: Vec<isize> = arr\n        .iter()\n      \
    \  .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)|\
    \ vec![x, i as isize])\n        .collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        vec![]\n    } else {\n        evens[0].clone()\n    }", "    let\
    \ mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n       \
    \ .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() > 0 {\n        evens[0].clone()\n\
    \    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut even_indexes: Vec<usize> = Vec::new();\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::usize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \            if *n < min_even {\n                min_even = *n;\n            \
    \    min_even_index = i;\n            }\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index\
    \ as isize]", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| (i, x))\n       \
    \ .collect();\n    evens.sort_by(|a, b| a.1.cmp(b.1));\n    if evens.is_empty()\
    \ {\n        vec![]\n    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, &x)| x % 2 == 0)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        evens[0].clone()\n    }", "    let mut min_even = None;\n\
    \    let mut min_even_index = None;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            match min_even {\n                None\
    \ => {\n                    min_even = Some(*v);\n                    min_even_index\
    \ = Some(i);\n                }\n                Some(min) => {\n            \
    \        if *v < min {\n                        min_even = Some(*v);\n       \
    \                 min_even_index = Some(i);\n                    }\n         \
    \       }\n            }\n        }\n    }\n    match min_even {\n        None\
    \ => vec![],\n        Some(min) => vec![min, min_even_index.unwrap() as isize],\n\
    \    }", "    let mut even_nodes: Vec<(isize, usize)> = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n        .collect();\n\
    \    even_nodes.sort_by(|a, b| a.0.cmp(&b.0));\n    even_nodes.first().map_or(vec![],\
    \ |x| vec![x.0, x.1 as isize])", "    let mut min_even = std::isize::MAX;\n  \
    \  let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes:\
    \ Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n     \
    \   if n % 2 == 0 {\n            evens.push(*n);\n            even_indexes.push(i);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = even_indexes[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]", " \
    \   let mut evens: Vec<isize> = arr\n        .iter()\n        .enumerate()\n \
    \       .filter(|(_, x)| x % 2 == 0)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .collect();\n    evens.sort();\n    if evens.len() == 0 {\n        return\
    \ vec![];\n    }\n    evens[0].clone()"]
stop_tokens:
- "\n}"
