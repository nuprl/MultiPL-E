name: HumanEval_18_how_many_times
language: rs
results:
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let found = string.find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index = found.unwrap() + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpoif9lckn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp9k7vawc.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += 1;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if string_char == substring_char {\n\
    \            i += 1;\n            j += 1;\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        } else {\n    \
    \        if j == 0 {\n                i += 1;\n                string_char = string_chars.next();\n\
    \            } else {\n                j = 0;\n                string_chars =\
    \ string.chars().skip(i);\n                substring_chars = substring.chars();\n\
    \                string_char = string_chars.next();\n                substring_char\
    \ = substring_chars.next();\n            }\n        }\n        if substring_char.is_none()\
    \ {\n            count += 1;\n            j = 0;\n            string_chars = string.chars().skip(i);\n\
    \            substring_chars = substring.chars();\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfb3v0nz4.rs:28:32\n   |\n\
    12 |     let mut string_chars = string.chars();\n   |                        \
    \    -------------- expected due to this value\n...\n28 |                 string_chars\
    \ = string.chars().skip(i);\n   |                                ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Skip`\n   |\n   = note: expected struct\
    \ `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfb3v0nz4.rs:37:28\n   |\n12 |     let mut string_chars\
    \ = string.chars();\n   |                            -------------- expected due\
    \ to this value\n...\n37 |             string_chars = string.chars().skip(i);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found struct `Skip<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut sub_index = 0;\n \
    \   let mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut string_char = string_chars.next();\n    let mut substring_char =\
    \ substring_chars.next();\n    while let Some(c) = string_char {\n        if c\
    \ == substring_char.unwrap() {\n            if sub_index == 0 {\n            \
    \    index = count;\n            }\n            sub_index += 1;\n            substring_char\
    \ = substring_chars.next();\n        } else {\n            sub_index = 0;\n  \
    \          substring_chars = substring.chars();\n            substring_char =\
    \ substring_chars.next();\n        }\n        count += 1;\n        string_char\
    \ = string_chars.next();\n    }\n    if sub_index == substring.len() as isize\
    \ {\n        count - index\n    } else {\n        0\n    }\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpt85wlc03.rs:17:32\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_chars_iter\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_2 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_3 = substring_chars.clone();\n    let mut substring_chars_iter_4\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_5 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_6 = substring_chars.clone();\n    let mut substring_chars_iter_7\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_8 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_9 = substring_chars.clone();\n    let mut substring_chars_iter_10\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_11 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_12 = substring_chars.clone();\n    let mut substring_chars_iter_13\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_14 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_15 = substring_chars.clone();\n    let mut substring_chars_iter_16\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_17 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_18 = substring_chars.clone();\n    let mut substring_chars_iter_19\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_20 = substring_chars.clone();\n\
    \    let mut substring_chars_iter_21 = substring_chars.clone();\n    let mut substring_\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk0u0pb80.rs:34:23\n   |\n\
    34 |     let mut substring_\n   |                       ^ help: add `;` here\n\
    35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk0u0pb80.rs:8:57\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \    --------------                                       ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.next().unwrap()\
    \ {\n                    let mut i = index + 1;\n                    let mut sub_iter\
    \ = substring_chars.clone();\n                    loop {\n                   \
    \     match string_chars.nth(i) {\n                            Some(c) => {\n\
    \                                if c == sub_iter.next().unwrap() {\n        \
    \                            if sub_iter.next().is_none() {\n                \
    \                        count += 1;\n                                       \
    \ break;\n                                    }\n                            \
    \        i += 1;\n                                } else {\n                 \
    \                   break;\n                                }\n              \
    \              }\n                            None => break,\n               \
    \         }\n                    }\n                }\n                index +=\
    \ 1;\n            }\n            None => break,\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `substring_chars` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpjtfhalec.rs:16:25\n   |\n12 |     let substring_chars\
    \ = substring.chars();\n   |         --------------- help: consider changing this\
    \ to be mutable: `mut substring_chars`\n...\n16 |                 if c == substring_chars.next().unwrap()\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_iter = substring_chars.clone();\n\
    \    let mut substring_iter_clone = substring_chars.clone();\n    let mut substring_iter_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone =\
    \ substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n   \n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplgginb0i.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnjqd3me6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let found = string.find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        let found\
    \ = found.unwrap();\n        count += 1;\n        index += found + substring.len();\n\
    \        string = string[found + substring.len()..].to_string();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpyfuvwoj3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpaf9_fgsg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while pos < string_len {\n    \
    \    if &string[pos..pos + substring_len] == substring {\n            count +=\
    \ 1;\n            pos += substring_len;\n        } else {\n            pos +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let mut slice = &string[start..end];\n    while slice.contains(&substring)\
    \ {\n        count += 1;\n        start += 1;\n        end += 1;\n        slice\
    \ = &string[start..end];\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 1 is out of bounds of ``', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_of_substring = string.find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      let index_of_substring = index_of_substring.unwrap();\n        count +=\
    \ 1;\n        index += index_of_substring + substring.len();\n        string =\
    \ string[index_of_substring + substring.len()..].to_string();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp_qljdvf1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut substring_first_char\
    \ = substring_chars.next();\n    for c in string_chars {\n        if c == substring_first_char.unwrap()\
    \ {\n            let mut substring_chars_clone = substring_chars.clone();\n  \
    \          let mut string_chars_clone = string_chars.clone();\n            let\
    \ mut string_chars_clone_next = string_chars_clone.nth(index);\n            let\
    \ mut substring_chars_clone_next = substring_chars_clone.next();\n           \
    \ while substring_chars_clone_next == string_chars_clone_next {\n            \
    \    substring_chars_clone_next = substring_chars_clone.next();\n            \
    \    string_chars_clone_next = string_chars_clone.next();\n            }\n   \
    \         if substring_chars_clone_next == None {\n                count += 1;\n\
    \            }\n        }\n        index += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpseyk6zkj.rs:11:9\n\
    \   |\n11 |     let mut string_chars = string.chars();\n   |         ----^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpseyk6zkj.rs:13:9\n\
    \   |\n13 |     let mut substring_first_char = substring_chars.next();\n   | \
    \        ----^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |         help: remove this\
    \ `mut`\n\nerror[E0382]: borrow of moved value: `string_chars`\n   --> /tmp/tmpseyk6zkj.rs:17:42\n\
    \    |\n11  |     let mut string_chars = string.chars();\n    |         ----------------\
    \ move occurs because `string_chars` has type `Chars<'_>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for c in string_chars {\n    |            \
    \  ------------ `string_chars` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |             let mut string_chars_clone = string_chars.clone();\n  \
    \  |                                          ^^^^^^^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `string_chars`\n\nerror: aborting due to previous error;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxs8vtx9d.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    if string_len == 0 || substring_len\
    \ == 0 {\n        return 0;\n    }\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut string_char = string_chars.next();\n\
    \    let mut substring_char = substring_chars.next();\n    while string_char.is_some()\
    \ {\n        if string_char.unwrap() == substring_char.unwrap() {\n          \
    \  let mut i = index;\n            let mut j = 0;\n            let mut string_char\
    \ = string_chars.next();\n            let mut substring_char = substring_chars.next();\n\
    \            while string_char.is_some() && substring_char.is_some() {\n     \
    \           if string_char.unwrap() == substring_char.unwrap() {\n           \
    \         i += 1;\n                    j += 1;\n                    string_char\
    \ = string_chars.next();\n                    substring_char = substring_chars.next();\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if j == substring_len {\n                count += 1;\n\
    \            }\n            index += 1;\n            string_chars = string.chars().skip(index);\n\
    \            substring_chars = substring.chars();\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        } else {\n    \
    \        index += 1;\n            string_chars = string.chars().skip(index);\n\
    \            substring_chars = substring.chars();\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3g7v_5jc.rs:40:28\n   |\n\
    16 |     let mut string_chars = string.chars();\n   |                        \
    \    -------------- expected due to this value\n...\n40 |             string_chars\
    \ = string.chars().skip(index);\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Skip`\n   |\n   = note: expected struct\
    \ `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3g7v_5jc.rs:46:28\n   |\n16 |     let mut string_chars\
    \ = string.chars();\n   |                            -------------- expected due\
    \ to this value\n...\n46 |             string_chars = string.chars().skip(index);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found struct `Skip<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_of_substring = string.find(&substring);\n        if index_of_substring\
    \ == None {\n            break;\n        }\n        let index_of_substring = index_of_substring.unwrap();\n\
    \        string = string.split_off(index_of_substring + substring.len());\n  \
    \      count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8akciej1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if substring_char.is_some() {\n  \
    \          if string_char.unwrap() == substring_char.unwrap() {\n            \
    \    j += 1;\n                substring_char = substring_chars.next();\n     \
    \       } else {\n                i += j + 1;\n                j = 0;\n      \
    \          substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            count\
    \ += 1;\n            i += j + 1;\n            j = 0;\n            substring_chars\
    \ = substring.chars();\n            substring_char = substring_chars.next();\n\
    \        }\n        string_char = string_chars.nth(i);\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpq40o9zt7.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt3t6kmra.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyqpp918w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo8qp62ok.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmrgt8km6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwo3no33e.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeoib_trz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxc2wlw9_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_chars_iter\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone = substring_chars.clone();\n\
    \    let mut substring_chars_iter_clone_clone = substring_chars.clone();\n   \
    \ let mut substring_chars_iter_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_chars_iter_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_chars_iter_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone =\
    \ substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut subst\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mkfjb70.rs:27:18\n   |\n\
    27 |     let mut subst\n   |                  ^ help: add `;` here\n28 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_mkfjb70.rs:8:57\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \    --------------                                       ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    while index < string_len\
    \ {\n        let mut string_char = string_chars.next().unwrap();\n        let\
    \ mut substring_char = substring_chars.next().unwrap();\n        if string_char\
    \ == substring_char {\n            let mut i = index;\n            let mut j =\
    \ 0;\n            let mut match_found = true;\n            while j < substring_len\
    \ {\n                if string_chars.next().unwrap() != substring_chars.next().unwrap()\
    \ {\n                    match_found = false;\n                    break;\n  \
    \              }\n                i += 1;\n                j += 1;\n         \
    \   }\n            if match_found {\n                count += 1;\n           \
    \     index = i;\n            }\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp71ime6k0.rs:23:75\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp600gm83d.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj_dp21jw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt3bwcju0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + substring.len()..].to_string();\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpy4kp2z0u.rs:14:51\n\
    \   |\n14 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpy4kp2z0u.rs:13:20\n\
    \   |\n13 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpy4kp2z0u.rs:15:21\n   |\n15 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + 1..].to_string();\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp8y2y1icx.rs:13:51\n\
    \   |\n13 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8y2y1icx.rs:12:20\n\
    \   |\n12 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp8y2y1icx.rs:14:21\n   |\n14 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_option = string.find(&substring);\n        match index_option {\n    \
    \        Some(index) => {\n                count += 1;\n                string\
    \ = string[index + substring.len()..].to_string();\n            }\n          \
    \  None => {\n                break;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeqs10_j4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let string_chars: Vec<char> =\
    \ string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \    while i < string_chars.len() {\n        if string_chars[i] == substring_chars[0]\
    \ {\n            let mut j = 0;\n            while j < substring_chars.len() &&\
    \ i + j < string_chars.len() && string_chars[i + j] == substring_chars[j] {\n\
    \                j += 1;\n            }\n            if j == substring_chars.len()\
    \ {\n                count += 1;\n                i += j - 1;\n            }\n\
    \        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkdpcyfo2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        let s = &string[start..end];\n     \
    \   if s == substring {\n            count += 1;\n        }\n        start +=\
    \ 1;\n        end += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7h2bn4jt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9nme5dys.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppubtgz49.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0derqp6j.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if string[i..].starts_with(&substring) {\n            count += 1;\n    \
    \        i += substring.len();\n        } else {\n            i += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj591fgzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        let slice = &string[start..end];\n   \
    \     if slice == substring {\n            count += 1;\n            start += 1;\n\
    \            end += 1;\n        } else {\n            start += 1;\n          \
    \  end += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1n6q2aml.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl12wkv5u.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let found = string.find(&substring);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        index = found.unwrap() + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp7rw0qgyj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0e9_bcd6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if substring_char.is_some() {\n  \
    \          if string_char.unwrap() == substring_char.unwrap() {\n            \
    \    i += 1;\n                j += 1;\n                substring_char = substring_chars.next();\n\
    \            } else {\n                i = 0;\n                j = 0;\n      \
    \          substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            count\
    \ += 1;\n            i = 0;\n            j = 0;\n            substring_chars =\
    \ substring.chars();\n            substring_char = substring_chars.next();\n \
    \       }\n        string_char = string_chars.nth(i);\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiloea_19.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyp224i1n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.split_off(i + substring.len());\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptk6gljoz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let substring_len = substring.len();\n\
    \    let string_len = string.len();\n    while index < string_len {\n        if\
    \ string[index..].starts_with(&substring) {\n            count += 1;\n       \
    \     index += substring_len;\n        } else {\n            index += 1;\n   \
    \     }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxb0xca39.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbl44as2y.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsudcuh91.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpqm6ivmer.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxmyi8kzy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring_length;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpf9lrb8ft.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3_z5orru.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsn8sieu1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_of_substring = string.find(&substring);\n        if index_of_substring.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        let index_of_substring\
    \ = index_of_substring.unwrap();\n        string = string.chars().skip(index_of_substring\
    \ + substring.len()).collect();\n        index += index_of_substring + substring.len();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpbetw3djo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7sxzyh4q.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuyl2223v.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while let Some(string_char) = string_char {\n        if let Some(substring_char)\
    \ = substring_char {\n            if string_char == substring_char {\n       \
    \         i += 1;\n                j += 1;\n                substring_char = substring_chars.next();\n\
    \            } else {\n                i = 0;\n                j = 0;\n      \
    \          substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            count\
    \ += 1;\n            i = 0;\n            j = 0;\n            substring_chars =\
    \ substring.chars();\n            substring_char = substring_chars.next();\n \
    \       }\n        string_char = string_chars.next();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopajxpqu.rs:21:34\n   |\n\
    17 |         if let Some(substring_char) = substring_char {\n   |            \
    \         -------------- expected due to the type of this binding\n...\n21 | \
    \                substring_char = substring_chars.next();\n   |              \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpopajxpqu.rs:26:34\n   |\n17 |\
    \         if let Some(substring_char) = substring_char {\n   |               \
    \      -------------- expected due to the type of this binding\n...\n26 |    \
    \             substring_char = substring_chars.next();\n   |                 \
    \                 ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpopajxpqu.rs:35:23\n   |\n16 |\
    \     while let Some(string_char) = string_char {\n   |                    -----------\
    \ expected due to the type of this binding\n...\n35 |         string_char = string_chars.next();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvjg1cvtr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpry5ndcra.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let mut found = false;\n        for\
    \ (i, c) in substring.chars().enumerate() {\n            if string.chars().nth(index\
    \ + i) == Some(c) {\n                found = true;\n            } else {\n   \
    \             found = false;\n                break;\n            }\n        }\n\
    \        if found {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpqv1yjzu8.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut string_char = string_chars.next();\n\
    \    let mut substring_char = substring_chars.next();\n    while string_char.is_some()\
    \ {\n        if string_char == substring_char {\n            let mut i = 0;\n\
    \            let mut string_chars_clone = string_chars.clone();\n            let\
    \ mut substring_chars_clone = substring_chars.clone();\n            while i <\
    \ substring_len {\n                if string_chars_clone.next() != substring_chars_clone.next()\
    \ {\n                    break;\n                }\n                i += 1;\n\
    \            }\n            if i == substring_len {\n                count +=\
    \ 1;\n                index += i;\n                string_chars = string_chars.skip(i);\n\
    \                substring_chars = substring.chars();\n            } else {\n\
    \                index += 1;\n                string_chars = string_chars.skip(1);\n\
    \            }\n        } else {\n            index += 1;\n            string_chars\
    \ = string_chars.skip(1);\n        }\n        string_char = string_chars.next();\n\
    \        substring_char = substring_chars.next();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoh_asjli.rs:31:32\n   |\n\
    13 |     let mut string_chars = string.chars();\n   |                        \
    \    -------------- expected due to this value\n...\n31 |                 string_chars\
    \ = string_chars.skip(i);\n   |                                ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Skip`\n   |\n   = note: expected struct\
    \ `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoh_asjli.rs:35:32\n   |\n13 |     let mut string_chars\
    \ = string.chars();\n   |                            -------------- expected due\
    \ to this value\n...\n35 |                 string_chars = string_chars.skip(1);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoh_asjli.rs:39:28\n   |\n13 |     let mut string_chars = string.chars();\n\
    \   |                            -------------- expected due to this value\n...\n\
    39 |             string_chars = string_chars.skip(1);\n   |                  \
    \          ^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct `Skip`\n\
    \   |\n   = note: expected struct `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppgo4fl6z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() == c {\n   \
    \             found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxg75m82f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            index += i + substring.len();\n    \
    \        string = string[i + substring.len()..].to_string();\n        } else {\n\
    \            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpabh1js5j.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        let mut j = index;\n        while i < substring_len\
    \ && j < string_len && string.chars().nth(j).unwrap() == substring.chars().nth(i).unwrap()\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if i == substring_len\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo6nspr9i.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.split_off(substring.len());\n        } else {\n            string =\
    \ string.split_off(1);\n        }\n        index += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpou7nd3bv.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == c {\n                found = true;\n            } else {\n              \
    \  found = false;\n                break;\n            }\n        }\n        if\
    \ found {\n            count += 1;\n            index += substring.len();\n  \
    \      } else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxn47lnyr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxyjo92py.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjas513bx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpber3dwdu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpipc3dqsb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        index += i;\n    \
    \    string = string[(index + substring.len())..].to_string();\n        count\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 3 is out of bounds of `x`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut index = 0;\n    while index < string.len() {\n        let mut found\
    \ = false;\n        for (i, c) in substring.chars().enumerate() {\n          \
    \  if index + i >= string.len() {\n                break;\n            }\n   \
    \         if c != string.chars().nth(index + i).unwrap() {\n                break;\n\
    \            }\n            if i == substring.len() - 1 {\n                found\
    \ = true;\n            }\n        }\n        if found {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7mbfmaed.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if string_char == substring_char {\n\
    \            if j == 0 {\n                i += 1;\n            }\n           \
    \ j += 1;\n            substring_char = substring_chars.next();\n            if\
    \ substring_char.is_none() {\n                count += 1;\n                substring_chars\
    \ = substring.chars();\n                substring_char = substring_chars.next();\n\
    \                j = 0;\n            }\n        } else {\n            substring_chars\
    \ = substring.chars();\n            substring_char = substring_chars.next();\n\
    \            j = 0;\n        }\n        string_char = string_chars.next();\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2a27j2uh.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpag6yreqz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    while\
    \ let Some(string_char) = string_chars.next() {\n        if string_char == substring_chars.next().unwrap()\
    \ {\n            i += 1;\n            if i == substring.len() {\n            \
    \    count += 1;\n                i = 0;\n                substring_chars = substring.chars();\n\
    \            }\n        } else {\n            i = 0;\n            substring_chars\
    \ = substring.chars();\n        }\n        j += 1;\n        if j == string.len()\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpha6mkuo6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.next().unwrap()\
    \ {\n                    let mut i = 0;\n                    let mut sub_chars\
    \ = substring_chars.clone();\n                    let mut string_chars_clone =\
    \ string_chars.clone();\n                    loop {\n                        match\
    \ string_chars_clone.nth(i) {\n                            Some(c) => {\n    \
    \                            if c == sub_chars.next().unwrap() {\n           \
    \                         if sub_chars.clone().next() == None {\n            \
    \                            count += 1;\n                                   \
    \     index += 1;\n                                        break;\n          \
    \                          }\n                                    i += 1;\n  \
    \                              } else {\n                                    break;\n\
    \                                }\n                            }\n          \
    \                  None => break,\n                        }\n               \
    \     }\n                }\n                index += 1;\n            }\n     \
    \       None => break,\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpdx87_b7b.rs:23:58\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while let Some(c) = string_char {\n        if c == substring_char.unwrap()\
    \ {\n            i += 1;\n            j += 1;\n            if i == substring.len()\
    \ {\n                count += 1;\n                i = 0;\n                j =\
    \ 0;\n                substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            i =\
    \ 0;\n            j += 1;\n            substring_chars = substring.chars();\n\
    \            substring_char = substring_chars.next();\n        }\n        string_char\
    \ = string_chars.nth(j);\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpipgn6gkk.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index = string.find(&substring);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        string = string.split_off(index.unwrap() + substring.len());\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp7lk85wz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeerlyg0c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            index += substring.len();\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      index += 1;\n            string = string.chars().skip(1).collect();\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzpzur9al.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_option = string.find(&substring);\n\
    \        match index_option {\n            Some(index) => {\n                count\
    \ += 1;\n                string = string[index + substring.len()..].to_string();\n\
    \            }\n            None => {\n                break;\n            }\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8j0lh7z2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring_length;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpafcjo9qy.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_of_substring = string.find(&substring);\n        if index_of_substring.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index = index_of_substring.unwrap()\
    \ + 1;\n        string = string[index..].to_string();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpce7ngd0x.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppie7nkgo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        index += i;\n    \
    \    string = string[(index + substring.len())..].to_string();\n        count\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 3 is out of bounds of `x`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let substring_chars: Vec<char> =\
    \ substring.chars().collect();\n    let string_len = string_chars.len();\n   \
    \ let substring_len = substring_chars.len();\n    while i < string_len {\n   \
    \     if string_chars[i] == substring_chars[j] {\n            j += 1;\n      \
    \      if j == substring_len {\n                count += 1;\n                j\
    \ = 0;\n            }\n        } else {\n            j = 0;\n        }\n     \
    \   i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp34yawekx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let mut found = false;\n    while end <= string.len() {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n            found = true;\n       \
    \ }\n        start += 1;\n        end += 1;\n    }\n    if found {\n        count\n\
    \    } else {\n        -1\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmp5s7bada5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string\
    \ = string.chars().collect::<Vec<char>>();\n    let substring = substring.chars().collect::<Vec<char>>();\n\
    \    while i < string.len() {\n        if string[i] == substring[j] {\n      \
    \      j += 1;\n            if j == substring.len() {\n                count +=\
    \ 1;\n                j = 0;\n            }\n        } else {\n            j =\
    \ 0;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwi5fz8rq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + 1..].to_string();\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmputqr5707.rs:13:51\n\
    \   |\n13 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmputqr5707.rs:12:20\n\
    \   |\n12 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmputqr5707.rs:14:21\n   |\n14 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string.get(index..index + substring_len) == Some(&substring) {\n   \
    \         count += 1;\n            index += substring_len;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdb3h3mo5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if string_char == substring_char {\n\
    \            i += 1;\n            j += 1;\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        } else {\n    \
    \        if j == substring.len() {\n                count += 1;\n            \
    \    j = 0;\n                substring_chars = substring.chars();\n          \
    \      substring_char = substring_chars.next();\n            } else {\n      \
    \          i += 1;\n                string_char = string_chars.nth(i - j);\n \
    \               substring_char = substring_chars.next();\n            }\n    \
    \    }\n    }\n    if j == substring.len() {\n        count += 1;\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpag_6fvcm.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkwsky2b8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        let slice = &string[start..end];\n \
    \       if slice == substring {\n            count += 1;\n        }\n        start\
    \ += 1;\n        end += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_option = string.find(&substring);\n\
    \        if index_option.is_none() {\n            break;\n        }\n        let\
    \ index = index_option.unwrap();\n        count += 1;\n        string = string[index\
    \ + substring.len()..].to_string();\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpi60t3w4p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy92hxk_x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_of_substring = string.find(&substring);\n        if index_of_substring.is_none()\
    \ {\n            break;\n        }\n        index = index_of_substring.unwrap()\
    \ + 1;\n        string = string.get(index..).unwrap().to_string();\n        count\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpa1ec8g08.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring_len = substring.len();\n    while index < string.len() {\n\
    \        let index_of_substring = string.find(&substring);\n        if index_of_substring.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index = index_of_substring.unwrap()\
    \ + substring_len;\n        string = string[index..].to_string();\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpj2l1ywrh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.replacen(&substring, \"\"\
    , 1);\n        } else {\n            string = string.replacen(&string[..1], \"\
    \", 1);\n        }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp972q1yg6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = true;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() || string.chars().nth(index + i).unwrap()\
    \ != c {\n                found = false;\n                break;\n           \
    \ }\n        }\n        if found {\n            count += 1;\n            index\
    \ += substring.len();\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpczd6p7ev.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5xw4_dsc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    if substring_len == 1 {\n        count\n    } else {\n        count\
    \ - 1\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpcxbr9n7e.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let sub_len = substring.len();\n\
    \    let str_len = string.len();\n    while start + sub_len <= str_len {\n   \
    \     if &string[start..start + sub_len] == substring {\n            count +=\
    \ 1;\n            start += sub_len;\n        } else {\n            start += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxn7ic_0c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(pos) = string[index..].find(&substring) {\n         \
    \   count += 1;\n            index += pos + substring.len();\n        } else {\n\
    \            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdwpyyt7g.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut found\
    \ = false;\n    let mut string_chars = string.chars();\n    let mut substring_chars\
    \ = substring.chars();\n    while let Some(c) = string_chars.next() {\n      \
    \  if c == substring_chars.next().unwrap() {\n            if !found {\n      \
    \          found = true;\n                i = j;\n            }\n            j\
    \ += 1;\n        } else {\n            if found {\n                found = false;\n\
    \                count += 1;\n                string_chars = string[i + 1..].chars();\n\
    \                substring_chars = substring.chars();\n            }\n       \
    \     j += 1;\n        }\n    }\n    if found {\n        count += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpddcxvjco.rs:16:40\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string.get(index..index + substring_len) == Some(&substring) {\n   \
    \         count += 1;\n            index += substring_len;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpddn687ua.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if string.chars().nth(index + i) == Some(c) {\n             \
    \   found = true;\n            } else {\n                found = false;\n    \
    \            break;\n            }\n        }\n        if found {\n          \
    \  count += 1;\n            index += substring.len();\n        } else {\n    \
    \        index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpaum41xo1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmhp3j2pm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2kbanw31.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if &string[i..i + substring.len()] == substring {\n            count +=\
    \ 1;\n            i += substring.len();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if &string[index..index + substring_length] == substring {\n    \
    \        count += 1;\n            index += substring_length;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmjxqdcuc.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if &string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    if substring_len == 1 {\n        count as isize\n    } else {\n    \
    \    count - 1\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpqv0kvk0p.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = index;\n        let mut j = 0;\n        while i < string.len()\
    \ && j < substring.len() && string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if j == substring.len()\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut last_index = 0;\n\
    \    let mut string = string;\n    let substring = substring;\n    while index\
    \ < string.len() {\n        let index = string.find(&substring);\n        if index.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        last_index =\
    \ index.unwrap();\n        string = string.split_off(last_index + substring.len());\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpm6m7zam2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmphgl0jfln.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let len = string.len();\n    while end <= len {\n        if &string[start..end]\
    \ == substring {\n            count += 1;\n            start += 1;\n         \
    \   end += 1;\n        } else {\n            start += 1;\n            end += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        index += i;\n    \
    \    string = string[(index + substring.len())..].to_string();\n        count\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 3 is out of bounds of `x`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.split_off(i + substring.len());\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppe_dxk50.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index = string.find(&substring);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        let index = index.unwrap();\n        string = string[index + substring.len()..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprv4zht9o.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == c {\n                found = true;\n            } else {\n              \
    \  found = false;\n                break;\n            }\n        }\n        if\
    \ found {\n            count += 1;\n            index += substring.len();\n  \
    \      } else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp885b4irb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpw22wiqt0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if let Some(j) = string[i..].find(&substring) {\n            count += 1;\n\
    \            i += j + substring.len();\n        } else {\n            break;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz11w4x1t.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplo8r2zh7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptm8v9yql.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2zwnqizu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.clone().nth(0).unwrap()\
    \ {\n                    let mut string_chars_clone = string_chars.clone();\n\
    \                    let mut substring_chars_clone = substring_chars.clone();\n\
    \                    let mut i = 0;\n                    loop {\n            \
    \            match string_chars_clone.nth(i) {\n                            Some(c)\
    \ => {\n                                match substring_chars_clone.nth(i) {\n\
    \                                    Some(c2) => {\n                         \
    \               if c == c2 {\n                                            i +=\
    \ 1;\n                                        } else {\n                     \
    \                       break;\n                                        }\n  \
    \                                  }\n                                    None\
    \ => {\n                                        count += 1;\n                \
    \                        index += i;\n                                       \
    \ break;\n                                    }\n                            \
    \    }\n                            }\n                            None => {\n\
    \                                break;\n                            }\n     \
    \                   }\n                    }\n                }\n            }\n\
    \            None => {\n                break;\n            }\n        }\n   \
    \     index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpd50mu5xh.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplg7_t2l9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyqahufc5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4rjhvnv2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpacshwpbq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6pajk8us.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ {\n            if string.chars().nth(index + i).unwrap() != substring.chars().nth(i).unwrap()\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring_len {\n            count += 1;\n            index +=\
    \ i;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy8ohu6v_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + substring.len()..].to_string();\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpwd8zxbg_.rs:14:51\n\
    \   |\n14 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpwd8zxbg_.rs:13:20\n\
    \   |\n13 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpwd8zxbg_.rs:15:21\n   |\n15 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.chars().skip(i + substring.len()).collect();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdp_skn99.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjgm_pluo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzgk9w1zf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa8gq45h9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa07me14o.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let substring_length = substring.len();\n\
    \    let string_length = string.len();\n    while start + substring_length <=\
    \ string_length {\n        if string[start..start + substring_length] == substring\
    \ {\n            count += 1;\n            start += substring_length;\n       \
    \ } else {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpryhfh3jr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let sub_index = string[index..].find(&substring);\n        if sub_index.is_none()\
    \ {\n            break;\n        }\n        let sub_index = sub_index.unwrap();\n\
    \        index += sub_index + substring_len;\n        count += 1;\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnain6k4k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string.get(index..index + substring_len) == Some(&substring) {\n   \
    \         count += 1;\n            index += substring_len;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp6tk3ssy.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.split_off(i + substring.len());\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuuj5pl_l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_of_substring = string.find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      let index_of_substring = index_of_substring.unwrap();\n        string =\
    \ string.split_off(index_of_substring + substring.len());\n        count += 1;\n\
    \        index += index_of_substring + substring.len();\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmptn_y37hj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpst18qnip.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut start = 0;\n    while start < string.len() {\n     \
    \   if let Some(index) = string[start..].find(&substring) {\n            count\
    \ += 1;\n            start += index + substring.len();\n        } else {\n   \
    \         break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprrwag3mn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + 1..].to_string();\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpc5jaf11d.rs:13:51\n\
    \   |\n13 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpc5jaf11d.rs:12:20\n\
    \   |\n12 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpc5jaf11d.rs:14:21\n   |\n14 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(pos) = string.find(&substring) {\n        count += 1;\n  \
    \      index += pos + 1;\n        string = string[index..].to_string();\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 4 is out of bounds of `xyx`', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.clone().nth(0).unwrap()\
    \ {\n                    let mut i = 0;\n                    let mut string_chars_clone\
    \ = string_chars.clone();\n                    loop {\n                      \
    \  match substring_chars.clone().nth(i) {\n                            Some(c)\
    \ => {\n                                match string_chars_clone.nth(i) {\n  \
    \                                  Some(c2) => {\n                           \
    \             if c != c2 {\n                                            break;\n\
    \                                        }\n                                 \
    \   }\n                                    None => break,\n                  \
    \              }\n                            }\n                            None\
    \ => {\n                                count += 1;\n                        \
    \        index += 1;\n                                break;\n               \
    \             }\n                        }\n                        i += 1;\n\
    \                    }\n                }\n            }\n            None =>\
    \ break,\n        }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp326gv2ju.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += 1;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptgd2jryf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt9auf18m.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpr8l4ajz4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if &string[index..index + substring.len()] == substring {\n     \
    \       count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu7lu5lfz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_e2eabkt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_bytes = string.as_bytes();\n\
    \    let substring_bytes = substring.as_bytes();\n    while index < string_bytes.len()\
    \ {\n        if &string_bytes[index..index + substring_bytes.len()] == substring_bytes\
    \ {\n            count += 1;\n            index += substring_bytes.len();\n  \
    \      } else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 10 out of range for slice of\
    \ length 9', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.split_off(substring.len());\n        } else {\n            string =\
    \ string.split_off(1);\n        }\n        index += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjtzhst74.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp06sgdzkg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut string_char = string_chars.next();\n\
    \    let mut substring_char = substring_chars.next();\n    while index < string_len\
    \ {\n        if string_char == substring_char {\n            let mut i = index;\n\
    \            let mut j = 0;\n            while i < string_len && j < substring_len\
    \ {\n                if string_chars.next() == substring_chars.next() {\n    \
    \                i += 1;\n                    j += 1;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if j == substring_len {\n                count += 1;\n            }\n     \
    \   }\n        index += 1;\n        string_char = string_chars.next();\n     \
    \   substring_char = substring_chars.next();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4ke8a8bq.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplph01dhg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        let sub_str = &string[start..end];\n \
    \       if sub_str == substring {\n            count += 1;\n            start\
    \ += 1;\n            end += 1;\n        } else {\n            start += 1;\n  \
    \          end += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
